{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Splitties \u00b6 Splitties is a collection of small Kotlin multiplatform libraries (with Android as first target). These libraries are intended to reduce the amount of code you have to write, freeing code reading and writing time, so you can focus more on what you want to build for your users (even if you\u2019re the only one), or have more time to have fun . This project is named \u201cSplitties\u201d because it is split in small modules, distributed as independent libraries, so you can add only the ones you need to your project/module, helping reduce the size of the final binary that users devices will need to download and keep in the limited storage (BTW, everything is limited). Some Android targeting modules have a content similar to what Anko offers. See a short comparison of Splitties with Anko here . Each module has been designed to have a small footprint and be as efficient as possible. All the multiplatform splits \u00b6 Currently, only JVM (including Android) and JS are supported, but future Kotlin/Native support is considered (you can subscribe to this issue to get updated on that). Bit Flags: hasFlag , withFlag and minusFlag extensions on Long , Int , Short , Byte , and their unsigned counterparts. Collections: forEach for List s without Iterator allocation. Coroutines: General purpose extensions to kotlinx.coroutines. All the Android splits \u00b6 Activities: Start activities with minimal boilerplate. Alert Dialog: Create simple alert dialogs with simple code. Alert Dialog AppCompat: AppCompat version of Alert Dialog . Alert Dialog AppCompat Coroutines: showAndAwait extension functions for AppCompat AlertDialog. Alert Dialog Material: Material Components extension of Alert Dialog AppCompat . App Context: Always have your application Context at hand with appCtx . Arch Lifecycle: Extensions to get ViewModel s, use LiveData and observe Lifecycle s. Arch Room: Room helpers to instantiate your DB and perform transactions in Kotlin. Bundle: BundleSpec to use Bundle with property syntax for Intent extras and more. Checked Lazy: mainThreadLazy that checks property access on main thread, and checkedLazy to make your own variant. Dimensions: Android dp extensions for View and Context . Particularly handy when using Views DSL . Exceptions: unexpectedValue(\u2026) , unsupportedAction(\u2026) and similar functions that return Nothing . Fragments: Start activities from fragments and do transactions with minimal boilerplate. Fragment Args: Fragment arguments without ceremony thanks to delegated properties. Init Provider: Base class for ContentProvider s used for automatic initialization purposes. Intents: Transform companion object s into powerful typesafe intent specs, and create PendingIntent s the clean and easy way. Lifecycle Coroutines: Coroutines integration with AndroidX Lifecycle . Main Handler: Top-level mainHandler property to stop allocating multiple Handler s for main Looper . Main Thread: Properties and precondition checkers related to Android main thread. Material Colors: 2014 Material Design color palettes as color resources. Material Lists: List item Views implementing Material Design guidelines (perfect for usage in a RecyclerView ). Permissions: Request runtime permissions without polluting your codebase. Preferences: Property syntax for Android\u2019s SharedPreferences or iOS/macOS NSUserDefaults . Resources: Extensions to get resources like strings, colors or drawables easily, with support for themed attributes. Selectable Views: Selectable Views with foreground property before API 23. Selectable Views AppCompat: Selectable Views for AppCompatTextView. Selectable Views ConstraintLayout: Selectable Views for ConstraintLayout. Snackbar: Grab a snack without ceremony with snack(\u2026) and longSnack(\u2026) . Stetho init: Have Stetho for your debug builds, without writing any code! System Services: No more context.getSystemService(NAME_OF_SERVICE) as NameOfManager . Toast: Show a toast by just calling toast(yourText) , and dodge API 25 BadTokenException . Typesafe RecyclerView: Typesafe ViewHolder and ItemViewHolder for easy basic usage of RecyclerView . Views: Extensions function and properties on View s. Views AppCompat: AppCompat extension of Views . Includes helpers for ImageView tinting, ActionBar and tooltip. Views CardView: CardView extension of Views . Provides a contentPadding property. Views Coroutines: Android Views + Kotlin coroutines. Views Coroutines Material: Material Components + Kotlin coroutines. Views DSL: Create UIs with readable Kotlin code (IDE preview supported). Views DSL AppCompat: AppCompat extension of Views DSL . Views DSL ConstraintLayout: ConstraintLayout extension of Views DSL . Views DSL CoordinatorLayout: CoordinatorLayout extension of Views DSL . Views DSL Material: Material Components extension of Views DSL . Views DSL RecyclerView: RecyclerView extension of Views DSL . Views Material: Material Components extension of Views . Views RecyclerView: RecyclerView extension of Views . Download \u00b6 Gradle instructions \u00b6 Make sure you have jcenter() in the repositories defined in your project\u2019s (root) build.gradle file (default for new Android Studio projects). To make is easier to take advantage of the contents of Splitties for your Android projects, there are grouping artifacts that include most splits. Android base \u00b6 These 2 packs don\u2019t include AppCompat and are suitable for WearOS apps. Includes the following modules: - activities - appctx - bitflags - bundle - collections - dimensions - fragments - fragmentargs - intents - lifecycle-coroutines - mainhandler - mainthread - material-colors - permissions - preferences - resources - systemservices - toast - views - views-coroutines - views-recyclerview - views-selectable - views-selectable-constraintlayout Gradle dependency: implementation ( \"com.louiscad.splitties:splitties-fun-pack-android-base:3.0.0-alpha07\" ) There\u2019s also a version with Views DSL. It additionally includes the following modules: views-dsl views-dsl-constraintlayout views-dsl-recyclerview Gradle dependency: implementation ( \"com.louiscad.splitties:splitties-fun-pack-android-base-with-views-dsl:3.0.0-alpha07\" ) Android AppCompat \u00b6 These 2 packs include the Android base pack, and the following modules: - alertdialog-appcompat - alertdialog-appcompat-coroutines - views-appcompat - views-selectable-appcompat Gradle dependency: implementation ( \"com.louiscad.splitties:splitties-fun-pack-android-appcompat:3.0.0-alpha07\" ) There\u2019s also a version with Views DSL. It additionally includes the Views DSL version of the Android base pack and the following module: - views-dsl-appcompat Gradle dependency: implementation ( \"com.louiscad.splitties:splitties-fun-pack-android-appcompat-with-views-dsl:3.0.0-alpha07\" ) Android Material Components \u00b6 These 2 packs include the Android AppCompat pack, and the following modules: - material-lists - snackbar - views-cardview - views-coroutines-material - views-material Gradle dependency: implementation ( \"com.louiscad.splitties:splitties-fun-pack-android-material-components:3.0.0-alpha07\" ) There\u2019s also a version with Views DSL. It additionally includes the Views DSL version of the Android AppCompat pack and the following modules: - views-dsl-coordinatorlayout - views-dsl-material Gradle dependency: implementation ( \"com.louiscad.splitties:splitties-fun-pack-android-material-components-with-views-dsl:3.0.0-alpha07\" ) All the artifacts (47) \u00b6 Add the version of the library to not repeat yourself if you use multiple artifacts, and make sure their versions are in sync by adding an ext property into your root project build.gradle file: allProjects { ext { splitties_version = \"3.0.0-alpha07\" } } Here are all the artifacts of this library. Just use the ones you need. (Click to expand) implementation(\"com.louiscad.splitties:splitties-activities:3.0.0-beta01\") implementation(\"com.louiscad.splitties:splitties-alertdialog:3.0.0-beta01\") implementation(\"com.louiscad.splitties:splitties-alertdialog-appcompat:3.0.0-beta01\") implementation(\"com.louiscad.splitties:splitties-alertdialog-appcompat-coroutines:3.0.0-beta01\") implementation(\"com.louiscad.splitties:splitties-appctx:3.0.0-beta01\") implementation(\"com.louiscad.splitties:splitties-arch-lifecycle:3.0.0-beta01\") implementation(\"com.louiscad.splitties:splitties-arch-room:3.0.0-beta01\") implementation(\"com.louiscad.splitties:splitties-bitflags:3.0.0-beta01\") implementation(\"com.louiscad.splitties:splitties-bundle:3.0.0-beta01\") implementation(\"com.louiscad.splitties:splitties-checkedlazy:3.0.0-beta01\") implementation(\"com.louiscad.splitties:splitties-collections:3.0.0-beta01\") implementation(\"com.louiscad.splitties:splitties-coroutines:3.0.0-beta01\") implementation(\"com.louiscad.splitties:splitties-dimensions:3.0.0-beta01\") implementation(\"com.louiscad.splitties:splitties-exceptions:3.0.0-beta01\") implementation(\"com.louiscad.splitties:splitties-fragments:3.0.0-beta01\") implementation(\"com.louiscad.splitties:splitties-fragmentargs:3.0.0-beta01\") implementation(\"com.louiscad.splitties:splitties-initprovider:3.0.0-beta01\") implementation(\"com.louiscad.splitties:splitties-intents:3.0.0-beta01\") implementation(\"com.louiscad.splitties:splitties-lifecycle-coroutines:3.0.0-beta01\") implementation(\"com.louiscad.splitties:splitties-mainhandler:3.0.0-beta01\") implementation(\"com.louiscad.splitties:splitties-mainthread:3.0.0-beta01\") implementation(\"com.louiscad.splitties:splitties-material-colors:3.0.0-beta01\") implementation(\"com.louiscad.splitties:splitties-material-lists:3.0.0-beta01\") implementation(\"com.louiscad.splitties:splitties-permissions:3.0.0-beta01\") implementation(\"com.louiscad.splitties:splitties-preferences:3.0.0-beta01\") implementation(\"com.louiscad.splitties:splitties-resources:3.0.0-beta01\") implementation(\"com.louiscad.splitties:splitties-snackbar:3.0.0-beta01\") debugImplementation(\"com.louiscad.splitties:splitties-stetho-init:3.0.0-beta01\") implementation(\"com.louiscad.splitties:splitties-systemservices:3.0.0-beta01\") implementation(\"com.louiscad.splitties:splitties-toast:3.0.0-beta01\") implementation(\"com.louiscad.splitties:splitties-typesaferecyclerview:3.0.0-beta01\") implementation(\"com.louiscad.splitties:splitties-views:3.0.0-beta01\") implementation(\"com.louiscad.splitties:splitties-views-appcompat:3.0.0-beta01\") implementation(\"com.louiscad.splitties:splitties-views-cardview:3.0.0-beta01\") implementation(\"com.louiscad.splitties:splitties-views-coroutines:3.0.0-beta01\") implementation(\"com.louiscad.splitties:splitties-views-coroutines-material:3.0.0-beta01\") implementation(\"com.louiscad.splitties:splitties-views-dsl:3.0.0-beta01\") implementation(\"com.louiscad.splitties:splitties-views-dsl-appcompat:3.0.0-beta01\") implementation(\"com.louiscad.splitties:splitties-views-dsl-constraintlayout:3.0.0-beta01\") implementation(\"com.louiscad.splitties:splitties-views-dsl-coordinatorlayout:3.0.0-beta01\") debugImplementation(\"com.louiscad.splitties:splitties-views-dsl-ide-preview:3.0.0-beta01\") implementation(\"com.louiscad.splitties:splitties-views-dsl-material:3.0.0-beta01\") implementation(\"com.louiscad.splitties:splitties-views-dsl-recyclerview:3.0.0-beta01\") implementation(\"com.louiscad.splitties:splitties-views-material:3.0.0-beta01\") implementation(\"com.louiscad.splitties:splitties-views-recyclerview:3.0.0-beta01\") implementation(\"com.louiscad.splitties:splitties-views-selectable:3.0.0-beta01\") implementation(\"com.louiscad.splitties:splitties-views-selectable-appcompat:3.0.0-beta01\") implementation(\"com.louiscad.splitties:splitties-views-selectable-constraintlayout:3.0.0-beta01\") Dev versions \u00b6 Let\u2019s say you need a new feature or a fix that did not make it to a release yet: You can grab it in the latest dev version by adding the corresponding repository and changing the library version to the dev version you need in your root project build.gradle file: allProjects { repositories { google () jcenter () // Add dev versions repo below maven { url 'https://dl.bintray.com/louiscad/splitties-dev' } } ext { splitties_version = '3.0.0-dev-008' } } Other build systems \u00b6 For maven and alternative build-systems, check the Bintray page . New versions notifications \u00b6 Releases are announced on GitHub, you can subscribe by clicking on \u201cWatch\u201d, then \u201cReleases only\u201d . Improve this library \u00b6 If you want this library to have a new feature or an improvement in a new or in an existing module, please, open an issue or vote/comment a similar one first, so it can be discussed. Documentation contributions are also welcome. For typos or other small improvements, feel free to submit a PR (pull request) directly. For more significant doc contributions, please, open an issue first so it can be discussed. If you find a bug , please open an issue with all the important details. If you know a simple fix that is not API breaking and that does not have side-effects that need to be considered, you may also directly submit a PR. You can also join the discussion on Kotlin\u2019s Slack in the #splitties channel (you can get an invitation here ). What is a split \u00b6 A \u201csplit\u201d is a module of the Splitties library that you can add as a dependency. It only includes the required transitive dependencies. This allows you to only add what you need in your app or library module, so the final apk is as small as possible and doesn\u2019t include stuff not used by your app. Let\u2019s say you\u2019re build a Wear OS app using the Views DSL. Wear OS apps don\u2019t need AppCompat. Including it would be a waste of bandwidth and storage. The Views DSL core module relies on the Android SDK but not on AppCompat, so you don\u2019t bloat your wrist app with AppCompat by using Views DSL. However, if you are building a phone, tablet or computer Android app, there\u2019s a Views DSL AppCompat split with a few extensions for you to use. Credits \u00b6 Special thanks to Jovche Mitrejchevski for helping in taking decisions for this project. Thanks to JetBrains and the contributors for Anko , which was a great source of inspiration, especially for Views DSL, and of course thanks for the excellent Kotlin programming language that makes this project possible. Thanks to Doug Stevenson for his articles \u201cKotlin & Android: A Brass Tacks Experiment\u201d . It is fair to say that Views DSL has its root in this experiment. License \u00b6 This library is published under Apache License version 2.0 which you can see here .","title":"Splitties"},{"location":"#splitties","text":"Splitties is a collection of small Kotlin multiplatform libraries (with Android as first target). These libraries are intended to reduce the amount of code you have to write, freeing code reading and writing time, so you can focus more on what you want to build for your users (even if you\u2019re the only one), or have more time to have fun . This project is named \u201cSplitties\u201d because it is split in small modules, distributed as independent libraries, so you can add only the ones you need to your project/module, helping reduce the size of the final binary that users devices will need to download and keep in the limited storage (BTW, everything is limited). Some Android targeting modules have a content similar to what Anko offers. See a short comparison of Splitties with Anko here . Each module has been designed to have a small footprint and be as efficient as possible.","title":"Splitties"},{"location":"#all-the-multiplatform-splits","text":"Currently, only JVM (including Android) and JS are supported, but future Kotlin/Native support is considered (you can subscribe to this issue to get updated on that). Bit Flags: hasFlag , withFlag and minusFlag extensions on Long , Int , Short , Byte , and their unsigned counterparts. Collections: forEach for List s without Iterator allocation. Coroutines: General purpose extensions to kotlinx.coroutines.","title":"All the multiplatform splits"},{"location":"#all-the-android-splits","text":"Activities: Start activities with minimal boilerplate. Alert Dialog: Create simple alert dialogs with simple code. Alert Dialog AppCompat: AppCompat version of Alert Dialog . Alert Dialog AppCompat Coroutines: showAndAwait extension functions for AppCompat AlertDialog. Alert Dialog Material: Material Components extension of Alert Dialog AppCompat . App Context: Always have your application Context at hand with appCtx . Arch Lifecycle: Extensions to get ViewModel s, use LiveData and observe Lifecycle s. Arch Room: Room helpers to instantiate your DB and perform transactions in Kotlin. Bundle: BundleSpec to use Bundle with property syntax for Intent extras and more. Checked Lazy: mainThreadLazy that checks property access on main thread, and checkedLazy to make your own variant. Dimensions: Android dp extensions for View and Context . Particularly handy when using Views DSL . Exceptions: unexpectedValue(\u2026) , unsupportedAction(\u2026) and similar functions that return Nothing . Fragments: Start activities from fragments and do transactions with minimal boilerplate. Fragment Args: Fragment arguments without ceremony thanks to delegated properties. Init Provider: Base class for ContentProvider s used for automatic initialization purposes. Intents: Transform companion object s into powerful typesafe intent specs, and create PendingIntent s the clean and easy way. Lifecycle Coroutines: Coroutines integration with AndroidX Lifecycle . Main Handler: Top-level mainHandler property to stop allocating multiple Handler s for main Looper . Main Thread: Properties and precondition checkers related to Android main thread. Material Colors: 2014 Material Design color palettes as color resources. Material Lists: List item Views implementing Material Design guidelines (perfect for usage in a RecyclerView ). Permissions: Request runtime permissions without polluting your codebase. Preferences: Property syntax for Android\u2019s SharedPreferences or iOS/macOS NSUserDefaults . Resources: Extensions to get resources like strings, colors or drawables easily, with support for themed attributes. Selectable Views: Selectable Views with foreground property before API 23. Selectable Views AppCompat: Selectable Views for AppCompatTextView. Selectable Views ConstraintLayout: Selectable Views for ConstraintLayout. Snackbar: Grab a snack without ceremony with snack(\u2026) and longSnack(\u2026) . Stetho init: Have Stetho for your debug builds, without writing any code! System Services: No more context.getSystemService(NAME_OF_SERVICE) as NameOfManager . Toast: Show a toast by just calling toast(yourText) , and dodge API 25 BadTokenException . Typesafe RecyclerView: Typesafe ViewHolder and ItemViewHolder for easy basic usage of RecyclerView . Views: Extensions function and properties on View s. Views AppCompat: AppCompat extension of Views . Includes helpers for ImageView tinting, ActionBar and tooltip. Views CardView: CardView extension of Views . Provides a contentPadding property. Views Coroutines: Android Views + Kotlin coroutines. Views Coroutines Material: Material Components + Kotlin coroutines. Views DSL: Create UIs with readable Kotlin code (IDE preview supported). Views DSL AppCompat: AppCompat extension of Views DSL . Views DSL ConstraintLayout: ConstraintLayout extension of Views DSL . Views DSL CoordinatorLayout: CoordinatorLayout extension of Views DSL . Views DSL Material: Material Components extension of Views DSL . Views DSL RecyclerView: RecyclerView extension of Views DSL . Views Material: Material Components extension of Views . Views RecyclerView: RecyclerView extension of Views .","title":"All the Android splits"},{"location":"#download","text":"","title":"Download"},{"location":"#gradle-instructions","text":"Make sure you have jcenter() in the repositories defined in your project\u2019s (root) build.gradle file (default for new Android Studio projects). To make is easier to take advantage of the contents of Splitties for your Android projects, there are grouping artifacts that include most splits.","title":"Gradle instructions"},{"location":"#android-base","text":"These 2 packs don\u2019t include AppCompat and are suitable for WearOS apps. Includes the following modules: - activities - appctx - bitflags - bundle - collections - dimensions - fragments - fragmentargs - intents - lifecycle-coroutines - mainhandler - mainthread - material-colors - permissions - preferences - resources - systemservices - toast - views - views-coroutines - views-recyclerview - views-selectable - views-selectable-constraintlayout Gradle dependency: implementation ( \"com.louiscad.splitties:splitties-fun-pack-android-base:3.0.0-alpha07\" ) There\u2019s also a version with Views DSL. It additionally includes the following modules: views-dsl views-dsl-constraintlayout views-dsl-recyclerview Gradle dependency: implementation ( \"com.louiscad.splitties:splitties-fun-pack-android-base-with-views-dsl:3.0.0-alpha07\" )","title":"Android base"},{"location":"#android-appcompat","text":"These 2 packs include the Android base pack, and the following modules: - alertdialog-appcompat - alertdialog-appcompat-coroutines - views-appcompat - views-selectable-appcompat Gradle dependency: implementation ( \"com.louiscad.splitties:splitties-fun-pack-android-appcompat:3.0.0-alpha07\" ) There\u2019s also a version with Views DSL. It additionally includes the Views DSL version of the Android base pack and the following module: - views-dsl-appcompat Gradle dependency: implementation ( \"com.louiscad.splitties:splitties-fun-pack-android-appcompat-with-views-dsl:3.0.0-alpha07\" )","title":"Android AppCompat"},{"location":"#android-material-components","text":"These 2 packs include the Android AppCompat pack, and the following modules: - material-lists - snackbar - views-cardview - views-coroutines-material - views-material Gradle dependency: implementation ( \"com.louiscad.splitties:splitties-fun-pack-android-material-components:3.0.0-alpha07\" ) There\u2019s also a version with Views DSL. It additionally includes the Views DSL version of the Android AppCompat pack and the following modules: - views-dsl-coordinatorlayout - views-dsl-material Gradle dependency: implementation ( \"com.louiscad.splitties:splitties-fun-pack-android-material-components-with-views-dsl:3.0.0-alpha07\" )","title":"Android Material Components"},{"location":"#all-the-artifacts-47","text":"Add the version of the library to not repeat yourself if you use multiple artifacts, and make sure their versions are in sync by adding an ext property into your root project build.gradle file: allProjects { ext { splitties_version = \"3.0.0-alpha07\" } } Here are all the artifacts of this library. Just use the ones you need. (Click to expand) implementation(\"com.louiscad.splitties:splitties-activities:3.0.0-beta01\") implementation(\"com.louiscad.splitties:splitties-alertdialog:3.0.0-beta01\") implementation(\"com.louiscad.splitties:splitties-alertdialog-appcompat:3.0.0-beta01\") implementation(\"com.louiscad.splitties:splitties-alertdialog-appcompat-coroutines:3.0.0-beta01\") implementation(\"com.louiscad.splitties:splitties-appctx:3.0.0-beta01\") implementation(\"com.louiscad.splitties:splitties-arch-lifecycle:3.0.0-beta01\") implementation(\"com.louiscad.splitties:splitties-arch-room:3.0.0-beta01\") implementation(\"com.louiscad.splitties:splitties-bitflags:3.0.0-beta01\") implementation(\"com.louiscad.splitties:splitties-bundle:3.0.0-beta01\") implementation(\"com.louiscad.splitties:splitties-checkedlazy:3.0.0-beta01\") implementation(\"com.louiscad.splitties:splitties-collections:3.0.0-beta01\") implementation(\"com.louiscad.splitties:splitties-coroutines:3.0.0-beta01\") implementation(\"com.louiscad.splitties:splitties-dimensions:3.0.0-beta01\") implementation(\"com.louiscad.splitties:splitties-exceptions:3.0.0-beta01\") implementation(\"com.louiscad.splitties:splitties-fragments:3.0.0-beta01\") implementation(\"com.louiscad.splitties:splitties-fragmentargs:3.0.0-beta01\") implementation(\"com.louiscad.splitties:splitties-initprovider:3.0.0-beta01\") implementation(\"com.louiscad.splitties:splitties-intents:3.0.0-beta01\") implementation(\"com.louiscad.splitties:splitties-lifecycle-coroutines:3.0.0-beta01\") implementation(\"com.louiscad.splitties:splitties-mainhandler:3.0.0-beta01\") implementation(\"com.louiscad.splitties:splitties-mainthread:3.0.0-beta01\") implementation(\"com.louiscad.splitties:splitties-material-colors:3.0.0-beta01\") implementation(\"com.louiscad.splitties:splitties-material-lists:3.0.0-beta01\") implementation(\"com.louiscad.splitties:splitties-permissions:3.0.0-beta01\") implementation(\"com.louiscad.splitties:splitties-preferences:3.0.0-beta01\") implementation(\"com.louiscad.splitties:splitties-resources:3.0.0-beta01\") implementation(\"com.louiscad.splitties:splitties-snackbar:3.0.0-beta01\") debugImplementation(\"com.louiscad.splitties:splitties-stetho-init:3.0.0-beta01\") implementation(\"com.louiscad.splitties:splitties-systemservices:3.0.0-beta01\") implementation(\"com.louiscad.splitties:splitties-toast:3.0.0-beta01\") implementation(\"com.louiscad.splitties:splitties-typesaferecyclerview:3.0.0-beta01\") implementation(\"com.louiscad.splitties:splitties-views:3.0.0-beta01\") implementation(\"com.louiscad.splitties:splitties-views-appcompat:3.0.0-beta01\") implementation(\"com.louiscad.splitties:splitties-views-cardview:3.0.0-beta01\") implementation(\"com.louiscad.splitties:splitties-views-coroutines:3.0.0-beta01\") implementation(\"com.louiscad.splitties:splitties-views-coroutines-material:3.0.0-beta01\") implementation(\"com.louiscad.splitties:splitties-views-dsl:3.0.0-beta01\") implementation(\"com.louiscad.splitties:splitties-views-dsl-appcompat:3.0.0-beta01\") implementation(\"com.louiscad.splitties:splitties-views-dsl-constraintlayout:3.0.0-beta01\") implementation(\"com.louiscad.splitties:splitties-views-dsl-coordinatorlayout:3.0.0-beta01\") debugImplementation(\"com.louiscad.splitties:splitties-views-dsl-ide-preview:3.0.0-beta01\") implementation(\"com.louiscad.splitties:splitties-views-dsl-material:3.0.0-beta01\") implementation(\"com.louiscad.splitties:splitties-views-dsl-recyclerview:3.0.0-beta01\") implementation(\"com.louiscad.splitties:splitties-views-material:3.0.0-beta01\") implementation(\"com.louiscad.splitties:splitties-views-recyclerview:3.0.0-beta01\") implementation(\"com.louiscad.splitties:splitties-views-selectable:3.0.0-beta01\") implementation(\"com.louiscad.splitties:splitties-views-selectable-appcompat:3.0.0-beta01\") implementation(\"com.louiscad.splitties:splitties-views-selectable-constraintlayout:3.0.0-beta01\")","title":"All the artifacts (47)"},{"location":"#dev-versions","text":"Let\u2019s say you need a new feature or a fix that did not make it to a release yet: You can grab it in the latest dev version by adding the corresponding repository and changing the library version to the dev version you need in your root project build.gradle file: allProjects { repositories { google () jcenter () // Add dev versions repo below maven { url 'https://dl.bintray.com/louiscad/splitties-dev' } } ext { splitties_version = '3.0.0-dev-008' } }","title":"Dev versions"},{"location":"#other-build-systems","text":"For maven and alternative build-systems, check the Bintray page .","title":"Other build systems"},{"location":"#new-versions-notifications","text":"Releases are announced on GitHub, you can subscribe by clicking on \u201cWatch\u201d, then \u201cReleases only\u201d .","title":"New versions notifications"},{"location":"#improve-this-library","text":"If you want this library to have a new feature or an improvement in a new or in an existing module, please, open an issue or vote/comment a similar one first, so it can be discussed. Documentation contributions are also welcome. For typos or other small improvements, feel free to submit a PR (pull request) directly. For more significant doc contributions, please, open an issue first so it can be discussed. If you find a bug , please open an issue with all the important details. If you know a simple fix that is not API breaking and that does not have side-effects that need to be considered, you may also directly submit a PR. You can also join the discussion on Kotlin\u2019s Slack in the #splitties channel (you can get an invitation here ).","title":"Improve this library"},{"location":"#what-is-a-split","text":"A \u201csplit\u201d is a module of the Splitties library that you can add as a dependency. It only includes the required transitive dependencies. This allows you to only add what you need in your app or library module, so the final apk is as small as possible and doesn\u2019t include stuff not used by your app. Let\u2019s say you\u2019re build a Wear OS app using the Views DSL. Wear OS apps don\u2019t need AppCompat. Including it would be a waste of bandwidth and storage. The Views DSL core module relies on the Android SDK but not on AppCompat, so you don\u2019t bloat your wrist app with AppCompat by using Views DSL. However, if you are building a phone, tablet or computer Android app, there\u2019s a Views DSL AppCompat split with a few extensions for you to use.","title":"What is a split"},{"location":"#credits","text":"Special thanks to Jovche Mitrejchevski for helping in taking decisions for this project. Thanks to JetBrains and the contributors for Anko , which was a great source of inspiration, especially for Views DSL, and of course thanks for the excellent Kotlin programming language that makes this project possible. Thanks to Doug Stevenson for his articles \u201cKotlin & Android: A Brass Tacks Experiment\u201d . It is fair to say that Views DSL has its root in this experiment.","title":"Credits"},{"location":"#license","text":"This library is published under Apache License version 2.0 which you can see here .","title":"License"},{"location":"CHANGELOG/","text":"Change log for Splitties \u00b6 Version 3.0.0-alpha07 (2020-09-01) \u00b6 Compiled with Kotlin 1.3.72 and kotlinx.coroutines 1.3.8. This release introduces 2 new splits: - Alert Dialog Material (Android only) Thanks @ivoberger for the contribution! - Coroutines (supports macOS, iOS, JS, JVM & Android) Alert Dialog and Alert Dialog AppCompat \u00b6 Added \u00b6 Add isCancellable parameter (defaults to true , as when unspecified) to alertDialog builders. Arch Lifecycle \u00b6 Added \u00b6 viewModels { \u2026 } for FragmentActivity and Fragment activityViewModels { \u2026 } for Fragment Changed \u00b6 This split no longer depends on the androidx.lifecycle:lifecycle-extensions artifact that has been deprecated in AndroidX Lifecycle 2.2.0 and is no longer published in later versions. Deprecated \u00b6 AndroidX Lifecycle KTX artifacts caught up with features that this split originally provided, so we\u2019ve deprecated that overlap: activityScope() for Activity -> viewModels() activityScope() for Fragment -> activityViewModels() fragmentScope() for Fragment -> viewModels() Also, we provided variants of these that took a lambda. Since AndroidX doesn\u2019t provide such a facility, they have been kept, but the old naming has been deprecated to match the AndroidX naming. Note that these changes provide a ReplaceWith clause for easy migration. Important: Next alpha release will move the deprecation level to error, and the alpha release after will remove them completely. (So it\u2019s best to not skip this update if you were using these extensions.) Collections \u00b6 Added \u00b6 forEachReversedWithIndex extension for List now has an allowSafeModifications parameter. When set to true (default is false ), you can mutate the list as long as it doesn\u2019t prevent the next iteration from happening (or that you perform a non local return to stop iterating altogether). As usual, unsafe operations while iterating a list can result in a ConcurrentModificationException or in an IndexOutOfBoundsException to be thrown. Dimensions \u00b6 Changed \u00b6 The dip and dp functions now return the type of their argument ( Int or Float ). You\u2019ll need to migrate usages of the previous dp function, so they pass a Float . Use \u201cFind in Path\u201d in the IDE to find them before fixing. If you often passed the same value to dp , the \u201cReplace in Path\u201d IDE option can save you even more time. Lifecycle Coroutines \u00b6 Added \u00b6 Lifecycle.isStartedFlow() Lifecycle.isStartedFlow(timeout: Duration) Lifecycle.isResumedFlow() Lifecycle.isResumedFlow(timeout: Duration) Lifecycle.stateFlow(): Flow<Lifecycle.State> Changed \u00b6 The following extension functions for Lifecycle have been promoted to @ExperimentalSplittiesApi (from @PotentialFutureAndroidXLifecycleKtxApi ): - createScope - createJob - awaitResumed - awaitStarted - awaitCreated - awaitState Deprecated \u00b6 Dispatchers.MainAndroid is no longer needed and has been deprecated since the performance issue that affected Dispatchers.Main has been fixed since kotlinx.coroutines 1.3.3 . The following extension properties have been deprecated because they are now provided by AndroidX Lifecycle Runtime KTX: - Lifecycle.coroutineScope - LifecycleOwner.lifecycleScope Lifecycle.job has also been deprecated even though there\u2019s no as-concise replacement because it doesn\u2019t satisfy a common use case. Main Thread \u00b6 Added \u00b6 Now supports macOS, iOS and JS. Material Lists \u00b6 Changed \u00b6 Ensure all TextView s in the list items are at least one line tall, even if the text is empty. Support enabled/disabled state by making child views duplicate parent state. Permissions \u00b6 Added \u00b6 New ensureAllPermissions function available in top-level and as extension for FragmentActivity and Fragment to request multiple permissions in a row and ensure you have them all granted. Preferences \u00b6 Added \u00b6 Now supports macOS and iOS (backed by NSUserDefaults , but supports custom implementation too, just like on Android). Added preferences property to PrefDelegate s. Added key property to PrefDelegate s. Added valueFlow() function to PrefDelegate s to get current value and changes of a pref field. Changed \u00b6 The availableAtDirectBoot parameter has been renamed to androidAvailableAtDirectBoot . The XxxPref classes (e.g. BoolPref , StringPref , etc.) are no longer inner classes but are now part of the PrefDelegate sealed class hierarchy. Resources \u00b6 Added \u00b6 New resolveThemeAttribute extension function for Context . This is the replacement for withStyledAttributes . Deprecated \u00b6 withStyledAttributes must be replaced by new resolveThemeAttribute that also has an implementation that is working reliably in IDE Preview. It will be removed in a future release. Snackbar \u00b6 Changed \u00b6 The snack , longSnack and snackForever extension functions now work with any View instead of just CoordinatorLayout . System Services \u00b6 Added \u00b6 Add biometricManager from API 29. Add roleManager from API 29. Views AppCompat \u00b6 Added \u00b6 configActionBar extension function for AppCompatActivity . homeAsUp extension read/write property for ActionBar . Changed \u00b6 ActionBar.showTitle now supports reading current value. ActionBar.showHome now supports reading current value. ActionBar.useLogo now supports reading current value. ActionBar.showCustomView now supports reading current value. Deprecated \u00b6 ActionBar.showHomeAsUp has been deprecated and must be replaced by homeAsUp . It will be removed in a future release. Views Coroutines & Views Coroutines Material \u00b6 Bug fixes \u00b6 Fix a very rare crash that would occur when performing two clicks or long clicks in a row (e.g. by calling performClick twice without a UI thread dispatch) when using View.awaitOneClick() , View.awaitOneLongClick() or FloatingActionButton.showAndAwaitOneClickThenHide() . Views DSL \u00b6 Added \u00b6 UiPreView is now included by default, the extra \u201cViews DSL IDE Preview\u201d module is no longer needed. If you never use it in your production code, R8 should remove it from your release app. This has been done to simplify setup. The isInPreview extension properties for Ui and View allow you to condition content to show based on whether it\u2019s the actual app or the IDE preview. Note that it statically evaluates to false in release builds (unlike View.isInEditmode ), so the compiler will remove any code placed in the branch of an if (isInPreview) condition, and will allow R8 to remove any code that was only used in IDE preview. There\u2019s 2 new overloads of the ViewGroup.add extension functions that take either a beforeChild or an afterChild parameter. You must use the parameter name to call one of these overloads. It comes handy in ViewGroup s where the order of the child View s matters (e.g. FrameLayout and LinearLayout ). space to create an android.widget.Space from a Ui , a View or a Context reference. Thanks to @Miha-x64 for the contribution! Changed \u00b6 UiPreView now shows known error cases in the preview itself with a red warning triangle icon. Views DSL ConstraintLayout \u00b6 Added \u00b6 Add new extensions: above , below , before and after for ConstraintLayout.LayoutParams . Views DSL Material \u00b6 Added \u00b6 Add slider , rangeSlider and shapeableImageView extensions for View , Ui and Context . They can instantiate the new widgets from the version 1.2.0 of the material-components-android library. Views DSL IDE preview \u00b6 This module has been deprecated. It will no longer published in future releases. Its content has been moved to the main \u201cViews DSL\u201d split. Version 3.0.0-alpha06 (2019-05-03) \u00b6 Compiled with Kotlin 1.3.31. Permissions \u00b6 Handle empty grantResults for permission request ( #191 ). Version 3.0.0-alpha05 (2019-04-29) \u00b6 Compiled with Kotlin 1.3.31. This release introduces 3 new splits: Alert Dialog AppCompat Coroutines Permissions Views Coroutines Material The most important change though, is how simpler integrating Splitties in your Android projects has become starting from this release, thanks to the new grouping artifacts. See their content and their maven coordinates in the dedicated part of the README . There is also new features and changes in existing splits, as detailed below. Alert Dialog & Alert Dialog AppCompat \u00b6 The alert functions have been deprecated in favor of a more accurate naming: alertDialog . These alertDialog functions are now usable on Context (vs previously only on Activity ), and they have optional parameters to specify the title, the message and even an icon (using a resource id or a Drawable . Also, the title and the message properties are now nullable, in respect to their accepted value. Fragments \u00b6 The show and showAsync extension functions allow you to show a DialogFragment without fearing the infamous IllegalStateException if the state has already been saved, because it will wait for the lifecycle to be in the RESUMED state before showing the DialogFragment . These 2 extension functions are defined for FragmentManager , FragmentActivity and Fragment . show is a suspending function that resumes after the lifecycle was resumed and the DialogFragment was shown. showAsync is when you are outside of a coroutine but it is marked as experimental because it has \u201casync\u201d in its name while not returning a Deferred . Feel free to suggest a better name in the issues or in the #splitties channel of Kotlin\u2019s Slack. Lifecycle Coroutines \u00b6 New suspending inline extensions functions for Lifecycle have been added for convenience: awaitResumed , awaitStarted & awaitCreated . They can replace code like awaitState(Lifecycle.State.RESUMED) for improved readability. Material Lists \u00b6 A new IconTwoLinesCheckBoxListItem class has been added. What it does is self-explanatory. Also, all the list items are now fully xml friendly. Resources \u00b6 The colorSL and appColorSL extension functions no longer return the nullable version of ColorStateList . Views DSL ConstraintLayout \u00b6 All the ConstraintLayout.LayoutParams extension functions now have overloads that allow specifying the margin. For example, the following code: centerHorizontally () horizontalMargin = dip ( 16 ) can now be written on one line: centerHorizontally(margin = dip(16)) . That improves readability as the word \u201chorizontal\u201d is no longer repeated, and it is still explicit. Views Material \u00b6 Two set-only extensions properties have been added for MaterialButton : iconResource and iconTintAndTextColor . Version 3.0.0-alpha04 (2019-03-03) \u00b6 Compiled with Kotlin 1.3.21. New features \u00b6 The wrapContent and matchParent extensions for ViewGroup now apply for View too. Add wrapInScrollView and wrapInHorizontalScrollView extension functions for View . Add experimental multiplatform support with initial Kotlin/JS support for the Bit Flags and Collections splits. Changes \u00b6 Rename LifecycleOwner.coroutineScope to lifecycleScope . This change is binary compatible. Make wrapInRecyclerView lambda inline. This change is not binary compatible. Fixes \u00b6 Remove contract in the Intents split that would cause compilation to fail when used. Version 3.0.0-alpha03 (2019-02-05) \u00b6 Compiled with Kotlin 1.3.20. This release introduces a new split: Views Coroutines . New features \u00b6 Added radioGroup { ... } functions in Views DSL. Added first class support for ConstraintLayout barriers, guidelines and groups. New styledView function for use when making an API for xml styles usage in Kotlin. See an example in AppCompatStyles . The MaterialComponentsStyles class brings access to all the xml styles defined in Google\u2019s Material Components library for Android in a typesafe way. Add materialCardView { ... } functions in Views DSL Material. Add navigationView { ... } functions in Views DSL Material. Make EditText inputType typesafe with the set only type extension property and the InputType inline class. Views DSL IDE Preview now supports CoroutineContext and CoroutineScope as constructor parameters for Ui subclasses. Added contracts for all the lParams functions from Views DSL and variants. Also added to the roomDb function from Arch Room as well as the verticalListLayoutParams and horizontalListLayoutParams functions from Views DSL RecyclerView. Add support for unsigned numbers in Bit Flags (i.e. UByte , UShort , UInt and ULong ). Changes \u00b6 When using the button function from Views DSL, MaterialButton is now automatically used in place of AppCompatButton if you also use Views DSL Material. Make mainHandler async by default to avoid vSync delays. It is used for Dispatchers.MainAndroid , so it will result in speed improvements when using Lifecycle Coroutines. If you really need sync behavior, you can use the new mainHandlerSync top level property instead. Make Dispatchers.MainAndroid of type MainCoroutineDispatcher so the immediate property is available. Make the awaitState function from Lifecycle Coroutines safe to use off the main thread, and document it. Call validate() from the lParams { ... } function for ConstraintLayout . Make xml styles related classes inline again (thanks to compiler bug fixed in Kotlin 1.3.20). The reified generic variant of view from Views DSL is now an internal API. ViewFactory and related symbols are now an internal API. Mark some SystemServices as nullable to be instant app tolerant. That includes WallpaperManager , WifiManager , WifiP2pManager , UsbManager , DevicePolicyManager , FingerprintManager , ShortcutManager and WifiAwareManager . The Views DSL IDE Preview documentation now states that running the compileDebugKotlin gradle task is enough to update the preview. This is faster than a full build. Fixes \u00b6 Make viewFactory from Views DSL internal API compatible with IDE Preview. Deprecation \u00b6 The illegal top level function from Exceptions has been deprecated in favor of error from Kotlin stdlib. New artifact \u00b6 This release has the following new artifact: \"com.louiscad.splitties:splitties-views-coroutines:3.0.0-alpha03\" Version 3.0.0-alpha02 (2019-01-06) \u00b6 This release introduces a new split: Lifecycle Coroutines . New artifact \u00b6 This release has the following new artifact: \"com.louiscad.splitties:splitties-lifecycle-coroutines:3.0.0-alpha02\" Version 3.0.0-alpha01 (2018-12-21) \u00b6 This release is compiled with Kotlin 1.3.11. It is a breaking release (more details in the changes section), and the API is subject to changes as it is back to an alpha stage. APIs that are likely to change have an experimental annotation that triggers a warning (which can be removed by opt-in), to prevent you from using them unintentionally. Migration to AndroidX \u00b6 All the old support library artifacts have been replaced by AndroidX ones. If your project has not migrated to AndroidX yet, please follow the quick steps below. Migrating your project to AndroidX in a `fun` way. (Click to expand) Theoretically, migrating a project to AndroidX is easy: you just select \"Migrate to AndroidX\" from the \"Refactor\" menu. Unfortunately, in addition to being unacceptably slow, it didn't work properly for Splitties (except for a past attempt which had to be abandoned for API stability reasons). _Our experience was waiting minutes with an unresponsive IDE, then giving up with no other choice than force closing Android Studio, and finally getting a broken project, with some dangling fully qualified references (instead of proper import replacement). We reverted and looked for an alternative that would work properly, and perform faster._ The solution has been a Kotlin script that is a white box, and runs in a matter of seconds. You can use it for your project too, so you can migrate to AndroidX quickly, and in a `fun` way. It is available [here](scripts/AndroidX-migrator.kts), and depends on [this csv file](scripts/androidx-class-mapping.csv). _Note that this script doesn't migrate the dependencies, because we changed the way we define dependencies (using constants defined in `buildSrc`), and it would have been harder to handle all the edge cases, and doing it by hand with Replace in Path from IDE was quick enough for us. If you prefer to have it, you are free to contribute and reach out in the issues or elsewhere._ To use it in your project, follow these simple steps: 1. Replace the support libraries dependencies by AndroidX dependencies (and update Splitties ones if you already used it). 2. Copy paste the two files linked above at the root of the gradle project. 3. Edit the `expectedNumberOfModules` property defined in the `AndroidX-migrator.gradle.kts` file to match the number of modules that your project has. 4. Make sure you have `kotlinc` 1.3+ available (see [easy installation in official docs here]( https://kotlinlang.org/docs/tutorials/command-line.html )). 5. Open a terminal at the root of the gradle project. 6. Run `kotlinc -script AndroidX-migrator.gradle.kts` and wait for completion. 7. Sync gradle project. 8. Build the project to ensure everything has migrated properly, or fix and try again. Improved API to use xml styles defined in Android or AppCompat \u00b6 Now, you pass the Context only once to the AndroidStyles or AppCompatStyles constructor, and you no longer have to pass it to the subsequent functions call. It is advised to obviously cache this instance to reduce boilerplate and avoid overhead. This is a breaking change. Package name changes and replaced artifacts \u00b6 The design support library no longer exists in AndroidX. It is replaced by several AndroidX artifacts and the Google Material Components library. Consequently, the package names no longer reference \u201cdesign\u201d but \u201ccoordinatorlayout\u201d and \u201cmaterial\u201d instead. As you can see below, the design support library dependent artifacts have been replaced. Note that Views DSL Material has a transitive dependency to Views DSL CoordinatorLayout, so you don\u2019t need to add an explicit dependency for the latter if you already use the former. New artifacts \u00b6 This release has the following new artifacts: \"com.louiscad.splitties:splitties-views-material:3.0.0-alpha01\" \"com.louiscad.splitties:splitties-views-dsl-coordinatorlayout:3.0.0-alpha01\" \"com.louiscad.splitties:splitties-views-dsl-material:3.0.0-alpha01\" Removed artifacts \u00b6 This release removes these two artifacts: \"com.louiscad.splitties:splitties-views-design-styles:2.1.1\" \"com.louiscad.splitties:splitties-views-dsl-design-styles:2.1.1\" Version 2.1.1 (2018-11-25) \u00b6 This release is compiled with Kotlin 1.3.10. Changes \u00b6 Enforce read-only in the withExtras extension function for Activity . Any attempt to mutate a property inside it will result in an IllegalStateException to be thrown, because this should be done in putExtras instead. You can see more info in the updated KDoc of these functions. Add a withExtras extension function for Intent (previously only available for Activity ). Add a putExtras extension function for Activity (previously only available for Intent ). Fix nullability warning in FragmentArgDelegate. Add KDoc to all public symbols from the Activities split. Add KDoc to all public symbols from the AlertDialog split. Add KDoc to all public symbols from the AlertDialog AppCompat split. Version 2.1.0 (2018-11-13) \u00b6 This release targets Android SDK 28, and splits depending on support libraries use version 28.0.0. Changes \u00b6 System Services from API 28 are now included into the same named split. Update ConfigChangesHandlingCollapsingToolbarLayout from View DSL Design to be compatible with design support library version 28.0.0. Update for nullability warnings brought by SDK 28. Version 2.0.0 (2018-11-13) \u00b6 This release targets Android SDK 27, and splits depending on support libraries use version 27.1.1. Changes \u00b6 Room updated to version 1.1.1 in Arch Room. Lambdas of onCreate and onOpen functions in Arch Room are now crossinline . The LifecycleObserver class is now marked as experimental. Version 2.0.0-beta1 (2018-11-13) \u00b6 This release breaks binary and source compatibility . Kotlin 1.3.0 \u00b6 This is not just a compiler update for Splitties. This release already takes advantage of Kotlin 1.3 features, beyond stable coroutines: The XmlStyle class from Views DSL is now inline, for minimal footprint at runtime. SuspendPrefsAccessor from Preferences is no longer experimental as coroutines graduated. Functions that take a lambda in Views DSL (except lParams functions) have a contract. This directly translates to more freedom in your UI code as you can initialize a property later. withExtras , putExtras and with from Bundle have a contract. This allows to initialize local variables from contents of a Bundle passing through a BundleSpec naturally! Symbols that could change are marked as experimental, for less surprises in the future when they are replaced, renamed or removed (still with a deprecation cycle whenever possible). Only verticalListLayoutParams and horizontalListLayoutParams extension functions for RecyclerView.LayoutManager are experimental for now, but this could change, especially in alpha, or beta stage. Version 2.0.0-alpha9 (2018-11-13) \u00b6 This release breaks binary and source compatibility . It renames several package names and modules, for more consistency across the project. View DSL has a new name: Views DSL. That also applies to its additional modules. Just like an extra s can make a new generation of smartphones, it can also make a new version of Splitties. The artifact names of all Selectable Views and View DSL changed, and so did the package names. Consequently, after updating the artifact names and the version, you\u2019ll need to update the imports. Fortunately, this is easily done with the \u201cReplace in Path\u201d IDE option present in IntelliJ IDEA and Android Studio. All you need to do is find an old import ( import splitties.viewdsl. ), select it, select the \u201cReplace in Path\u201d option paste ( import splitties.views.dsl. ) in the second input field, and validate. Then, you just have to do the same for Selectable Views with import splitties.selectableviews. and import splitties.views.selectable. \u2026 and voil\u00e0! You just migrated to latest Splitties version! New artifacts \u00b6 Here are all the artifacts added in this version. Just use the ones you need. (Click to expand) implementation ( \"com.louiscad.splitties:splitties-views-dsl:3.0.0-beta01\" ) implementation ( \"com.louiscad.splitties:splitties-views-dsl-appcompat:3.0.0-beta01\" ) implementation ( \"com.louiscad.splitties:splitties-views-dsl-constraintlayout:3.0.0-beta01\" ) implementation ( \"com.louiscad.splitties:splitties-views-dsl-design:3.0.0-beta01\" ) debugImplementation ( \"com.louiscad.splitties:splitties-views-dsl-ide-preview:3.0.0-beta01\" ) implementation ( \"com.louiscad.splitties:splitties-views-dsl-recyclerview:3.0.0-beta01\" ) implementation ( \"com.louiscad.splitties:splitties-views-selectable:3.0.0-beta01\" ) implementation ( \"com.louiscad.splitties:splitties-views-selectable-appcompat:3.0.0-beta01\" ) implementation ( \"com.louiscad.splitties:splitties-views-selectable-constraintlayout:3.0.0-beta01\" ) All the lines above assume you defined the `splitties_version` ext property in your root project's `build.gradle` file to `2.0.0-alpha9` as shown in this snippet: allProjects { ext { splitties_version = '2.0.0-alpha9' } } Removed artifacts \u00b6 This release removes all these artifacts: implementation(\"com.louiscad.splitties:splitties-selectableviews:3.0.0-beta01\") implementation(\"com.louiscad.splitties:splitties-selectableviews-appcompat:3.0.0-beta01\") implementation(\"com.louiscad.splitties:splitties-selectableviews-constraintlayout:3.0.0-beta01\") implementation(\"com.louiscad.splitties:splitties-viewdsl:3.0.0-beta01\") implementation(\"com.louiscad.splitties:splitties-viewdsl-appcompat:3.0.0-beta01\") implementation(\"com.louiscad.splitties:splitties-viewdsl-constraintlayout:3.0.0-beta01\") implementation(\"com.louiscad.splitties:splitties-viewdsl-design:3.0.0-beta01\") debugImplementation(\"com.louiscad.splitties:splitties-viewdsl-ide-preview:3.0.0-beta01\") implementation(\"com.louiscad.splitties:splitties-viewdsl-recyclerview:3.0.0-beta01\") Version 2.0.0-alpha8 (2018-11-12) \u00b6 This release breaks binary compatibility . It removes all deprecated symbols that had their deprecation level raised to error in 2.0.0-alpha7. Make sure you don\u2019t rely on any library that uses an old version of a Splitties artifact that relies on these previously deprecated and now removed symbols, or your app is likely not build, or to crash at runtime because of not found classes. Version 2.0.0-alpha7 (2018-11-12) \u00b6 Raise all deprecated symbols deprecation level to error. Use this version to make sure you don\u2019t use them in your projects, next version will remove them! Version 2.0.0-alpha6 (2018-11-11) \u00b6 Version 2.0.0-alpha5 broke the API, this version fixes this. Like version 2.0.0-alpha5, but without breaking the API from 2.0.0-alpha4 \u00b6 This release is mostly the same as 2.0.0-alpha5, but also has 2 very important things: - binary compatibility (minor change in Preferences experimental API excluded) - source compatibility, except an overload resolution ambiguity in View DSL, see the migration guide for a smooth migration. Removed splits and versions sync \u00b6 Version 2.0.0-alpha5 technically removed 2 splits (one was actually a renaming, the other one a merging). Consequently, you have to make sure your dependencies no longer reference these removed artifacts. Easily done. Problems arise when you depend on libraries that themselves depend on Splitties, which may be older versions. These libraries may bring transitive dependencies to old modules that will clash with ones from newer versions, and the versions they rely on may also mismatch with the ones you need, and these older versions will take precedence if they are in library modules of your project that don\u2019t depend explicitly on a newer version. Fortunately, Gradle dependency resolution strategy allows to easily fix these issues all over your project. All you need to do is to make sure you have the following snippet into your root project\u2019s build.gradle file: allprojects { ext { splitties_version = '2.0.0-alpha6' } configurations . all { resolutionStrategy . eachDependency { DependencyResolveDetails details -> def req = details . requested if ( req . group != \"com.louiscad.splitties\" ) return if ( req . name == \"splitties-uithread\" ) { details . useTarget ( group: req . group , name: \"splitties-mainthread\" , version: splitties_version ) details . because ( \"Splitties uithread has been renamed to mainthread\" ) } else if ( req . name == \"splitties-viewdsl-appcompat-styles\" ) { details . useTarget ( group: req . group , name: \"splitties-viewdsl-appcompat\" , version: splitties_version ) details . because ( \"[Splitties] Split merged and removed\" ) } else { details . useTarget ( group: req . group , name: req . name , version: splitties_version ) details . because ( \"Transitive dependencies could take precedence otherwise\" ) } } } } The snippet above, for all sub-projects (aka. modules): 1. defines Splitties version in an ext property so it can be used in all build.gradle files. 2. sets a resolution strategy for all configurations (like implementation or api ) which: 1. redirects any usage of the old splitties-mainthread artifact to the new splitties-mainthread one. 2. redirects any usage of the old splitties-viewdsl-appcompat-styles artifact to the one it has been merged into: splitties-viewdsl-appcompat . 3. makes sure all splitties artifacts versions are in sync, across all sub-projects. If you don\u2019t do this but have a library using an old artifact in your dependencies, you\u2019ll encounter gradle sync issues, or runtime issues, and the real cause may not appear clearly (because of bugs in tooling). Changes per module \u00b6 Checked Lazy \u00b6 uiLazy has been deprecated in favor of mainThreadLazy . View DSL RecyclerView \u00b6 The wrapInRecyclerView extension function now accepts an optional lambda to configure the wrapping RecyclerView easily. Version 2.0.0-alpha5 (2018-11-02) \u00b6 This release is breaking if you come from version 2.0.0-alpha4, especially if you were using View DSL. It\u2019s highly recommended to directly migrate from version 2.0.0-alpha4 to 2.0.0-alpha6, which has a smoother migration path, and a guide to do so. Project wide changes \u00b6 Add consumer proguard rules for splits with optional dependencies. Update to Kotlin 1.2.71 Update kotlinx.coroutines to version 0.30.2 Changes per module \u00b6 Collections \u00b6 Add allocation-free reverse List forEach extensions: forEachReversedByIndex and forEachReversedWithIndex . Intents \u00b6 Add toPendingActivities() extension function for Array<Intent> . Material Lists \u00b6 The following previously deprecated classes have been removed: SingleLineIconListItem (use IconOneLineListItem instead) TwoLinesIconListItem (use IconTwoLinesListItem instead) TwoLinesIconSwitchListItem (use IconTwoLinesSwitchListItem instead) All the xml files (except view_ids.xml ) have been removed. Preferences \u00b6 Enhancements \u00b6 The preferences are now loaded in Dispatchers.IO when using SuspendPrefsAccessor . Fix clash with private property name and non imported extension for Preferences. (#96). Breaking changes (in experimental API) \u00b6 The SuspendPrefsAccessor constructor parameter of type CoroutineDispatcher has been removed now that Dispatchers.IO is always used. If you didn\u2019t specify a custom dispatcher, you don\u2019t need to do anything. Selectable Views (all variants) \u00b6 All the final methods have been opened up, and now have the @CallSuper annotation instead. This makes the classes more useful to develop custom views, like the extended Floating Action Button with SelectableConstraintLayout where you need to clip the view in onDraw(\u2026) . The dispatchDrawableHotspotChanged overridden method in the classes of the Selectable Views splits family was annotated with @TargetApi , but is not correctly annotated with @RequiresApi . This likely caused no issue as you usually don\u2019t call this method directly but let Android do, but now, it\u2019s fixed! ~UI Thread~ -> Main Thread \u00b6 The UI Thread split has been renamed to Main thread (for the same reasons kotlinx.coroutines replaced UI by Dispatchers.Main ). While the artifact has been changed , the old symbols have only been deprecated in favor of new ones defined in new package, with new names ( ui -> main ). If you use a library that depends on the old artifact, see \u201cRemoved splits and versions sync\u201d in version 2.0.0-alpha6 release notes. View DSL (and additional modules) \u00b6 The API of View DSL (and its additional modules) has been improved, and there\u2019s some new features, along with some deprecations. However, this release (2.0.0-alpha5) is breaking when updating from previous versions. This has been fixed in 2.0.0-alpha6, so please skip this release if you are upgrading , and follow thoroughly the migration guide . Regardless, there has been improvements in View DSL additional modules. Please, review them below. ~View DSL AppCompat Styles~ -> View DSL AppCompat \u00b6 The View DSL AppCompat Styles split has been merged into View DSL AppCompat. If you use a library that depends on the old artifact, see \u201cRemoved splits and versions sync\u201d in version 2.0.0-alpha6 release notes. View DSL ConstraintLayout \u00b6 Probably the best change in this split is that now, you no longer need to specify any View id. If there\u2019s none and you add a constraint using extension functions from this split, an id that can\u2019t clash with aapt/xml ids will be generated and assigned to the view so constraints work. Keep in mind you may still want to use stable ids defined in xml or elsewhere in cases where you use views that need to have their state saved, like a RecyclerView , an EditText or a CheckBox . Added support for chains with the two horizontalChain and verticalChain new extension functions for ConstraintLayout . Also added horizontalMargin and verticalMargin extension properties for List<View> that are designed for use in a ConstraintLayout when you made a chain with the two new methods that take a list of views. View DSL Design \u00b6 When instantiating an AppBarLayout or a CollapsingToolbarLayout with the new appBarLayout and collapsingToolbarLayout functions, you\u2019ll automatically get instances that have known bugs in the design support library fixed, including config changes handling (supports rotation or layout changes without recreating the Activity). View DSL RecyclerView \u00b6 The setSingleView extension function for RecyclerView has been deprecated. Use the wrapInRecyclerView extension function for View instead, it is simpler to use and supports horizontal scrolling. Views \u00b6 Deprecated View visibility extension properties and functions in favor of Android KTX ones. Added lines write only extension property for TextView . Change the signature of the lambda of the onClick extension function for View . It no longer passes the clicked view . This is to avoid it shadowing when you nest lambdas, and has been done because this parameter is almost never used. Add 1 extension function, 1 extension property and 1 top level function, related to View id generation: View.assignAndGetGeneratedId() , View.existingOrNewId and generateViewId() . Upcoming APIs preview in the sample \u00b6 The sample of Splitties is a place where you can preview several extensions or other work that can be integrated into Splitties as a library later. In addition to what was already present in the sample, there has been an important addition: An example of how to request a dangerous permission with a single suspend call, plus a try/catch to handle user deny. New artifact \u00b6 This release has a new artifact: implementation ( \"com.louiscad.splitties:splitties-mainthread:3.0.0-beta01\" ) Removed artifacts \u00b6 This release removes these two artifacts: implementation(\"com.louiscad.splitties:splitties-uithread:3.0.0-beta01\") implementation(\"com.louiscad.splitties:splitties-viewdsl-appcompat-styles:3.0.0-beta01\") Version 2.0.0-alpha4 (2018-07-09) \u00b6 Provide ReplaceWith migrations for add methods deprecated in version 2.0.0-alpha2. Add default empty lambda for startActivity(action: String\u2026) methods. Compiled with Kotlin 1.2.51 Version 2.0.0-alpha3 (2018-06-09) \u00b6 New features \u00b6 Bundle \u00b6 There are 2 new methods: bundleOrDefault(\u2026) and bundleOrElse { \u2026 } to allow default values in BundleSpec delegated properties. Fragment Args \u00b6 Like for BundleSpec , there are 2 new methods: argOrDefault(\u2026) and argOrElse { \u2026 } to allow default values in Fragment delegated argument properties. Breaking changes \u00b6 Bundle \u00b6 The delegates previously returned by bundle() and bundleOrNull() are no longer part of the public API and have been replaced by the ReadWriteProperty interface. Fragment Args \u00b6 The arg() and argOrNull() functions have moved out of the support subpackage as there\u2019s no longer any ambiguity since platform Fragments are deprecated and going away. Auto-import should import the versions from the new package for you. The delegates previously returned by arg() and argOrNull() are no longer part of the public API and have been replaced by the ReadWriteProperty interface. Version 2.0.0-alpha2 (2018-05-21) \u00b6 9 new library modules (amounting to a total of 42 splits): \u00b6 Activities : Start activities with minimal boilerplate Collections : forEach for List s without Iterator allocation Fragments : Start activities from fragments and do transactions with minimal boilerplate Intents : Transform companion object s into powerful typesafe intent specs Material Colors : 2014 Material Design color palettes as color resources View DSL RecyclerView : RecyclerView extension of View DSL Views CardView : CardView extension of Views. Provides a contentPadding property View Design : Design Support library extension of Views Views RecyclerView : RecyclerView extension of Views Other changes: \u00b6 AppCtx \u00b6 The consume { \u2026 } utility function from the splitties.init package has been deprecated. Replace it with true.also { _ -> \u2026 } or false.also { _ -> \u2026 } . Arch Lifecycle \u00b6 New mapNotNull , switchMap and switchMapNotNull extension functions for LiveData . activityScope and fragmentScope extension functions to get a ViewModel now accept an optional lambda (which creates a ViewModelProvider under the hood. This allows to pass arguments to your ViewModel when it\u2019s first created. observe and observeNotNull now return the created Observer so it can be unregistered manually later if needed. Arch Room \u00b6 The new inTransaction { \u2026 } extension function for RoomDatabase s does the same as transaction { \u2026 } but also returns the value of the last expression of the lambda. New onCreate { \u2026 } and onOpen { \u2026 } extension functions for RoomDatabase.Builder . Bundle \u00b6 BundleHelper has been renamed to BundleSpec , but a typealias keeps the source compatibility. However, there\u2019s no binary compatibility, which means you\u2019ll need to recompile any library using it. BundleSpec and the methods relying on it can now be used safely on any thread! Material Lists \u00b6 Allow disabling default icon tint on list items with optional constructor parameter. Preferences \u00b6 A new experimental SuspendPrefsAccessor for coroutines users allows you to ensure you can\u2019t load the preferences (which does I/O) on the UI thread. Resources \u00b6 The str extension functions formatArgs now accept null arguments. View DSL \u00b6 The higher order function add has been deprecated because it went in the way of promoting a view to a property easily. View DSL AppCompat styles \u00b6 Added flatButton , imgActionButton and largeProgressBar . View DSL ConstraintLayout \u00b6 Add baselineToBaselineOf(\u2026) extension function for ConstraintLayout.LayoutParams . View DSL IDE Preview \u00b6 UiPreView injects a valid value into appCtx so your Ui s can depend on it (probably indirectly) without breaking preview! Views \u00b6 New Gravity flags aliases (e.g. gravityStartCenter instead of Gravity.START or Gravity.CENTER_VERTICAL ). Change case of imageBitMap to imageBitmap to make it more consistent with the class name Bitmap Views AppCompat \u00b6 tooltipTxt now accepts null to remove any tooltip previously set on the view. New artifacts \u00b6 Here are all the artifacts added in this version. Just use the ones you need. (Click to expand) implementation ( \"com.louiscad.splitties:splitties-activities:3.0.0-beta01\" ) implementation ( \"com.louiscad.splitties:splitties-collections:3.0.0-beta01\" ) implementation ( \"com.louiscad.splitties:splitties-fragments:3.0.0-beta01\" ) implementation ( \"com.louiscad.splitties:splitties-intents:3.0.0-beta01\" ) implementation ( \"com.louiscad.splitties:splitties-material-colors:3.0.0-beta01\" ) implementation ( \"com.louiscad.splitties:splitties-viewdsl-recyclerview:3.0.0-beta01\" ) implementation ( \"com.louiscad.splitties:splitties-views-cardview:3.0.0-beta01\" ) implementation ( \"com.louiscad.splitties:splitties-views-design:3.0.0-beta01\" ) implementation ( \"com.louiscad.splitties:splitties-views-recyclerview:3.0.0-beta01\" ) All the lines above assume you defined the `splitties_version` ext property in your root project's `build.gradle` file to `2.0.0-alpha2` as shown in this snippet: allProjects { ext { splitties_version = '2.0.0-alpha2' } } Version 2.0.0-alpha1 (2018-03-11) \u00b6 26 new library modules (amounting to a total of 33 splits): \u00b6 Alert Dialog : Create simple alert dialogs with simple code Alert Dialog AppCompat : AppCompat version of Alert Dialog Arch Lifecycle : Extensions to get ViewModel s, use LiveData and observe Lifecycle s Arch Room : Room helpers to instantiate your DB and perform transactions in Kotlin Bit Flags : hasFlag , withFlag and minusFlag extensions on Long , Int , Short and Byte Bundle : BundleHelper to use Bundle with property syntax for Intent extras and more Dimensions : Android dp extensions for View and Context . Particularly handy when using View DSL Exceptions : illegal(\u2026) and similar functions that return Nothing , handy for impossible or illegal when branches Fragment Args : Fragment arguments without ceremony thanks to delegated properties Init Provider : Base class for ContentProvider s used for automatic initialization purposes Main Handler : Top-level mainHandler property to stop allocating multiple Handler s for main Looper Resources : Extensions to get resources like strings, colors or drawables easily, with support for themed attributes Selectable Views AppCompat : Selectable Views for AppCompatTextView Selectable Views ConstraintLayout : Selectable Views for ConstraintLayout Snackbar : Grab a snack without ceremony with snack(\u2026) and longSnack(\u2026) System Services : No more context.getSystemService(NAME_OF_SERVICE) as NameOfManager Toast : Show a toast by just calling toast(yourText) , and dodge API 25 BadTokenException UI Thread : Properties related to Android UI thread, and checkUiThread() precondition checker View DSL : Create UIs with readable Kotlin code View DSL AppCompat : AppCompat extension of View DSL View DSL AppCompat styles : AppCompat styles for View DSL View DSL ConstraintLayout : ConstraintLayout extension of View DSL View DSL Design : Design Support Library extension of View DSL View DSL IDE preview : Preview View DSL UIs in the IDE Views : Extensions function and properties on View s Views AppCompat : AppCompat extension of Views. Includes helpers for ImageView tinting, ActionBar and tooltip 1 renamed module: \u00b6 \u201cChecked Lazy\u201d replaces the \u201cConcurrency\u201d module. Other changes: \u00b6 The groupId of the library changed from xyz.louiscad.splitties to com.louiscad.splitties . Check dependencies list below. All previous modules migrated to Kotlin, excepted the ViewHolder class from the Typesafe RecyclerView module that can\u2019t be written in Kotlin at the moment due to hiding super fields not being supported. App Context module has a new, memory leak safe injectAsAppCtx() method, that uses the new canLeakMemory() extension function on Context that is also public. Preferences StringPref and stringPref don\u2019t allow null values anymore. Use StringOrNullPref and stringOrNullPref if you need nullable strings. Same for StringSetPref and stringSetPref . The isUiThread property moved from the old \u201cConcurrency\u201d module to the \u201cUI Thread\u201d module. Material Lists are now written in Kotlin with View DSL, fixing icon tinting support on day/night themes and behavior on long texts. Also, the naming has been improved. Old named items are now deprecated. Checked Lazy does no longer depend on Timber but is now more configurable, allowing to write reporting behavior if needed. Selectable Views has been split in base module (that includes only dependencies on Android platform), AppCompat module and ConstraintLayout module. Selectable Views don\u2019t support the foreground xml attribute from app namespace anymore, but there\u2019s a new foregroundSelector property. New artifacts \u00b6 Here are all the artifacts added in this version. Just use the ones you need. (Click to expand) implementation ( \"com.louiscad.splitties:splitties-alertdialog:3.0.0-beta01\" ) implementation ( \"com.louiscad.splitties:splitties-alertdialog-appcompat:3.0.0-beta01\" ) implementation ( \"com.louiscad.splitties:splitties-appctx:3.0.0-beta01\" ) implementation ( \"com.louiscad.splitties:splitties-arch-lifecycle:3.0.0-beta01\" ) implementation ( \"com.louiscad.splitties:splitties-arch-room:3.0.0-beta01\" ) implementation ( \"com.louiscad.splitties:splitties-bitflags:3.0.0-beta01\" ) implementation ( \"com.louiscad.splitties:splitties-bundle:3.0.0-beta01\" ) implementation ( \"com.louiscad.splitties:splitties-checkedlazy:3.0.0-beta01\" ) implementation ( \"com.louiscad.splitties:splitties-dimensions:3.0.0-beta01\" ) implementation ( \"com.louiscad.splitties:splitties-exceptions:3.0.0-beta01\" ) implementation ( \"com.louiscad.splitties:splitties-initprovider:3.0.0-beta01\" ) implementation ( \"com.louiscad.splitties:splitties-mainhandler:3.0.0-beta01\" ) implementation ( \"com.louiscad.splitties:splitties-material-lists:3.0.0-beta01\" ) implementation ( \"com.louiscad.splitties:splitties-preferences:3.0.0-beta01\" ) implementation ( \"com.louiscad.splitties:splitties-resources:3.0.0-beta01\" ) implementation ( \"com.louiscad.splitties:splitties-fragmentargs:3.0.0-beta01\" ) implementation ( \"com.louiscad.splitties:splitties-selectableviews:3.0.0-beta01\" ) implementation ( \"com.louiscad.splitties:splitties-selectableviews-appcompat:3.0.0-beta01\" ) implementation ( \"com.louiscad.splitties:splitties-selectableviews-constraintlayout:3.0.0-beta01\" ) debugImplementation ( \"com.louiscad.splitties:splitties-stetho-init:3.0.0-beta01\" ) implementation ( \"com.louiscad.splitties:splitties-systemservices:3.0.0-beta01\" ) implementation ( \"com.louiscad.splitties:splitties-toast:3.0.0-beta01\" ) implementation ( \"com.louiscad.splitties:splitties-typesaferecyclerview:3.0.0-beta01\" ) implementation ( \"com.louiscad.splitties:splitties-uithread:3.0.0-beta01\" ) implementation ( \"com.louiscad.splitties:splitties-snackbar:3.0.0-beta01\" ) implementation ( \"com.louiscad.splitties:splitties-viewdsl:3.0.0-beta01\" ) implementation ( \"com.louiscad.splitties:splitties-viewdsl-appcompat:3.0.0-beta01\" ) implementation ( \"com.louiscad.splitties:splitties-viewdsl-appcompat-styles:3.0.0-beta01\" ) implementation ( \"com.louiscad.splitties:splitties-viewdsl-constraintlayout:3.0.0-beta01\" ) implementation ( \"com.louiscad.splitties:splitties-viewdsl-design:3.0.0-beta01\" ) debugImplementation ( \"com.louiscad.splitties:splitties-viewdsl-ide-preview:3.0.0-beta01\" ) implementation ( \"com.louiscad.splitties:splitties-views:3.0.0-beta01\" ) implementation ( \"com.louiscad.splitties:splitties-views-appcompat:3.0.0-beta01\" ) All the lines above assume you defined the `splitties_version` ext property in your root project's `build.gradle` file to `2.0.0-alpha1` as show in this snippet: allProjects { ext { splitties_version = '2.0.0-alpha1' } } Version 1.3.0 (2017-04-17) \u00b6 5 new library modules: \u00b6 App Context : Have a Context everywhere Concurrency : Single thread lazy implementations, with reporting via Timber support Material Lists : List Items for RecyclerView implementing Material Design Guidelines Preferences : Property syntax for Android\u2019s SharedPreferences Stetho init : Have Stetho without writing any code! 1 renamed module: \u00b6 Selectable Views replaces Selectable ViewGroups Other changes: \u00b6 Selectable Views now has a SelectableTextView . Made to use it on simple, single-line list items. Typesafe RecyclerView now depends on Kotlin Typesafe RecyclerView has a new ItemViewHolder helper class for simple but common use cases. Version 1.2 (2016-09-19) \u00b6 This version adds the setHost(Host host) method in ViewWrapper.Binder interface where Host can be any type you want you can use from the implementing item View to communicate with your Activity, Fragment, Presenter, or whatever. Note this adds a third type parameter to the ViewWrapper class, and a second one for the ViewWrapper.Binder class. Version 1.1 (2016-09-11) \u00b6 This version adds the setViewHolder(ViewWrapper holder) method in ViewWrapper.Binder interface so list item View s can now get a reference to their ViewHolder , and call getAdapterPosition() on it for example. Version 1.0 (2016-08-24) \u00b6 This is the first release of Splitties. It includes two independent modules: - Typesafe RecyclerView - Selectable ViewGroups For gradle projects from jcenter() repo: compile 'xyz.louiscad.splitties:selectableviewgroups:1.0' compile 'xyz.louiscad.splitties:typesaferecyclerview:1.0'","title":"Change Log"},{"location":"CHANGELOG/#change-log-for-splitties","text":"","title":"Change log for Splitties"},{"location":"CHANGELOG/#version-300-alpha07-2020-09-01","text":"Compiled with Kotlin 1.3.72 and kotlinx.coroutines 1.3.8. This release introduces 2 new splits: - Alert Dialog Material (Android only) Thanks @ivoberger for the contribution! - Coroutines (supports macOS, iOS, JS, JVM & Android)","title":"Version 3.0.0-alpha07 (2020-09-01)"},{"location":"CHANGELOG/#alert-dialog-and-alert-dialog-appcompat","text":"","title":"Alert Dialog and Alert Dialog AppCompat"},{"location":"CHANGELOG/#added","text":"Add isCancellable parameter (defaults to true , as when unspecified) to alertDialog builders.","title":"Added"},{"location":"CHANGELOG/#arch-lifecycle","text":"","title":"Arch Lifecycle"},{"location":"CHANGELOG/#added_1","text":"viewModels { \u2026 } for FragmentActivity and Fragment activityViewModels { \u2026 } for Fragment","title":"Added"},{"location":"CHANGELOG/#changed","text":"This split no longer depends on the androidx.lifecycle:lifecycle-extensions artifact that has been deprecated in AndroidX Lifecycle 2.2.0 and is no longer published in later versions.","title":"Changed"},{"location":"CHANGELOG/#deprecated","text":"AndroidX Lifecycle KTX artifacts caught up with features that this split originally provided, so we\u2019ve deprecated that overlap: activityScope() for Activity -> viewModels() activityScope() for Fragment -> activityViewModels() fragmentScope() for Fragment -> viewModels() Also, we provided variants of these that took a lambda. Since AndroidX doesn\u2019t provide such a facility, they have been kept, but the old naming has been deprecated to match the AndroidX naming. Note that these changes provide a ReplaceWith clause for easy migration. Important: Next alpha release will move the deprecation level to error, and the alpha release after will remove them completely. (So it\u2019s best to not skip this update if you were using these extensions.)","title":"Deprecated"},{"location":"CHANGELOG/#collections","text":"","title":"Collections"},{"location":"CHANGELOG/#added_2","text":"forEachReversedWithIndex extension for List now has an allowSafeModifications parameter. When set to true (default is false ), you can mutate the list as long as it doesn\u2019t prevent the next iteration from happening (or that you perform a non local return to stop iterating altogether). As usual, unsafe operations while iterating a list can result in a ConcurrentModificationException or in an IndexOutOfBoundsException to be thrown.","title":"Added"},{"location":"CHANGELOG/#dimensions","text":"","title":"Dimensions"},{"location":"CHANGELOG/#changed_1","text":"The dip and dp functions now return the type of their argument ( Int or Float ). You\u2019ll need to migrate usages of the previous dp function, so they pass a Float . Use \u201cFind in Path\u201d in the IDE to find them before fixing. If you often passed the same value to dp , the \u201cReplace in Path\u201d IDE option can save you even more time.","title":"Changed"},{"location":"CHANGELOG/#lifecycle-coroutines","text":"","title":"Lifecycle Coroutines"},{"location":"CHANGELOG/#added_3","text":"Lifecycle.isStartedFlow() Lifecycle.isStartedFlow(timeout: Duration) Lifecycle.isResumedFlow() Lifecycle.isResumedFlow(timeout: Duration) Lifecycle.stateFlow(): Flow<Lifecycle.State>","title":"Added"},{"location":"CHANGELOG/#changed_2","text":"The following extension functions for Lifecycle have been promoted to @ExperimentalSplittiesApi (from @PotentialFutureAndroidXLifecycleKtxApi ): - createScope - createJob - awaitResumed - awaitStarted - awaitCreated - awaitState","title":"Changed"},{"location":"CHANGELOG/#deprecated_1","text":"Dispatchers.MainAndroid is no longer needed and has been deprecated since the performance issue that affected Dispatchers.Main has been fixed since kotlinx.coroutines 1.3.3 . The following extension properties have been deprecated because they are now provided by AndroidX Lifecycle Runtime KTX: - Lifecycle.coroutineScope - LifecycleOwner.lifecycleScope Lifecycle.job has also been deprecated even though there\u2019s no as-concise replacement because it doesn\u2019t satisfy a common use case.","title":"Deprecated"},{"location":"CHANGELOG/#main-thread","text":"","title":"Main Thread"},{"location":"CHANGELOG/#added_4","text":"Now supports macOS, iOS and JS.","title":"Added"},{"location":"CHANGELOG/#material-lists","text":"","title":"Material Lists"},{"location":"CHANGELOG/#changed_3","text":"Ensure all TextView s in the list items are at least one line tall, even if the text is empty. Support enabled/disabled state by making child views duplicate parent state.","title":"Changed"},{"location":"CHANGELOG/#permissions","text":"","title":"Permissions"},{"location":"CHANGELOG/#added_5","text":"New ensureAllPermissions function available in top-level and as extension for FragmentActivity and Fragment to request multiple permissions in a row and ensure you have them all granted.","title":"Added"},{"location":"CHANGELOG/#preferences","text":"","title":"Preferences"},{"location":"CHANGELOG/#added_6","text":"Now supports macOS and iOS (backed by NSUserDefaults , but supports custom implementation too, just like on Android). Added preferences property to PrefDelegate s. Added key property to PrefDelegate s. Added valueFlow() function to PrefDelegate s to get current value and changes of a pref field.","title":"Added"},{"location":"CHANGELOG/#changed_4","text":"The availableAtDirectBoot parameter has been renamed to androidAvailableAtDirectBoot . The XxxPref classes (e.g. BoolPref , StringPref , etc.) are no longer inner classes but are now part of the PrefDelegate sealed class hierarchy.","title":"Changed"},{"location":"CHANGELOG/#resources","text":"","title":"Resources"},{"location":"CHANGELOG/#added_7","text":"New resolveThemeAttribute extension function for Context . This is the replacement for withStyledAttributes .","title":"Added"},{"location":"CHANGELOG/#deprecated_2","text":"withStyledAttributes must be replaced by new resolveThemeAttribute that also has an implementation that is working reliably in IDE Preview. It will be removed in a future release.","title":"Deprecated"},{"location":"CHANGELOG/#snackbar","text":"","title":"Snackbar"},{"location":"CHANGELOG/#changed_5","text":"The snack , longSnack and snackForever extension functions now work with any View instead of just CoordinatorLayout .","title":"Changed"},{"location":"CHANGELOG/#system-services","text":"","title":"System Services"},{"location":"CHANGELOG/#added_8","text":"Add biometricManager from API 29. Add roleManager from API 29.","title":"Added"},{"location":"CHANGELOG/#views-appcompat","text":"","title":"Views AppCompat"},{"location":"CHANGELOG/#added_9","text":"configActionBar extension function for AppCompatActivity . homeAsUp extension read/write property for ActionBar .","title":"Added"},{"location":"CHANGELOG/#changed_6","text":"ActionBar.showTitle now supports reading current value. ActionBar.showHome now supports reading current value. ActionBar.useLogo now supports reading current value. ActionBar.showCustomView now supports reading current value.","title":"Changed"},{"location":"CHANGELOG/#deprecated_3","text":"ActionBar.showHomeAsUp has been deprecated and must be replaced by homeAsUp . It will be removed in a future release.","title":"Deprecated"},{"location":"CHANGELOG/#views-coroutines-views-coroutines-material","text":"","title":"Views Coroutines &amp; Views Coroutines Material"},{"location":"CHANGELOG/#bug-fixes","text":"Fix a very rare crash that would occur when performing two clicks or long clicks in a row (e.g. by calling performClick twice without a UI thread dispatch) when using View.awaitOneClick() , View.awaitOneLongClick() or FloatingActionButton.showAndAwaitOneClickThenHide() .","title":"Bug fixes"},{"location":"CHANGELOG/#views-dsl","text":"","title":"Views DSL"},{"location":"CHANGELOG/#added_10","text":"UiPreView is now included by default, the extra \u201cViews DSL IDE Preview\u201d module is no longer needed. If you never use it in your production code, R8 should remove it from your release app. This has been done to simplify setup. The isInPreview extension properties for Ui and View allow you to condition content to show based on whether it\u2019s the actual app or the IDE preview. Note that it statically evaluates to false in release builds (unlike View.isInEditmode ), so the compiler will remove any code placed in the branch of an if (isInPreview) condition, and will allow R8 to remove any code that was only used in IDE preview. There\u2019s 2 new overloads of the ViewGroup.add extension functions that take either a beforeChild or an afterChild parameter. You must use the parameter name to call one of these overloads. It comes handy in ViewGroup s where the order of the child View s matters (e.g. FrameLayout and LinearLayout ). space to create an android.widget.Space from a Ui , a View or a Context reference. Thanks to @Miha-x64 for the contribution!","title":"Added"},{"location":"CHANGELOG/#changed_7","text":"UiPreView now shows known error cases in the preview itself with a red warning triangle icon.","title":"Changed"},{"location":"CHANGELOG/#views-dsl-constraintlayout","text":"","title":"Views DSL ConstraintLayout"},{"location":"CHANGELOG/#added_11","text":"Add new extensions: above , below , before and after for ConstraintLayout.LayoutParams .","title":"Added"},{"location":"CHANGELOG/#views-dsl-material","text":"","title":"Views DSL Material"},{"location":"CHANGELOG/#added_12","text":"Add slider , rangeSlider and shapeableImageView extensions for View , Ui and Context . They can instantiate the new widgets from the version 1.2.0 of the material-components-android library.","title":"Added"},{"location":"CHANGELOG/#views-dsl-ide-preview","text":"This module has been deprecated. It will no longer published in future releases. Its content has been moved to the main \u201cViews DSL\u201d split.","title":"Views DSL IDE preview"},{"location":"CHANGELOG/#version-300-alpha06-2019-05-03","text":"Compiled with Kotlin 1.3.31.","title":"Version 3.0.0-alpha06 (2019-05-03)"},{"location":"CHANGELOG/#permissions_1","text":"Handle empty grantResults for permission request ( #191 ).","title":"Permissions"},{"location":"CHANGELOG/#version-300-alpha05-2019-04-29","text":"Compiled with Kotlin 1.3.31. This release introduces 3 new splits: Alert Dialog AppCompat Coroutines Permissions Views Coroutines Material The most important change though, is how simpler integrating Splitties in your Android projects has become starting from this release, thanks to the new grouping artifacts. See their content and their maven coordinates in the dedicated part of the README . There is also new features and changes in existing splits, as detailed below.","title":"Version 3.0.0-alpha05 (2019-04-29)"},{"location":"CHANGELOG/#alert-dialog-alert-dialog-appcompat","text":"The alert functions have been deprecated in favor of a more accurate naming: alertDialog . These alertDialog functions are now usable on Context (vs previously only on Activity ), and they have optional parameters to specify the title, the message and even an icon (using a resource id or a Drawable . Also, the title and the message properties are now nullable, in respect to their accepted value.","title":"Alert Dialog &amp; Alert Dialog AppCompat"},{"location":"CHANGELOG/#fragments","text":"The show and showAsync extension functions allow you to show a DialogFragment without fearing the infamous IllegalStateException if the state has already been saved, because it will wait for the lifecycle to be in the RESUMED state before showing the DialogFragment . These 2 extension functions are defined for FragmentManager , FragmentActivity and Fragment . show is a suspending function that resumes after the lifecycle was resumed and the DialogFragment was shown. showAsync is when you are outside of a coroutine but it is marked as experimental because it has \u201casync\u201d in its name while not returning a Deferred . Feel free to suggest a better name in the issues or in the #splitties channel of Kotlin\u2019s Slack.","title":"Fragments"},{"location":"CHANGELOG/#lifecycle-coroutines_1","text":"New suspending inline extensions functions for Lifecycle have been added for convenience: awaitResumed , awaitStarted & awaitCreated . They can replace code like awaitState(Lifecycle.State.RESUMED) for improved readability.","title":"Lifecycle Coroutines"},{"location":"CHANGELOG/#material-lists_1","text":"A new IconTwoLinesCheckBoxListItem class has been added. What it does is self-explanatory. Also, all the list items are now fully xml friendly.","title":"Material Lists"},{"location":"CHANGELOG/#resources_1","text":"The colorSL and appColorSL extension functions no longer return the nullable version of ColorStateList .","title":"Resources"},{"location":"CHANGELOG/#views-dsl-constraintlayout_1","text":"All the ConstraintLayout.LayoutParams extension functions now have overloads that allow specifying the margin. For example, the following code: centerHorizontally () horizontalMargin = dip ( 16 ) can now be written on one line: centerHorizontally(margin = dip(16)) . That improves readability as the word \u201chorizontal\u201d is no longer repeated, and it is still explicit.","title":"Views DSL ConstraintLayout"},{"location":"CHANGELOG/#views-material","text":"Two set-only extensions properties have been added for MaterialButton : iconResource and iconTintAndTextColor .","title":"Views Material"},{"location":"CHANGELOG/#version-300-alpha04-2019-03-03","text":"Compiled with Kotlin 1.3.21.","title":"Version 3.0.0-alpha04 (2019-03-03)"},{"location":"CHANGELOG/#new-features","text":"The wrapContent and matchParent extensions for ViewGroup now apply for View too. Add wrapInScrollView and wrapInHorizontalScrollView extension functions for View . Add experimental multiplatform support with initial Kotlin/JS support for the Bit Flags and Collections splits.","title":"New features"},{"location":"CHANGELOG/#changes","text":"Rename LifecycleOwner.coroutineScope to lifecycleScope . This change is binary compatible. Make wrapInRecyclerView lambda inline. This change is not binary compatible.","title":"Changes"},{"location":"CHANGELOG/#fixes","text":"Remove contract in the Intents split that would cause compilation to fail when used.","title":"Fixes"},{"location":"CHANGELOG/#version-300-alpha03-2019-02-05","text":"Compiled with Kotlin 1.3.20. This release introduces a new split: Views Coroutines .","title":"Version 3.0.0-alpha03 (2019-02-05)"},{"location":"CHANGELOG/#new-features_1","text":"Added radioGroup { ... } functions in Views DSL. Added first class support for ConstraintLayout barriers, guidelines and groups. New styledView function for use when making an API for xml styles usage in Kotlin. See an example in AppCompatStyles . The MaterialComponentsStyles class brings access to all the xml styles defined in Google\u2019s Material Components library for Android in a typesafe way. Add materialCardView { ... } functions in Views DSL Material. Add navigationView { ... } functions in Views DSL Material. Make EditText inputType typesafe with the set only type extension property and the InputType inline class. Views DSL IDE Preview now supports CoroutineContext and CoroutineScope as constructor parameters for Ui subclasses. Added contracts for all the lParams functions from Views DSL and variants. Also added to the roomDb function from Arch Room as well as the verticalListLayoutParams and horizontalListLayoutParams functions from Views DSL RecyclerView. Add support for unsigned numbers in Bit Flags (i.e. UByte , UShort , UInt and ULong ).","title":"New features"},{"location":"CHANGELOG/#changes_1","text":"When using the button function from Views DSL, MaterialButton is now automatically used in place of AppCompatButton if you also use Views DSL Material. Make mainHandler async by default to avoid vSync delays. It is used for Dispatchers.MainAndroid , so it will result in speed improvements when using Lifecycle Coroutines. If you really need sync behavior, you can use the new mainHandlerSync top level property instead. Make Dispatchers.MainAndroid of type MainCoroutineDispatcher so the immediate property is available. Make the awaitState function from Lifecycle Coroutines safe to use off the main thread, and document it. Call validate() from the lParams { ... } function for ConstraintLayout . Make xml styles related classes inline again (thanks to compiler bug fixed in Kotlin 1.3.20). The reified generic variant of view from Views DSL is now an internal API. ViewFactory and related symbols are now an internal API. Mark some SystemServices as nullable to be instant app tolerant. That includes WallpaperManager , WifiManager , WifiP2pManager , UsbManager , DevicePolicyManager , FingerprintManager , ShortcutManager and WifiAwareManager . The Views DSL IDE Preview documentation now states that running the compileDebugKotlin gradle task is enough to update the preview. This is faster than a full build.","title":"Changes"},{"location":"CHANGELOG/#fixes_1","text":"Make viewFactory from Views DSL internal API compatible with IDE Preview.","title":"Fixes"},{"location":"CHANGELOG/#deprecation","text":"The illegal top level function from Exceptions has been deprecated in favor of error from Kotlin stdlib.","title":"Deprecation"},{"location":"CHANGELOG/#new-artifact","text":"This release has the following new artifact: \"com.louiscad.splitties:splitties-views-coroutines:3.0.0-alpha03\"","title":"New artifact"},{"location":"CHANGELOG/#version-300-alpha02-2019-01-06","text":"This release introduces a new split: Lifecycle Coroutines .","title":"Version 3.0.0-alpha02 (2019-01-06)"},{"location":"CHANGELOG/#new-artifact_1","text":"This release has the following new artifact: \"com.louiscad.splitties:splitties-lifecycle-coroutines:3.0.0-alpha02\"","title":"New artifact"},{"location":"CHANGELOG/#version-300-alpha01-2018-12-21","text":"This release is compiled with Kotlin 1.3.11. It is a breaking release (more details in the changes section), and the API is subject to changes as it is back to an alpha stage. APIs that are likely to change have an experimental annotation that triggers a warning (which can be removed by opt-in), to prevent you from using them unintentionally.","title":"Version 3.0.0-alpha01 (2018-12-21)"},{"location":"CHANGELOG/#migration-to-androidx","text":"All the old support library artifacts have been replaced by AndroidX ones. If your project has not migrated to AndroidX yet, please follow the quick steps below. Migrating your project to AndroidX in a `fun` way. (Click to expand) Theoretically, migrating a project to AndroidX is easy: you just select \"Migrate to AndroidX\" from the \"Refactor\" menu. Unfortunately, in addition to being unacceptably slow, it didn't work properly for Splitties (except for a past attempt which had to be abandoned for API stability reasons). _Our experience was waiting minutes with an unresponsive IDE, then giving up with no other choice than force closing Android Studio, and finally getting a broken project, with some dangling fully qualified references (instead of proper import replacement). We reverted and looked for an alternative that would work properly, and perform faster._ The solution has been a Kotlin script that is a white box, and runs in a matter of seconds. You can use it for your project too, so you can migrate to AndroidX quickly, and in a `fun` way. It is available [here](scripts/AndroidX-migrator.kts), and depends on [this csv file](scripts/androidx-class-mapping.csv). _Note that this script doesn't migrate the dependencies, because we changed the way we define dependencies (using constants defined in `buildSrc`), and it would have been harder to handle all the edge cases, and doing it by hand with Replace in Path from IDE was quick enough for us. If you prefer to have it, you are free to contribute and reach out in the issues or elsewhere._ To use it in your project, follow these simple steps: 1. Replace the support libraries dependencies by AndroidX dependencies (and update Splitties ones if you already used it). 2. Copy paste the two files linked above at the root of the gradle project. 3. Edit the `expectedNumberOfModules` property defined in the `AndroidX-migrator.gradle.kts` file to match the number of modules that your project has. 4. Make sure you have `kotlinc` 1.3+ available (see [easy installation in official docs here]( https://kotlinlang.org/docs/tutorials/command-line.html )). 5. Open a terminal at the root of the gradle project. 6. Run `kotlinc -script AndroidX-migrator.gradle.kts` and wait for completion. 7. Sync gradle project. 8. Build the project to ensure everything has migrated properly, or fix and try again.","title":"Migration to AndroidX"},{"location":"CHANGELOG/#improved-api-to-use-xml-styles-defined-in-android-or-appcompat","text":"Now, you pass the Context only once to the AndroidStyles or AppCompatStyles constructor, and you no longer have to pass it to the subsequent functions call. It is advised to obviously cache this instance to reduce boilerplate and avoid overhead. This is a breaking change.","title":"Improved API to use xml styles defined in Android or AppCompat"},{"location":"CHANGELOG/#package-name-changes-and-replaced-artifacts","text":"The design support library no longer exists in AndroidX. It is replaced by several AndroidX artifacts and the Google Material Components library. Consequently, the package names no longer reference \u201cdesign\u201d but \u201ccoordinatorlayout\u201d and \u201cmaterial\u201d instead. As you can see below, the design support library dependent artifacts have been replaced. Note that Views DSL Material has a transitive dependency to Views DSL CoordinatorLayout, so you don\u2019t need to add an explicit dependency for the latter if you already use the former.","title":"Package name changes and replaced artifacts"},{"location":"CHANGELOG/#new-artifacts","text":"This release has the following new artifacts: \"com.louiscad.splitties:splitties-views-material:3.0.0-alpha01\" \"com.louiscad.splitties:splitties-views-dsl-coordinatorlayout:3.0.0-alpha01\" \"com.louiscad.splitties:splitties-views-dsl-material:3.0.0-alpha01\"","title":"New artifacts"},{"location":"CHANGELOG/#removed-artifacts","text":"This release removes these two artifacts: \"com.louiscad.splitties:splitties-views-design-styles:2.1.1\" \"com.louiscad.splitties:splitties-views-dsl-design-styles:2.1.1\"","title":"Removed artifacts"},{"location":"CHANGELOG/#version-211-2018-11-25","text":"This release is compiled with Kotlin 1.3.10.","title":"Version 2.1.1 (2018-11-25)"},{"location":"CHANGELOG/#changes_2","text":"Enforce read-only in the withExtras extension function for Activity . Any attempt to mutate a property inside it will result in an IllegalStateException to be thrown, because this should be done in putExtras instead. You can see more info in the updated KDoc of these functions. Add a withExtras extension function for Intent (previously only available for Activity ). Add a putExtras extension function for Activity (previously only available for Intent ). Fix nullability warning in FragmentArgDelegate. Add KDoc to all public symbols from the Activities split. Add KDoc to all public symbols from the AlertDialog split. Add KDoc to all public symbols from the AlertDialog AppCompat split.","title":"Changes"},{"location":"CHANGELOG/#version-210-2018-11-13","text":"This release targets Android SDK 28, and splits depending on support libraries use version 28.0.0.","title":"Version 2.1.0 (2018-11-13)"},{"location":"CHANGELOG/#changes_3","text":"System Services from API 28 are now included into the same named split. Update ConfigChangesHandlingCollapsingToolbarLayout from View DSL Design to be compatible with design support library version 28.0.0. Update for nullability warnings brought by SDK 28.","title":"Changes"},{"location":"CHANGELOG/#version-200-2018-11-13","text":"This release targets Android SDK 27, and splits depending on support libraries use version 27.1.1.","title":"Version 2.0.0 (2018-11-13)"},{"location":"CHANGELOG/#changes_4","text":"Room updated to version 1.1.1 in Arch Room. Lambdas of onCreate and onOpen functions in Arch Room are now crossinline . The LifecycleObserver class is now marked as experimental.","title":"Changes"},{"location":"CHANGELOG/#version-200-beta1-2018-11-13","text":"This release breaks binary and source compatibility .","title":"Version 2.0.0-beta1 (2018-11-13)"},{"location":"CHANGELOG/#kotlin-130","text":"This is not just a compiler update for Splitties. This release already takes advantage of Kotlin 1.3 features, beyond stable coroutines: The XmlStyle class from Views DSL is now inline, for minimal footprint at runtime. SuspendPrefsAccessor from Preferences is no longer experimental as coroutines graduated. Functions that take a lambda in Views DSL (except lParams functions) have a contract. This directly translates to more freedom in your UI code as you can initialize a property later. withExtras , putExtras and with from Bundle have a contract. This allows to initialize local variables from contents of a Bundle passing through a BundleSpec naturally! Symbols that could change are marked as experimental, for less surprises in the future when they are replaced, renamed or removed (still with a deprecation cycle whenever possible). Only verticalListLayoutParams and horizontalListLayoutParams extension functions for RecyclerView.LayoutManager are experimental for now, but this could change, especially in alpha, or beta stage.","title":"Kotlin 1.3.0"},{"location":"CHANGELOG/#version-200-alpha9-2018-11-13","text":"This release breaks binary and source compatibility . It renames several package names and modules, for more consistency across the project. View DSL has a new name: Views DSL. That also applies to its additional modules. Just like an extra s can make a new generation of smartphones, it can also make a new version of Splitties. The artifact names of all Selectable Views and View DSL changed, and so did the package names. Consequently, after updating the artifact names and the version, you\u2019ll need to update the imports. Fortunately, this is easily done with the \u201cReplace in Path\u201d IDE option present in IntelliJ IDEA and Android Studio. All you need to do is find an old import ( import splitties.viewdsl. ), select it, select the \u201cReplace in Path\u201d option paste ( import splitties.views.dsl. ) in the second input field, and validate. Then, you just have to do the same for Selectable Views with import splitties.selectableviews. and import splitties.views.selectable. \u2026 and voil\u00e0! You just migrated to latest Splitties version!","title":"Version 2.0.0-alpha9 (2018-11-13)"},{"location":"CHANGELOG/#new-artifacts_1","text":"Here are all the artifacts added in this version. Just use the ones you need. (Click to expand) implementation ( \"com.louiscad.splitties:splitties-views-dsl:3.0.0-beta01\" ) implementation ( \"com.louiscad.splitties:splitties-views-dsl-appcompat:3.0.0-beta01\" ) implementation ( \"com.louiscad.splitties:splitties-views-dsl-constraintlayout:3.0.0-beta01\" ) implementation ( \"com.louiscad.splitties:splitties-views-dsl-design:3.0.0-beta01\" ) debugImplementation ( \"com.louiscad.splitties:splitties-views-dsl-ide-preview:3.0.0-beta01\" ) implementation ( \"com.louiscad.splitties:splitties-views-dsl-recyclerview:3.0.0-beta01\" ) implementation ( \"com.louiscad.splitties:splitties-views-selectable:3.0.0-beta01\" ) implementation ( \"com.louiscad.splitties:splitties-views-selectable-appcompat:3.0.0-beta01\" ) implementation ( \"com.louiscad.splitties:splitties-views-selectable-constraintlayout:3.0.0-beta01\" ) All the lines above assume you defined the `splitties_version` ext property in your root project's `build.gradle` file to `2.0.0-alpha9` as shown in this snippet: allProjects { ext { splitties_version = '2.0.0-alpha9' } }","title":"New artifacts"},{"location":"CHANGELOG/#removed-artifacts_1","text":"This release removes all these artifacts: implementation(\"com.louiscad.splitties:splitties-selectableviews:3.0.0-beta01\") implementation(\"com.louiscad.splitties:splitties-selectableviews-appcompat:3.0.0-beta01\") implementation(\"com.louiscad.splitties:splitties-selectableviews-constraintlayout:3.0.0-beta01\") implementation(\"com.louiscad.splitties:splitties-viewdsl:3.0.0-beta01\") implementation(\"com.louiscad.splitties:splitties-viewdsl-appcompat:3.0.0-beta01\") implementation(\"com.louiscad.splitties:splitties-viewdsl-constraintlayout:3.0.0-beta01\") implementation(\"com.louiscad.splitties:splitties-viewdsl-design:3.0.0-beta01\") debugImplementation(\"com.louiscad.splitties:splitties-viewdsl-ide-preview:3.0.0-beta01\") implementation(\"com.louiscad.splitties:splitties-viewdsl-recyclerview:3.0.0-beta01\")","title":"Removed artifacts"},{"location":"CHANGELOG/#version-200-alpha8-2018-11-12","text":"This release breaks binary compatibility . It removes all deprecated symbols that had their deprecation level raised to error in 2.0.0-alpha7. Make sure you don\u2019t rely on any library that uses an old version of a Splitties artifact that relies on these previously deprecated and now removed symbols, or your app is likely not build, or to crash at runtime because of not found classes.","title":"Version 2.0.0-alpha8 (2018-11-12)"},{"location":"CHANGELOG/#version-200-alpha7-2018-11-12","text":"Raise all deprecated symbols deprecation level to error. Use this version to make sure you don\u2019t use them in your projects, next version will remove them!","title":"Version 2.0.0-alpha7 (2018-11-12)"},{"location":"CHANGELOG/#version-200-alpha6-2018-11-11","text":"Version 2.0.0-alpha5 broke the API, this version fixes this.","title":"Version 2.0.0-alpha6 (2018-11-11)"},{"location":"CHANGELOG/#like-version-200-alpha5-but-without-breaking-the-api-from-200-alpha4","text":"This release is mostly the same as 2.0.0-alpha5, but also has 2 very important things: - binary compatibility (minor change in Preferences experimental API excluded) - source compatibility, except an overload resolution ambiguity in View DSL, see the migration guide for a smooth migration.","title":"Like version 2.0.0-alpha5, but without breaking the API from 2.0.0-alpha4"},{"location":"CHANGELOG/#removed-splits-and-versions-sync","text":"Version 2.0.0-alpha5 technically removed 2 splits (one was actually a renaming, the other one a merging). Consequently, you have to make sure your dependencies no longer reference these removed artifacts. Easily done. Problems arise when you depend on libraries that themselves depend on Splitties, which may be older versions. These libraries may bring transitive dependencies to old modules that will clash with ones from newer versions, and the versions they rely on may also mismatch with the ones you need, and these older versions will take precedence if they are in library modules of your project that don\u2019t depend explicitly on a newer version. Fortunately, Gradle dependency resolution strategy allows to easily fix these issues all over your project. All you need to do is to make sure you have the following snippet into your root project\u2019s build.gradle file: allprojects { ext { splitties_version = '2.0.0-alpha6' } configurations . all { resolutionStrategy . eachDependency { DependencyResolveDetails details -> def req = details . requested if ( req . group != \"com.louiscad.splitties\" ) return if ( req . name == \"splitties-uithread\" ) { details . useTarget ( group: req . group , name: \"splitties-mainthread\" , version: splitties_version ) details . because ( \"Splitties uithread has been renamed to mainthread\" ) } else if ( req . name == \"splitties-viewdsl-appcompat-styles\" ) { details . useTarget ( group: req . group , name: \"splitties-viewdsl-appcompat\" , version: splitties_version ) details . because ( \"[Splitties] Split merged and removed\" ) } else { details . useTarget ( group: req . group , name: req . name , version: splitties_version ) details . because ( \"Transitive dependencies could take precedence otherwise\" ) } } } } The snippet above, for all sub-projects (aka. modules): 1. defines Splitties version in an ext property so it can be used in all build.gradle files. 2. sets a resolution strategy for all configurations (like implementation or api ) which: 1. redirects any usage of the old splitties-mainthread artifact to the new splitties-mainthread one. 2. redirects any usage of the old splitties-viewdsl-appcompat-styles artifact to the one it has been merged into: splitties-viewdsl-appcompat . 3. makes sure all splitties artifacts versions are in sync, across all sub-projects. If you don\u2019t do this but have a library using an old artifact in your dependencies, you\u2019ll encounter gradle sync issues, or runtime issues, and the real cause may not appear clearly (because of bugs in tooling).","title":"Removed splits and versions sync"},{"location":"CHANGELOG/#changes-per-module","text":"","title":"Changes per module"},{"location":"CHANGELOG/#checked-lazy","text":"uiLazy has been deprecated in favor of mainThreadLazy .","title":"Checked Lazy"},{"location":"CHANGELOG/#view-dsl-recyclerview","text":"The wrapInRecyclerView extension function now accepts an optional lambda to configure the wrapping RecyclerView easily.","title":"View DSL RecyclerView"},{"location":"CHANGELOG/#version-200-alpha5-2018-11-02","text":"This release is breaking if you come from version 2.0.0-alpha4, especially if you were using View DSL. It\u2019s highly recommended to directly migrate from version 2.0.0-alpha4 to 2.0.0-alpha6, which has a smoother migration path, and a guide to do so.","title":"Version 2.0.0-alpha5 (2018-11-02)"},{"location":"CHANGELOG/#project-wide-changes","text":"Add consumer proguard rules for splits with optional dependencies. Update to Kotlin 1.2.71 Update kotlinx.coroutines to version 0.30.2","title":"Project wide changes"},{"location":"CHANGELOG/#changes-per-module_1","text":"","title":"Changes per module"},{"location":"CHANGELOG/#collections_1","text":"Add allocation-free reverse List forEach extensions: forEachReversedByIndex and forEachReversedWithIndex .","title":"Collections"},{"location":"CHANGELOG/#intents","text":"Add toPendingActivities() extension function for Array<Intent> .","title":"Intents"},{"location":"CHANGELOG/#material-lists_2","text":"The following previously deprecated classes have been removed: SingleLineIconListItem (use IconOneLineListItem instead) TwoLinesIconListItem (use IconTwoLinesListItem instead) TwoLinesIconSwitchListItem (use IconTwoLinesSwitchListItem instead) All the xml files (except view_ids.xml ) have been removed.","title":"Material Lists"},{"location":"CHANGELOG/#preferences_1","text":"","title":"Preferences"},{"location":"CHANGELOG/#enhancements","text":"The preferences are now loaded in Dispatchers.IO when using SuspendPrefsAccessor . Fix clash with private property name and non imported extension for Preferences. (#96).","title":"Enhancements"},{"location":"CHANGELOG/#breaking-changes-in-experimental-api","text":"The SuspendPrefsAccessor constructor parameter of type CoroutineDispatcher has been removed now that Dispatchers.IO is always used. If you didn\u2019t specify a custom dispatcher, you don\u2019t need to do anything.","title":"Breaking changes (in experimental API)"},{"location":"CHANGELOG/#selectable-views-all-variants","text":"All the final methods have been opened up, and now have the @CallSuper annotation instead. This makes the classes more useful to develop custom views, like the extended Floating Action Button with SelectableConstraintLayout where you need to clip the view in onDraw(\u2026) . The dispatchDrawableHotspotChanged overridden method in the classes of the Selectable Views splits family was annotated with @TargetApi , but is not correctly annotated with @RequiresApi . This likely caused no issue as you usually don\u2019t call this method directly but let Android do, but now, it\u2019s fixed!","title":"Selectable Views (all variants)"},{"location":"CHANGELOG/#ui-thread-main-thread","text":"The UI Thread split has been renamed to Main thread (for the same reasons kotlinx.coroutines replaced UI by Dispatchers.Main ). While the artifact has been changed , the old symbols have only been deprecated in favor of new ones defined in new package, with new names ( ui -> main ). If you use a library that depends on the old artifact, see \u201cRemoved splits and versions sync\u201d in version 2.0.0-alpha6 release notes.","title":"~UI Thread~ -&gt; Main Thread"},{"location":"CHANGELOG/#view-dsl-and-additional-modules","text":"The API of View DSL (and its additional modules) has been improved, and there\u2019s some new features, along with some deprecations. However, this release (2.0.0-alpha5) is breaking when updating from previous versions. This has been fixed in 2.0.0-alpha6, so please skip this release if you are upgrading , and follow thoroughly the migration guide . Regardless, there has been improvements in View DSL additional modules. Please, review them below.","title":"View DSL (and additional modules)"},{"location":"CHANGELOG/#view-dsl-appcompat-styles-view-dsl-appcompat","text":"The View DSL AppCompat Styles split has been merged into View DSL AppCompat. If you use a library that depends on the old artifact, see \u201cRemoved splits and versions sync\u201d in version 2.0.0-alpha6 release notes.","title":"~View DSL AppCompat Styles~ -&gt; View DSL AppCompat"},{"location":"CHANGELOG/#view-dsl-constraintlayout","text":"Probably the best change in this split is that now, you no longer need to specify any View id. If there\u2019s none and you add a constraint using extension functions from this split, an id that can\u2019t clash with aapt/xml ids will be generated and assigned to the view so constraints work. Keep in mind you may still want to use stable ids defined in xml or elsewhere in cases where you use views that need to have their state saved, like a RecyclerView , an EditText or a CheckBox . Added support for chains with the two horizontalChain and verticalChain new extension functions for ConstraintLayout . Also added horizontalMargin and verticalMargin extension properties for List<View> that are designed for use in a ConstraintLayout when you made a chain with the two new methods that take a list of views.","title":"View DSL ConstraintLayout"},{"location":"CHANGELOG/#view-dsl-design","text":"When instantiating an AppBarLayout or a CollapsingToolbarLayout with the new appBarLayout and collapsingToolbarLayout functions, you\u2019ll automatically get instances that have known bugs in the design support library fixed, including config changes handling (supports rotation or layout changes without recreating the Activity).","title":"View DSL Design"},{"location":"CHANGELOG/#view-dsl-recyclerview_1","text":"The setSingleView extension function for RecyclerView has been deprecated. Use the wrapInRecyclerView extension function for View instead, it is simpler to use and supports horizontal scrolling.","title":"View DSL RecyclerView"},{"location":"CHANGELOG/#views","text":"Deprecated View visibility extension properties and functions in favor of Android KTX ones. Added lines write only extension property for TextView . Change the signature of the lambda of the onClick extension function for View . It no longer passes the clicked view . This is to avoid it shadowing when you nest lambdas, and has been done because this parameter is almost never used. Add 1 extension function, 1 extension property and 1 top level function, related to View id generation: View.assignAndGetGeneratedId() , View.existingOrNewId and generateViewId() .","title":"Views"},{"location":"CHANGELOG/#upcoming-apis-preview-in-the-sample","text":"The sample of Splitties is a place where you can preview several extensions or other work that can be integrated into Splitties as a library later. In addition to what was already present in the sample, there has been an important addition: An example of how to request a dangerous permission with a single suspend call, plus a try/catch to handle user deny.","title":"Upcoming APIs preview in the sample"},{"location":"CHANGELOG/#new-artifact_2","text":"This release has a new artifact: implementation ( \"com.louiscad.splitties:splitties-mainthread:3.0.0-beta01\" )","title":"New artifact"},{"location":"CHANGELOG/#removed-artifacts_2","text":"This release removes these two artifacts: implementation(\"com.louiscad.splitties:splitties-uithread:3.0.0-beta01\") implementation(\"com.louiscad.splitties:splitties-viewdsl-appcompat-styles:3.0.0-beta01\")","title":"Removed artifacts"},{"location":"CHANGELOG/#version-200-alpha4-2018-07-09","text":"Provide ReplaceWith migrations for add methods deprecated in version 2.0.0-alpha2. Add default empty lambda for startActivity(action: String\u2026) methods. Compiled with Kotlin 1.2.51","title":"Version 2.0.0-alpha4 (2018-07-09)"},{"location":"CHANGELOG/#version-200-alpha3-2018-06-09","text":"","title":"Version 2.0.0-alpha3 (2018-06-09)"},{"location":"CHANGELOG/#new-features_2","text":"","title":"New features"},{"location":"CHANGELOG/#bundle","text":"There are 2 new methods: bundleOrDefault(\u2026) and bundleOrElse { \u2026 } to allow default values in BundleSpec delegated properties.","title":"Bundle"},{"location":"CHANGELOG/#fragment-args","text":"Like for BundleSpec , there are 2 new methods: argOrDefault(\u2026) and argOrElse { \u2026 } to allow default values in Fragment delegated argument properties.","title":"Fragment Args"},{"location":"CHANGELOG/#breaking-changes","text":"","title":"Breaking changes"},{"location":"CHANGELOG/#bundle_1","text":"The delegates previously returned by bundle() and bundleOrNull() are no longer part of the public API and have been replaced by the ReadWriteProperty interface.","title":"Bundle"},{"location":"CHANGELOG/#fragment-args_1","text":"The arg() and argOrNull() functions have moved out of the support subpackage as there\u2019s no longer any ambiguity since platform Fragments are deprecated and going away. Auto-import should import the versions from the new package for you. The delegates previously returned by arg() and argOrNull() are no longer part of the public API and have been replaced by the ReadWriteProperty interface.","title":"Fragment Args"},{"location":"CHANGELOG/#version-200-alpha2-2018-05-21","text":"","title":"Version 2.0.0-alpha2 (2018-05-21)"},{"location":"CHANGELOG/#9-new-library-modules-amounting-to-a-total-of-42-splits","text":"Activities : Start activities with minimal boilerplate Collections : forEach for List s without Iterator allocation Fragments : Start activities from fragments and do transactions with minimal boilerplate Intents : Transform companion object s into powerful typesafe intent specs Material Colors : 2014 Material Design color palettes as color resources View DSL RecyclerView : RecyclerView extension of View DSL Views CardView : CardView extension of Views. Provides a contentPadding property View Design : Design Support library extension of Views Views RecyclerView : RecyclerView extension of Views","title":"9 new library modules (amounting to a total of 42 splits):"},{"location":"CHANGELOG/#other-changes","text":"","title":"Other changes:"},{"location":"CHANGELOG/#appctx","text":"The consume { \u2026 } utility function from the splitties.init package has been deprecated. Replace it with true.also { _ -> \u2026 } or false.also { _ -> \u2026 } .","title":"AppCtx"},{"location":"CHANGELOG/#arch-lifecycle_1","text":"New mapNotNull , switchMap and switchMapNotNull extension functions for LiveData . activityScope and fragmentScope extension functions to get a ViewModel now accept an optional lambda (which creates a ViewModelProvider under the hood. This allows to pass arguments to your ViewModel when it\u2019s first created. observe and observeNotNull now return the created Observer so it can be unregistered manually later if needed.","title":"Arch Lifecycle"},{"location":"CHANGELOG/#arch-room","text":"The new inTransaction { \u2026 } extension function for RoomDatabase s does the same as transaction { \u2026 } but also returns the value of the last expression of the lambda. New onCreate { \u2026 } and onOpen { \u2026 } extension functions for RoomDatabase.Builder .","title":"Arch Room"},{"location":"CHANGELOG/#bundle_2","text":"BundleHelper has been renamed to BundleSpec , but a typealias keeps the source compatibility. However, there\u2019s no binary compatibility, which means you\u2019ll need to recompile any library using it. BundleSpec and the methods relying on it can now be used safely on any thread!","title":"Bundle"},{"location":"CHANGELOG/#material-lists_3","text":"Allow disabling default icon tint on list items with optional constructor parameter.","title":"Material Lists"},{"location":"CHANGELOG/#preferences_2","text":"A new experimental SuspendPrefsAccessor for coroutines users allows you to ensure you can\u2019t load the preferences (which does I/O) on the UI thread.","title":"Preferences"},{"location":"CHANGELOG/#resources_2","text":"The str extension functions formatArgs now accept null arguments.","title":"Resources"},{"location":"CHANGELOG/#view-dsl","text":"The higher order function add has been deprecated because it went in the way of promoting a view to a property easily.","title":"View DSL"},{"location":"CHANGELOG/#view-dsl-appcompat-styles","text":"Added flatButton , imgActionButton and largeProgressBar .","title":"View DSL AppCompat styles"},{"location":"CHANGELOG/#view-dsl-constraintlayout_1","text":"Add baselineToBaselineOf(\u2026) extension function for ConstraintLayout.LayoutParams .","title":"View DSL ConstraintLayout"},{"location":"CHANGELOG/#view-dsl-ide-preview","text":"UiPreView injects a valid value into appCtx so your Ui s can depend on it (probably indirectly) without breaking preview!","title":"View DSL IDE Preview"},{"location":"CHANGELOG/#views_1","text":"New Gravity flags aliases (e.g. gravityStartCenter instead of Gravity.START or Gravity.CENTER_VERTICAL ). Change case of imageBitMap to imageBitmap to make it more consistent with the class name Bitmap","title":"Views"},{"location":"CHANGELOG/#views-appcompat_1","text":"tooltipTxt now accepts null to remove any tooltip previously set on the view.","title":"Views AppCompat"},{"location":"CHANGELOG/#new-artifacts_2","text":"Here are all the artifacts added in this version. Just use the ones you need. (Click to expand) implementation ( \"com.louiscad.splitties:splitties-activities:3.0.0-beta01\" ) implementation ( \"com.louiscad.splitties:splitties-collections:3.0.0-beta01\" ) implementation ( \"com.louiscad.splitties:splitties-fragments:3.0.0-beta01\" ) implementation ( \"com.louiscad.splitties:splitties-intents:3.0.0-beta01\" ) implementation ( \"com.louiscad.splitties:splitties-material-colors:3.0.0-beta01\" ) implementation ( \"com.louiscad.splitties:splitties-viewdsl-recyclerview:3.0.0-beta01\" ) implementation ( \"com.louiscad.splitties:splitties-views-cardview:3.0.0-beta01\" ) implementation ( \"com.louiscad.splitties:splitties-views-design:3.0.0-beta01\" ) implementation ( \"com.louiscad.splitties:splitties-views-recyclerview:3.0.0-beta01\" ) All the lines above assume you defined the `splitties_version` ext property in your root project's `build.gradle` file to `2.0.0-alpha2` as shown in this snippet: allProjects { ext { splitties_version = '2.0.0-alpha2' } }","title":"New artifacts"},{"location":"CHANGELOG/#version-200-alpha1-2018-03-11","text":"","title":"Version 2.0.0-alpha1 (2018-03-11)"},{"location":"CHANGELOG/#26-new-library-modules-amounting-to-a-total-of-33-splits","text":"Alert Dialog : Create simple alert dialogs with simple code Alert Dialog AppCompat : AppCompat version of Alert Dialog Arch Lifecycle : Extensions to get ViewModel s, use LiveData and observe Lifecycle s Arch Room : Room helpers to instantiate your DB and perform transactions in Kotlin Bit Flags : hasFlag , withFlag and minusFlag extensions on Long , Int , Short and Byte Bundle : BundleHelper to use Bundle with property syntax for Intent extras and more Dimensions : Android dp extensions for View and Context . Particularly handy when using View DSL Exceptions : illegal(\u2026) and similar functions that return Nothing , handy for impossible or illegal when branches Fragment Args : Fragment arguments without ceremony thanks to delegated properties Init Provider : Base class for ContentProvider s used for automatic initialization purposes Main Handler : Top-level mainHandler property to stop allocating multiple Handler s for main Looper Resources : Extensions to get resources like strings, colors or drawables easily, with support for themed attributes Selectable Views AppCompat : Selectable Views for AppCompatTextView Selectable Views ConstraintLayout : Selectable Views for ConstraintLayout Snackbar : Grab a snack without ceremony with snack(\u2026) and longSnack(\u2026) System Services : No more context.getSystemService(NAME_OF_SERVICE) as NameOfManager Toast : Show a toast by just calling toast(yourText) , and dodge API 25 BadTokenException UI Thread : Properties related to Android UI thread, and checkUiThread() precondition checker View DSL : Create UIs with readable Kotlin code View DSL AppCompat : AppCompat extension of View DSL View DSL AppCompat styles : AppCompat styles for View DSL View DSL ConstraintLayout : ConstraintLayout extension of View DSL View DSL Design : Design Support Library extension of View DSL View DSL IDE preview : Preview View DSL UIs in the IDE Views : Extensions function and properties on View s Views AppCompat : AppCompat extension of Views. Includes helpers for ImageView tinting, ActionBar and tooltip","title":"26 new library modules (amounting to a total of 33 splits):"},{"location":"CHANGELOG/#1-renamed-module","text":"\u201cChecked Lazy\u201d replaces the \u201cConcurrency\u201d module.","title":"1 renamed module:"},{"location":"CHANGELOG/#other-changes_1","text":"The groupId of the library changed from xyz.louiscad.splitties to com.louiscad.splitties . Check dependencies list below. All previous modules migrated to Kotlin, excepted the ViewHolder class from the Typesafe RecyclerView module that can\u2019t be written in Kotlin at the moment due to hiding super fields not being supported. App Context module has a new, memory leak safe injectAsAppCtx() method, that uses the new canLeakMemory() extension function on Context that is also public. Preferences StringPref and stringPref don\u2019t allow null values anymore. Use StringOrNullPref and stringOrNullPref if you need nullable strings. Same for StringSetPref and stringSetPref . The isUiThread property moved from the old \u201cConcurrency\u201d module to the \u201cUI Thread\u201d module. Material Lists are now written in Kotlin with View DSL, fixing icon tinting support on day/night themes and behavior on long texts. Also, the naming has been improved. Old named items are now deprecated. Checked Lazy does no longer depend on Timber but is now more configurable, allowing to write reporting behavior if needed. Selectable Views has been split in base module (that includes only dependencies on Android platform), AppCompat module and ConstraintLayout module. Selectable Views don\u2019t support the foreground xml attribute from app namespace anymore, but there\u2019s a new foregroundSelector property.","title":"Other changes:"},{"location":"CHANGELOG/#new-artifacts_3","text":"Here are all the artifacts added in this version. Just use the ones you need. (Click to expand) implementation ( \"com.louiscad.splitties:splitties-alertdialog:3.0.0-beta01\" ) implementation ( \"com.louiscad.splitties:splitties-alertdialog-appcompat:3.0.0-beta01\" ) implementation ( \"com.louiscad.splitties:splitties-appctx:3.0.0-beta01\" ) implementation ( \"com.louiscad.splitties:splitties-arch-lifecycle:3.0.0-beta01\" ) implementation ( \"com.louiscad.splitties:splitties-arch-room:3.0.0-beta01\" ) implementation ( \"com.louiscad.splitties:splitties-bitflags:3.0.0-beta01\" ) implementation ( \"com.louiscad.splitties:splitties-bundle:3.0.0-beta01\" ) implementation ( \"com.louiscad.splitties:splitties-checkedlazy:3.0.0-beta01\" ) implementation ( \"com.louiscad.splitties:splitties-dimensions:3.0.0-beta01\" ) implementation ( \"com.louiscad.splitties:splitties-exceptions:3.0.0-beta01\" ) implementation ( \"com.louiscad.splitties:splitties-initprovider:3.0.0-beta01\" ) implementation ( \"com.louiscad.splitties:splitties-mainhandler:3.0.0-beta01\" ) implementation ( \"com.louiscad.splitties:splitties-material-lists:3.0.0-beta01\" ) implementation ( \"com.louiscad.splitties:splitties-preferences:3.0.0-beta01\" ) implementation ( \"com.louiscad.splitties:splitties-resources:3.0.0-beta01\" ) implementation ( \"com.louiscad.splitties:splitties-fragmentargs:3.0.0-beta01\" ) implementation ( \"com.louiscad.splitties:splitties-selectableviews:3.0.0-beta01\" ) implementation ( \"com.louiscad.splitties:splitties-selectableviews-appcompat:3.0.0-beta01\" ) implementation ( \"com.louiscad.splitties:splitties-selectableviews-constraintlayout:3.0.0-beta01\" ) debugImplementation ( \"com.louiscad.splitties:splitties-stetho-init:3.0.0-beta01\" ) implementation ( \"com.louiscad.splitties:splitties-systemservices:3.0.0-beta01\" ) implementation ( \"com.louiscad.splitties:splitties-toast:3.0.0-beta01\" ) implementation ( \"com.louiscad.splitties:splitties-typesaferecyclerview:3.0.0-beta01\" ) implementation ( \"com.louiscad.splitties:splitties-uithread:3.0.0-beta01\" ) implementation ( \"com.louiscad.splitties:splitties-snackbar:3.0.0-beta01\" ) implementation ( \"com.louiscad.splitties:splitties-viewdsl:3.0.0-beta01\" ) implementation ( \"com.louiscad.splitties:splitties-viewdsl-appcompat:3.0.0-beta01\" ) implementation ( \"com.louiscad.splitties:splitties-viewdsl-appcompat-styles:3.0.0-beta01\" ) implementation ( \"com.louiscad.splitties:splitties-viewdsl-constraintlayout:3.0.0-beta01\" ) implementation ( \"com.louiscad.splitties:splitties-viewdsl-design:3.0.0-beta01\" ) debugImplementation ( \"com.louiscad.splitties:splitties-viewdsl-ide-preview:3.0.0-beta01\" ) implementation ( \"com.louiscad.splitties:splitties-views:3.0.0-beta01\" ) implementation ( \"com.louiscad.splitties:splitties-views-appcompat:3.0.0-beta01\" ) All the lines above assume you defined the `splitties_version` ext property in your root project's `build.gradle` file to `2.0.0-alpha1` as show in this snippet: allProjects { ext { splitties_version = '2.0.0-alpha1' } }","title":"New artifacts"},{"location":"CHANGELOG/#version-130-2017-04-17","text":"","title":"Version 1.3.0 (2017-04-17)"},{"location":"CHANGELOG/#5-new-library-modules","text":"App Context : Have a Context everywhere Concurrency : Single thread lazy implementations, with reporting via Timber support Material Lists : List Items for RecyclerView implementing Material Design Guidelines Preferences : Property syntax for Android\u2019s SharedPreferences Stetho init : Have Stetho without writing any code!","title":"5 new library modules:"},{"location":"CHANGELOG/#1-renamed-module_1","text":"Selectable Views replaces Selectable ViewGroups","title":"1 renamed module:"},{"location":"CHANGELOG/#other-changes_2","text":"Selectable Views now has a SelectableTextView . Made to use it on simple, single-line list items. Typesafe RecyclerView now depends on Kotlin Typesafe RecyclerView has a new ItemViewHolder helper class for simple but common use cases.","title":"Other changes:"},{"location":"CHANGELOG/#version-12-2016-09-19","text":"This version adds the setHost(Host host) method in ViewWrapper.Binder interface where Host can be any type you want you can use from the implementing item View to communicate with your Activity, Fragment, Presenter, or whatever. Note this adds a third type parameter to the ViewWrapper class, and a second one for the ViewWrapper.Binder class.","title":"Version 1.2 (2016-09-19)"},{"location":"CHANGELOG/#version-11-2016-09-11","text":"This version adds the setViewHolder(ViewWrapper holder) method in ViewWrapper.Binder interface so list item View s can now get a reference to their ViewHolder , and call getAdapterPosition() on it for example.","title":"Version 1.1 (2016-09-11)"},{"location":"CHANGELOG/#version-10-2016-08-24","text":"This is the first release of Splitties. It includes two independent modules: - Typesafe RecyclerView - Selectable ViewGroups For gradle projects from jcenter() repo: compile 'xyz.louiscad.splitties:selectableviewgroups:1.0' compile 'xyz.louiscad.splitties:typesaferecyclerview:1.0'","title":"Version 1.0 (2016-08-24)"},{"location":"RELEASING/","text":"Releasing this library: \u00b6 Releasing a stable, beta or alpha version \u00b6 Run the interactive script Run Releasing.kts (preferably in system terminal as IDE could crash) with kotlinc -script Releasing.kts and follow the steps directly from the command line. Publishing a dev version \u00b6 Make sure splitties.version in the libraries_version.txt file is set to a new -dev- version. Commit \u201cDev version X.X.X-dev-XXX\u201d Push the commit and wait for the GitHub Action to run the release (the automated workflow should take less than an hour).","title":"Releasing"},{"location":"RELEASING/#releasing-this-library","text":"","title":"Releasing this library:"},{"location":"RELEASING/#releasing-a-stable-beta-or-alpha-version","text":"Run the interactive script Run Releasing.kts (preferably in system terminal as IDE could crash) with kotlinc -script Releasing.kts and follow the steps directly from the command line.","title":"Releasing a stable, beta or alpha version"},{"location":"RELEASING/#publishing-a-dev-version","text":"Make sure splitties.version in the libraries_version.txt file is set to a new -dev- version. Commit \u201cDev version X.X.X-dev-XXX\u201d Push the commit and wait for the GitHub Action to run the release (the automated workflow should take less than an hour).","title":"Publishing a dev version"},{"location":"2/","text":"Splitties \u00b6 Splitties is a collection of small independent Android libraries that aims to make developing apps and libraries for Android (including Wear, TV, Things, Auto and ChromeOS targeted) easier and more fun . Some modules are similar to what Anko provides. This project is named \u201cSplitties\u201d because it is split in small modules, distributed as independent Android libraries, so you can add only the ones you need to your project/module, helping reduce the size of the final apk. Each module has been designed to have a small footprint and be as efficient as possible. All the splits \u00b6 Activities: Start activities with minimal boilerplate. Alert Dialog: Create simple alert dialogs with simple code. Alert Dialog AppCompat: AppCompat version of Alert Dialog . App Context: Always have your application Context at hand with appCtx . Arch Lifecycle: Extensions to get ViewModel s, use LiveData and observe Lifecycle s. Arch Room: Room helpers to instantiate your DB and perform transactions in Kotlin. Bit Flags: hasFlag , withFlag and minusFlag extensions on Long , Int , Short and Byte . Bundle: BundleSpec to use Bundle with property syntax for Intent extras and more. Collections: forEach for List s without Iterator allocation. Checked Lazy: mainThreadLazy that checks property access on main thread, and checkedLazy to make your own variant. Dimensions: Android dp extensions for View and Context . Particularly handy when using Views DSL . Exceptions: illegal(\u2026) and similar functions that return Nothing , handy for impossible or illegal when branches. Fragments: Start activities from fragments and do transactions with minimal boilerplate. Fragment Args: Fragment arguments without ceremony thanks to delegated properties. Init Provider: Base class for ContentProvider s used for automatic initialization purposes. Intents: Transform companion object s into powerful typesafe intent specs, and create PendingIntent s the clean and easy way. Main Handler: Top-level mainHandler property to stop allocating multiple Handler s for main Looper . Main Thread: Properties and precondition checkers related to Android main thread. Material Colors: 2014 Material Design color palettes as color resources. Material Lists: List item Views implementing Material Design guidelines (perfect for usage in a RecyclerView ). Preferences: Property syntax for Android\u2019s SharedPreferences. Resources: Extensions to get resources like strings, colors or drawables easily, with support for themed attributes. Selectable Views: Selectable Views with foreground property before API 23. Selectable Views AppCompat: Selectable Views for AppCompatTextView. Selectable Views ConstraintLayout: Selectable Views for ConstraintLayout. Snackbar: Grab a snack without ceremony with snack(\u2026) and longSnack(\u2026) . Stetho init: Have Stetho for your debug builds, without writing any code! System Services: No more context.getSystemService(NAME_OF_SERVICE) as NameOfManager . Toast: Show a toast by just calling toast(yourText) , and dodge API 25 BadTokenException . Typesafe RecyclerView: Typesafe ViewHolder and ItemViewHolder for easy basic usage of RecyclerView . Views: Extensions function and properties on View s. Views AppCompat: AppCompat extension of Views . Includes helpers for ImageView tinting, ActionBar and tooltip. Views CardView: CardView extension of Views . Provides a contentPadding property. Views Design: Design Support library extension of Views . Views DSL: Create UIs with readable Kotlin code. Views DSL AppCompat: AppCompat extension of Views DSL . Views DSL ConstraintLayout: ConstraintLayout extension of Views DSL . Views DSL Design: Design Support Library extension of Views DSL . Views DSL IDE preview: Preview Views DSL UIs in the IDE. Views DSL RecyclerView: RecyclerView extension of Views DSL . Views RecyclerView: RecyclerView extension of Views . Download \u00b6 Gradle instructions \u00b6 Make sure you have jcenter() in the repositories defined in your project\u2019s (root) build.gradle file (default for new Android Studio projects). Add the version of the library to not repeat yourself if you use multiple artifacts, and make sure their versions are in sync by adding an ext property into your root project build.gradle file: allProjects { ext { splitties_version = '2.1.1' } } Here are all the artifacts of this library. Just use the ones you need. (Click to expand) implementation \"com.louiscad.splitties:splitties-activities:2.1.1\" implementation \"com.louiscad.splitties:splitties-alertdialog:2.1.1\" implementation \"com.louiscad.splitties:splitties-alertdialog-appcompat:2.1.1\" implementation \"com.louiscad.splitties:splitties-appctx:2.1.1\" implementation \"com.louiscad.splitties:splitties-arch-lifecycle:2.1.1\" implementation \"com.louiscad.splitties:splitties-arch-room:2.1.1\" implementation \"com.louiscad.splitties:splitties-bitflags:2.1.1\" implementation \"com.louiscad.splitties:splitties-bundle:2.1.1\" implementation \"com.louiscad.splitties:splitties-checkedlazy:2.1.1\" implementation \"com.louiscad.splitties:splitties-collections:2.1.1\" implementation \"com.louiscad.splitties:splitties-dimensions:2.1.1\" implementation \"com.louiscad.splitties:splitties-exceptions:2.1.1\" implementation \"com.louiscad.splitties:splitties-fragments:2.1.1\" implementation \"com.louiscad.splitties:splitties-fragmentargs:2.1.1\" implementation \"com.louiscad.splitties:splitties-initprovider:2.1.1\" implementation \"com.louiscad.splitties:splitties-intents:2.1.1\" implementation \"com.louiscad.splitties:splitties-mainhandler:2.1.1\" implementation \"com.louiscad.splitties:splitties-mainthread:2.1.1\" implementation \"com.louiscad.splitties:splitties-material-colors:2.1.1\" implementation \"com.louiscad.splitties:splitties-material-lists:2.1.1\" implementation \"com.louiscad.splitties:splitties-preferences:2.1.1\" implementation \"com.louiscad.splitties:splitties-resources:2.1.1\" implementation \"com.louiscad.splitties:splitties-snackbar:2.1.1\" debugImplementation \"com.louiscad.splitties:splitties-stetho-init:2.1.1\" implementation \"com.louiscad.splitties:splitties-systemservices:2.1.1\" implementation \"com.louiscad.splitties:splitties-toast:2.1.1\" implementation \"com.louiscad.splitties:splitties-typesaferecyclerview:2.1.1\" implementation \"com.louiscad.splitties:splitties-views:2.1.1\" implementation \"com.louiscad.splitties:splitties-views-appcompat:2.1.1\" implementation \"com.louiscad.splitties:splitties-views-cardview:2.1.1\" implementation \"com.louiscad.splitties:splitties-views-design:2.1.1\" implementation \"com.louiscad.splitties:splitties-views-dsl:2.1.1\" implementation \"com.louiscad.splitties:splitties-views-dsl-appcompat:2.1.1\" implementation \"com.louiscad.splitties:splitties-views-dsl-constraintlayout:2.1.1\" implementation \"com.louiscad.splitties:splitties-views-dsl-design:2.1.1\" debugImplementation \"com.louiscad.splitties:splitties-views-dsl-ide-preview:2.1.1\" implementation \"com.louiscad.splitties:splitties-views-dsl-recyclerview:2.1.1\" implementation \"com.louiscad.splitties:splitties-views-recyclerview:2.1.1\" implementation \"com.louiscad.splitties:splitties-views-selectable:2.1.1\" implementation \"com.louiscad.splitties:splitties-views-selectable-appcompat:2.1.1\" implementation \"com.louiscad.splitties:splitties-views-selectable-constraintlayout:2.1.1\" Snapshots \u00b6 Let\u2019s say you need a new feature or a fix that did not make it to a release yet: You can grab it in the latest snapshot by adding the snapshots repository and changing the library version to the -SNAPSHOT version in your root project build.gradle file: allProjects { repositories { google () jcenter () // Add snapshots repo below maven { url 'https://oss.jfrog.org/artifactory/oss-snapshot-local' } } ext { splitties_version = '2.0.0-SNAPSHOT' // Change this line } } If you need to, you can browse the deployed snapshots on artifactory with the native browser or the web app so you can pick a specific snapshot. Other build systems \u00b6 For maven and alternative build-systems, check the Bintray page . New versions notifications \u00b6 To get notified for new versions, be sure to click on \u201cWatch\u201d on the splitties Bintray page . Improve this library \u00b6 If you want this library to have a new feature or an improvement in a new or in an existing module, please, open an issue or vote/comment a similar one first, so it can be discussed. Documentation contributions are also welcome. For typos or other small improvements, feel free to submit a PR (pull request) directly. For more significant doc contributions, please, open an issue first so it can be discussed. If you find a bug , please open an issue with all the important details. If you know a simple fix that is not API breaking and that does not have side-effects that need to be considered, you may also directly submit a PR. What is a split \u00b6 A \u201csplit\u201d is a module of the Splitties library that you can add as a dependency. It only includes the required transitive dependencies. This allows you to only add what you need in your app or library module, so the final apk is as small as possible and doesn\u2019t include stuff not used by your app. Let\u2019s say you\u2019re build an Android Wear app using the Views DSL. Android Wear apps don\u2019t need AppCompat. Including it would be a waste of bandwidth and storage. The Views DSL core module relies on the Android SDK but not on AppCompat, so you don\u2019t bloat your wrist app with AppCompat by using Views DSL. However, if you are building a phone, tablet or computer Android app, there\u2019s a Views DSL AppCompat split with a few extensions for you to use. License \u00b6 This library is published under Apache License version 2.0 which you can see here .","title":"Overview"},{"location":"2/#splitties","text":"Splitties is a collection of small independent Android libraries that aims to make developing apps and libraries for Android (including Wear, TV, Things, Auto and ChromeOS targeted) easier and more fun . Some modules are similar to what Anko provides. This project is named \u201cSplitties\u201d because it is split in small modules, distributed as independent Android libraries, so you can add only the ones you need to your project/module, helping reduce the size of the final apk. Each module has been designed to have a small footprint and be as efficient as possible.","title":"Splitties"},{"location":"2/#all-the-splits","text":"Activities: Start activities with minimal boilerplate. Alert Dialog: Create simple alert dialogs with simple code. Alert Dialog AppCompat: AppCompat version of Alert Dialog . App Context: Always have your application Context at hand with appCtx . Arch Lifecycle: Extensions to get ViewModel s, use LiveData and observe Lifecycle s. Arch Room: Room helpers to instantiate your DB and perform transactions in Kotlin. Bit Flags: hasFlag , withFlag and minusFlag extensions on Long , Int , Short and Byte . Bundle: BundleSpec to use Bundle with property syntax for Intent extras and more. Collections: forEach for List s without Iterator allocation. Checked Lazy: mainThreadLazy that checks property access on main thread, and checkedLazy to make your own variant. Dimensions: Android dp extensions for View and Context . Particularly handy when using Views DSL . Exceptions: illegal(\u2026) and similar functions that return Nothing , handy for impossible or illegal when branches. Fragments: Start activities from fragments and do transactions with minimal boilerplate. Fragment Args: Fragment arguments without ceremony thanks to delegated properties. Init Provider: Base class for ContentProvider s used for automatic initialization purposes. Intents: Transform companion object s into powerful typesafe intent specs, and create PendingIntent s the clean and easy way. Main Handler: Top-level mainHandler property to stop allocating multiple Handler s for main Looper . Main Thread: Properties and precondition checkers related to Android main thread. Material Colors: 2014 Material Design color palettes as color resources. Material Lists: List item Views implementing Material Design guidelines (perfect for usage in a RecyclerView ). Preferences: Property syntax for Android\u2019s SharedPreferences. Resources: Extensions to get resources like strings, colors or drawables easily, with support for themed attributes. Selectable Views: Selectable Views with foreground property before API 23. Selectable Views AppCompat: Selectable Views for AppCompatTextView. Selectable Views ConstraintLayout: Selectable Views for ConstraintLayout. Snackbar: Grab a snack without ceremony with snack(\u2026) and longSnack(\u2026) . Stetho init: Have Stetho for your debug builds, without writing any code! System Services: No more context.getSystemService(NAME_OF_SERVICE) as NameOfManager . Toast: Show a toast by just calling toast(yourText) , and dodge API 25 BadTokenException . Typesafe RecyclerView: Typesafe ViewHolder and ItemViewHolder for easy basic usage of RecyclerView . Views: Extensions function and properties on View s. Views AppCompat: AppCompat extension of Views . Includes helpers for ImageView tinting, ActionBar and tooltip. Views CardView: CardView extension of Views . Provides a contentPadding property. Views Design: Design Support library extension of Views . Views DSL: Create UIs with readable Kotlin code. Views DSL AppCompat: AppCompat extension of Views DSL . Views DSL ConstraintLayout: ConstraintLayout extension of Views DSL . Views DSL Design: Design Support Library extension of Views DSL . Views DSL IDE preview: Preview Views DSL UIs in the IDE. Views DSL RecyclerView: RecyclerView extension of Views DSL . Views RecyclerView: RecyclerView extension of Views .","title":"All the splits"},{"location":"2/#download","text":"","title":"Download"},{"location":"2/#gradle-instructions","text":"Make sure you have jcenter() in the repositories defined in your project\u2019s (root) build.gradle file (default for new Android Studio projects). Add the version of the library to not repeat yourself if you use multiple artifacts, and make sure their versions are in sync by adding an ext property into your root project build.gradle file: allProjects { ext { splitties_version = '2.1.1' } } Here are all the artifacts of this library. Just use the ones you need. (Click to expand) implementation \"com.louiscad.splitties:splitties-activities:2.1.1\" implementation \"com.louiscad.splitties:splitties-alertdialog:2.1.1\" implementation \"com.louiscad.splitties:splitties-alertdialog-appcompat:2.1.1\" implementation \"com.louiscad.splitties:splitties-appctx:2.1.1\" implementation \"com.louiscad.splitties:splitties-arch-lifecycle:2.1.1\" implementation \"com.louiscad.splitties:splitties-arch-room:2.1.1\" implementation \"com.louiscad.splitties:splitties-bitflags:2.1.1\" implementation \"com.louiscad.splitties:splitties-bundle:2.1.1\" implementation \"com.louiscad.splitties:splitties-checkedlazy:2.1.1\" implementation \"com.louiscad.splitties:splitties-collections:2.1.1\" implementation \"com.louiscad.splitties:splitties-dimensions:2.1.1\" implementation \"com.louiscad.splitties:splitties-exceptions:2.1.1\" implementation \"com.louiscad.splitties:splitties-fragments:2.1.1\" implementation \"com.louiscad.splitties:splitties-fragmentargs:2.1.1\" implementation \"com.louiscad.splitties:splitties-initprovider:2.1.1\" implementation \"com.louiscad.splitties:splitties-intents:2.1.1\" implementation \"com.louiscad.splitties:splitties-mainhandler:2.1.1\" implementation \"com.louiscad.splitties:splitties-mainthread:2.1.1\" implementation \"com.louiscad.splitties:splitties-material-colors:2.1.1\" implementation \"com.louiscad.splitties:splitties-material-lists:2.1.1\" implementation \"com.louiscad.splitties:splitties-preferences:2.1.1\" implementation \"com.louiscad.splitties:splitties-resources:2.1.1\" implementation \"com.louiscad.splitties:splitties-snackbar:2.1.1\" debugImplementation \"com.louiscad.splitties:splitties-stetho-init:2.1.1\" implementation \"com.louiscad.splitties:splitties-systemservices:2.1.1\" implementation \"com.louiscad.splitties:splitties-toast:2.1.1\" implementation \"com.louiscad.splitties:splitties-typesaferecyclerview:2.1.1\" implementation \"com.louiscad.splitties:splitties-views:2.1.1\" implementation \"com.louiscad.splitties:splitties-views-appcompat:2.1.1\" implementation \"com.louiscad.splitties:splitties-views-cardview:2.1.1\" implementation \"com.louiscad.splitties:splitties-views-design:2.1.1\" implementation \"com.louiscad.splitties:splitties-views-dsl:2.1.1\" implementation \"com.louiscad.splitties:splitties-views-dsl-appcompat:2.1.1\" implementation \"com.louiscad.splitties:splitties-views-dsl-constraintlayout:2.1.1\" implementation \"com.louiscad.splitties:splitties-views-dsl-design:2.1.1\" debugImplementation \"com.louiscad.splitties:splitties-views-dsl-ide-preview:2.1.1\" implementation \"com.louiscad.splitties:splitties-views-dsl-recyclerview:2.1.1\" implementation \"com.louiscad.splitties:splitties-views-recyclerview:2.1.1\" implementation \"com.louiscad.splitties:splitties-views-selectable:2.1.1\" implementation \"com.louiscad.splitties:splitties-views-selectable-appcompat:2.1.1\" implementation \"com.louiscad.splitties:splitties-views-selectable-constraintlayout:2.1.1\"","title":"Gradle instructions"},{"location":"2/#snapshots","text":"Let\u2019s say you need a new feature or a fix that did not make it to a release yet: You can grab it in the latest snapshot by adding the snapshots repository and changing the library version to the -SNAPSHOT version in your root project build.gradle file: allProjects { repositories { google () jcenter () // Add snapshots repo below maven { url 'https://oss.jfrog.org/artifactory/oss-snapshot-local' } } ext { splitties_version = '2.0.0-SNAPSHOT' // Change this line } } If you need to, you can browse the deployed snapshots on artifactory with the native browser or the web app so you can pick a specific snapshot.","title":"Snapshots"},{"location":"2/#other-build-systems","text":"For maven and alternative build-systems, check the Bintray page .","title":"Other build systems"},{"location":"2/#new-versions-notifications","text":"To get notified for new versions, be sure to click on \u201cWatch\u201d on the splitties Bintray page .","title":"New versions notifications"},{"location":"2/#improve-this-library","text":"If you want this library to have a new feature or an improvement in a new or in an existing module, please, open an issue or vote/comment a similar one first, so it can be discussed. Documentation contributions are also welcome. For typos or other small improvements, feel free to submit a PR (pull request) directly. For more significant doc contributions, please, open an issue first so it can be discussed. If you find a bug , please open an issue with all the important details. If you know a simple fix that is not API breaking and that does not have side-effects that need to be considered, you may also directly submit a PR.","title":"Improve this library"},{"location":"2/#what-is-a-split","text":"A \u201csplit\u201d is a module of the Splitties library that you can add as a dependency. It only includes the required transitive dependencies. This allows you to only add what you need in your app or library module, so the final apk is as small as possible and doesn\u2019t include stuff not used by your app. Let\u2019s say you\u2019re build an Android Wear app using the Views DSL. Android Wear apps don\u2019t need AppCompat. Including it would be a waste of bandwidth and storage. The Views DSL core module relies on the Android SDK but not on AppCompat, so you don\u2019t bloat your wrist app with AppCompat by using Views DSL. However, if you are building a phone, tablet or computer Android app, there\u2019s a Views DSL AppCompat split with a few extensions for you to use.","title":"What is a split"},{"location":"2/#license","text":"This library is published under Apache License version 2.0 which you can see here .","title":"License"},{"location":"2/CHANGELOG/","text":"Change log for Splitties \u00b6 Version 2.1.1 (2018-11-25) \u00b6 This release is compiled with Kotlin 1.3.10. Changes \u00b6 Enforce read-only in the withExtras extension function for Activity . Any attempt to mutate a property inside it will result in an IllegalStateException to be thrown, because this should be done in putExtras instead. You can see more info in the updated KDoc of these functions. Add a withExtras extension function for Intent (previously only available for Activity ). Add a putExtras extension function for Activity (previously only available for Intent ). Fix nullability warning in FragmentArgDelegate. Add KDoc to all public symbols from the Activities split. Add KDoc to all public symbols from the AlertDialog split. Add KDoc to all public symbols from the AlertDialog AppCompat split. Version 2.1.0 (2018-11-13) \u00b6 This release targets Android SDK 28, and splits depending on support libraries use version 28.0.0. Changes \u00b6 System Services from API 28 are now included into the same named split. Update ConfigChangesHandlingCollapsingToolbarLayout from View DSL Design to be compatible with design support library version 28.0.0. Update for nullability warnings brought by SDK 28. Version 2.0.0 (2018-11-13) \u00b6 This release targets Android SDK 27, and splits depending on support libraries use version 27.1.1. Changes \u00b6 Room updated to version 1.1.1 in Arch Room. Lambdas of onCreate and onOpen functions in Arch Room are now crossinline . The LifecycleObserver class is now marked as experimental. Version 2.0.0-beta1 (2018-11-13) \u00b6 This release breaks binary and source compatibility . Kotlin 1.3.0 \u00b6 This is not just a compiler update for Splitties. This release already takes advantage of Kotlin 1.3 features, beyond stable coroutines: The XmlStyle class from Views DSL is now inline, for minimal footprint at runtime. SuspendPrefsAccessor from Preferences is no longer experimental as coroutines graduated. Functions that take a lambda in Views DSL (except lParams functions) have a contract. This directly translates to more freedom in your UI code as you can initialize a property later. withExtras , putExtras and with from Bundle have a contract. This allows to initialize local variables from contents of a Bundle passing through a BundleSpec naturally! Symbols that could change are marked as experimental, for less surprises in the future when they are replaced, renamed or removed (still with a deprecation cycle whenever possible). Only verticalListLayoutParams and horizontalListLayoutParams extension functions for RecyclerView.LayoutManager are experimental for now, but this could change, especially in alpha, or beta stage. Version 2.0.0-alpha9 (2018-11-13) \u00b6 This release breaks binary and source compatibility . It renames several package names and modules, for more consistency across the project. View DSL has a new name: Views DSL. That also applies to its additional modules. Just like an extra s can make a new generation of smartphones, it can also make a new version of Splitties. The artifact names of all Selectable Views and View DSL changed, and so did the package names. Consequently, after updating the artifact names and the version, you\u2019ll need to update the imports. Fortunately, this is easily done with the \u201cReplace in Path\u201d IDE option present in IntelliJ IDEA and Android Studio. All you need to do is find an old import ( import splitties.viewdsl. ), select it, select the \u201cReplace in Path\u201d option paste ( import splitties.views.dsl. ) in the second input field, and validate. Then, you just have to the same for Selectable Views with import splitties.selectableviews. and import splitties.views.selectable. \u2026 and voil\u00e0! You just migrated to latest Splitties version! New artifacts \u00b6 Here are all the artifacts added in this version. Just use the ones you need. (Click to expand) implementation \"com.louiscad.splitties:splitties-views-dsl:2.1.1\" implementation \"com.louiscad.splitties:splitties-views-dsl-appcompat:2.1.1\" implementation \"com.louiscad.splitties:splitties-views-dsl-constraintlayout:2.1.1\" implementation \"com.louiscad.splitties:splitties-views-dsl-design:2.1.1\" debugImplementation \"com.louiscad.splitties:splitties-views-dsl-ide-preview:2.1.1\" implementation \"com.louiscad.splitties:splitties-views-dsl-recyclerview:2.1.1\" implementation \"com.louiscad.splitties:splitties-views-selectable:2.1.1\" implementation \"com.louiscad.splitties:splitties-views-selectable-appcompat:2.1.1\" implementation \"com.louiscad.splitties:splitties-views-selectable-constraintlayout:2.1.1\" All the lines above assume you defined the `splitties_version` ext property in your root project's `build.gradle` file to `2.0.0-alpha9` as shown in this snippet: allProjects { ext { splitties_version = '2.0.0-alpha9' } } Removed artifacts \u00b6 This release removes all these artifacts: implementation \"com.louiscad.splitties:splitties-selectableviews:2.1.1\" implementation \"com.louiscad.splitties:splitties-selectableviews-appcompat:2.1.1\" implementation \"com.louiscad.splitties:splitties-selectableviews-constraintlayout:2.1.1\" implementation \"com.louiscad.splitties:splitties-viewdsl:2.1.1\" implementation \"com.louiscad.splitties:splitties-viewdsl-appcompat:2.1.1\" implementation \"com.louiscad.splitties:splitties-viewdsl-constraintlayout:2.1.1\" implementation \"com.louiscad.splitties:splitties-viewdsl-design:2.1.1\" debugImplementation \"com.louiscad.splitties:splitties-viewdsl-ide-preview:2.1.1\" implementation \"com.louiscad.splitties:splitties-viewdsl-recyclerview:2.1.1\" Version 2.0.0-alpha8 (2018-11-12) \u00b6 This release breaks binary compatibility . It removes all deprecated symbols that had their deprecation level raised to error in 2.0.0-alpha7. Make sure you don\u2019t rely on any library that uses an old version of a Splitties artifact that relies on these previously deprecated and now removed symbols, or your app is likely not build, or to crash at runtime because of not found classes. Version 2.0.0-alpha7 (2018-11-12) \u00b6 Raise all deprecated symbols deprecation level to error. Use this version to make sure you don\u2019t use them in your projects, next version will remove them! Version 2.0.0-alpha6 (2018-11-11) \u00b6 Version 2.0.0-alpha5 broke the API, this version fixes this. Like version 2.0.0-alpha5, but without breaking the API from 2.0.0-alpha4 \u00b6 This release is mostly the same as 2.0.0-alpha5, but also has 2 very important things: - binary compatibility (minor change in Preferences experimental API excluded) - source compatibility, except an overload resolution ambiguity in View DSL, see the migration guide for a smooth migration. Removed splits and versions sync \u00b6 Version 2.0.0-alpha5 technically removed 2 splits (one was actually a renaming, the other one a merging). Consequently, you have to make sure your dependencies no longer reference these removed artifacts. Easily done. Problems arise when you depend on libraries that themselves depend on Splitties, which may be older versions. These libraries may bring transitive dependencies to old modules that will clash with ones from newer versions, and the versions they rely on may also mismatch with the ones you need, and these older versions will take precedence if they are in library modules of your project that don\u2019t depend explicitly on a newer version. Fortunately, Gradle dependency resolution strategy allows to easily fix these issues all over your project. All you need to do is to make sure you have the following snippet into your root project\u2019s build.gradle file: allprojects { ext { splitties_version = '2.0.0-alpha6' } configurations . all { resolutionStrategy . eachDependency { DependencyResolveDetails details -> def req = details . requested if ( req . group != \"com.louiscad.splitties\" ) return if ( req . name == \"splitties-uithread\" ) { details . useTarget ( group: req . group , name: \"splitties-mainthread\" , version: splitties_version ) details . because ( \"Splitties uithread has been renamed to mainthread\" ) } else if ( req . name == \"splitties-viewdsl-appcompat-styles\" ) { details . useTarget ( group: req . group , name: \"splitties-viewdsl-appcompat\" , version: splitties_version ) details . because ( \"[Splitties] Split merged and removed\" ) } else { details . useTarget ( group: req . group , name: req . name , version: splitties_version ) details . because ( \"Transitive dependencies could take precedence otherwise\" ) } } } } The snippet above, for all sub-projects (aka. modules): 1. defines Splitties version in an ext property so it can be used in all build.gradle files. 2. sets a resolution strategy for all configurations (like implementation or api ) which: 1. redirects any usage of the old splitties-mainthread artifact to the new splitties-mainthread one. 2. redirects any usage of the old splitties-viewdsl-appcompat-styles artifact to the one it has been merged into: splitties-viewdsl-appcompat . 3. makes sure all splitties artifacts versions are in sync, across all sub-projects. If you don\u2019t do this but have a library using an old artifact in your dependencies, you\u2019ll encounter gradle sync issues, or runtime issues, and the real cause may not appear clearly (because of bugs in tooling). Changes per module \u00b6 Checked Lazy \u00b6 uiLazy has been deprecated in favor of mainThreadLazy . View DSL RecyclerView \u00b6 The wrapInRecyclerView extension function now accepts an optional lambda to configure the wrapping RecyclerView easily. Version 2.0.0-alpha5 (2018-11-02) \u00b6 This release is breaking if you come from version 2.0.0-alpha4, especially if you were using View DSL. It\u2019s highly recommended to directly migrate from version 2.0.0-alpha4 to 2.0.0-alpha6, which has a smoother migration path, and a guide to do so. Project wide changes \u00b6 Add consumer proguard rules for splits with optional dependencies. Update to Kotlin 1.2.71 Update kotlinx.coroutines to version 0.30.2 Changes per module \u00b6 Collections \u00b6 Add allocation-free reverse List forEach extensions: forEachReversedByIndex and forEachReversedWithIndex . Intents \u00b6 Add toPendingActivities() extension function for Array<Intent> . Material Lists \u00b6 The following previously deprecated classes have been removed: SingleLineIconListItem (use IconOneLineListItem instead) TwoLinesIconListItem (use IconTwoLinesListItem instead) TwoLinesIconSwitchListItem (use IconTwoLinesSwitchListItem instead) All the xml files (except view_ids.xml ) have been removed. Preferences \u00b6 Enhancements \u00b6 The preferences are now loaded in Dispatchers.IO when using SuspendPrefsAccessor . Fix clash with private property name and non imported extension for Preferences. (#96). Breaking changes (in experimental API) \u00b6 The SuspendPrefsAccessor constructor parameter of type CoroutineDispatcher has been removed now that Dispatchers.IO is always used. If you didn\u2019t specify a custom dispatcher, you don\u2019t need to do anything. Selectable Views (all variants) \u00b6 All the final methods have been opened up, and now have the @CallSuper annotation instead. This makes the classes more useful to develop custom views, like the extended Floating Action Button with SelectableConstraintLayout where you need to clip the view in onDraw(\u2026) . The dispatchDrawableHotspotChanged overridden method in the classes of the Selectable Views splits family was annotated with @TargetApi , but is not correctly annotated with @RequiresApi . This likely caused no issue as you usually don\u2019t call this method directly but let Android do, but now, it\u2019s fixed! ~UI Thread~ -> Main Thread \u00b6 The UI Thread split has been renamed to Main thread (for the same reasons kotlinx.coroutines replaced UI by Dispatchers.Main ). While the artifact has been changed , the old symbols have only been deprecated in favor of new ones defined in new package, with new names ( ui -> main ). If you use a library that depends on the old artifact, see \u201cRemoved splits and versions sync\u201d in version 2.0.0-alpha6 release notes. View DSL (and additional modules) \u00b6 The API of View DSL (and its additional modules) has been improved, and there\u2019s some new features, along with some deprecations. However, this release (2.0.0-alpha5) is breaking when updating from previous versions. This has been fixed in 2.0.0-alpha6, so please skip this release if you are upgrading , and follow thoroughly the migration guide . Regardless, there has been improvements in View DSL additional modules. Please, review them below. ~View DSL AppCompat Styles~ -> View DSL AppCompat \u00b6 The View DSL AppCompat Styles split has been merged into View DSL AppCompat. If you use a library that depends on the old artifact, see \u201cRemoved splits and versions sync\u201d in version 2.0.0-alpha6 release notes. View DSL ConstraintLayout \u00b6 Probably the best change in this split is that now, you no longer need to specify any View id. If there\u2019s none and you add a constraint using extension functions from this split, an id that can\u2019t clash with aapt/xml ids will be generated and assigned to the view so constraints work. Keep in mind you may still want to use stable ids defined in xml or elsewhere in cases where you use views that need to have their state saved, like a RecyclerView , an EditText or a CheckBox . Added support for chains with the two horizontalChain and verticalChain new extension functions for ConstraintLayout . Also added horizontalMargin and verticalMargin extension properties for List<View> that are designed for use in a ConstraintLayout when you made a chain with the two new methods that take a list of views. View DSL Design \u00b6 When instantiating an AppBarLayout or a CollapsingToolbarLayout with the new appBarLayout and collapsingToolbarLayout functions, you\u2019ll automatically get instances that have known bugs in the design support library fixed, including config changes handling (supports rotation or layout changes without recreating the Activity). View DSL RecyclerView \u00b6 The setSingleView extension function for RecyclerView has been deprecated. Use the wrapInRecyclerView extension function for View instead, it is simpler to use and supports horizontal scrolling. Views \u00b6 Deprecated View visibility extension properties and functions in favor of Android KTX ones. Added lines write only extension property for TextView . Change the signature of the lambda of the onClick extension function for View . It no longer passes the clicked view . This is to avoid it shadowing when you nest lambdas, and has been done because this parameter is almost never used. Add 1 extension function, 1 extension property and 1 top level function, related to View id generation: View.assignAndGetGeneratedId() , View.existingOrNewId and generateViewId() . Upcoming APIs preview in the sample \u00b6 The sample of Splitties is a place where you can preview several extensions or other work that can be integrated into Splitties as a library later. In addition to what was already present in the sample, there has been an important addition: An example of how to request a dangerous permission with a single suspend call, plus a try/catch to handle user deny. New artifact \u00b6 This release has a new artifact: implementation \"com.louiscad.splitties:splitties-mainthread:2.1.1\" Removed artifacts \u00b6 This release removes these two artifacts: implementation \"com.louiscad.splitties:splitties-uithread:2.1.1\" implementation \"com.louiscad.splitties:splitties-viewdsl-appcompat-styles:2.1.1\" Version 2.0.0-alpha4 (2018-07-09) \u00b6 Provide ReplaceWith migrations for add methods deprecated in version 2.0.0-alpha2. Add default empty lambda for startActivity(action: String\u2026) methods. Compiled with Kotlin 1.2.51 Version 2.0.0-alpha3 (2018-06-09) \u00b6 New features \u00b6 Bundle \u00b6 There are 2 new methods: bundleOrDefault(\u2026) and bundleOrElse { \u2026 } to allow default values in BundleSpec delegated properties. Fragment Args \u00b6 Like for BundleSpec , there are 2 new methods: argOrDefault(\u2026) and argOrElse { \u2026 } to allow default values in Fragment delegated argument properties. Breaking changes \u00b6 Bundle \u00b6 The delegates previously returned by bundle() and bundleOrNull() are no longer part of the public API and have been replaced by the ReadWriteProperty interface. Fragment Args \u00b6 The arg() and argOrNull() functions have moved out of the support subpackage as there\u2019s no longer any ambiguity since platform Fragments are deprecated and going away. Auto-import should import the versions from the new package for you. The delegates previously returned by arg() and argOrNull() are no longer part of the public API and have been replaced by the ReadWriteProperty interface. Version 2.0.0-alpha2 (2018-05-21) \u00b6 9 new library modules (amounting to a total of 42 splits): \u00b6 Activities : Start activities with minimal boilerplate Collections : forEach for List s without Iterator allocation Fragments : Start activities from fragments and do transactions with minimal boilerplate Intents : Transform companion object s into powerful typesafe intent specs Material Colors : 2014 Material Design color palettes as color resources View DSL RecyclerView : RecyclerView extension of View DSL Views CardView : CardView extension of Views. Provides a contentPadding property View Design : Design Support library extension of Views Views RecyclerView : RecyclerView extension of Views Other changes: \u00b6 AppCtx \u00b6 The consume { \u2026 } utility function from the splitties.init package has been deprecated. Replace it with true.also { _ -> \u2026 } or false.also { _ -> \u2026 } . Arch Lifecycle \u00b6 New mapNotNull , switchMap and switchMapNotNull extension functions for LiveData . activityScope and fragmentScope extension functions to get a ViewModel now accept an optional lambda (which creates a ViewModelProvider under the hood. This allows to pass arguments to your ViewModel when it\u2019s first created. observe and observeNotNull now return the created Observer so it can be unregistered manually later if needed. Arch Room \u00b6 The new inTransaction { \u2026 } extension function for RoomDatabase s does the same as transaction { \u2026 } but also returns the value of the last expression of the lambda. New onCreate { \u2026 } and onOpen { \u2026 } extension functions for RoomDatabase.Builder . Bundle \u00b6 BundleHelper has been renamed to BundleSpec , but a typealias keeps the source compatibility. However, there\u2019s no binary compatibility, which means you\u2019ll need to recompile any library using it. BundleSpec and the methods relying on it can now be used safely on any thread! Material Lists \u00b6 Allow disabling default icon tint on list items with optional constructor parameter. Preferences \u00b6 A new experimental SuspendPrefsAccessor for coroutines users allows you to ensure you can\u2019t load the preferences (which does I/O) on the UI thread. Resources \u00b6 The str extension functions formatArgs now accept null arguments. View DSL \u00b6 The higher order function add has been deprecated because it went in the way of promoting a view to a property easily. View DSL AppCompat styles \u00b6 Added flatButton , imgActionButton and largeProgressBar . View DSL ConstraintLayout \u00b6 Add baselineToBaselineOf(\u2026) extension function for ConstraintLayout.LayoutParams . View DSL IDE Preview \u00b6 UiPreView injects a valid value into appCtx so your Ui s can depend on it (probably indirectly) without breaking preview! Views \u00b6 New Gravity flags aliases (e.g. gravityStartCenter instead of Gravity.START or Gravity.CENTER_VERTICAL ). Change case of imageBitMap to imageBitmap to make it more consistent with the class name Bitmap Views AppCompat \u00b6 tooltipTxt now accepts null to remove any tooltip previously set on the view. New artifacts \u00b6 Here are all the artifacts added in this version. Just use the ones you need. (Click to expand) implementation \"com.louiscad.splitties:splitties-activities:2.1.1\" implementation \"com.louiscad.splitties:splitties-collections:2.1.1\" implementation \"com.louiscad.splitties:splitties-fragments:2.1.1\" implementation \"com.louiscad.splitties:splitties-intents:2.1.1\" implementation \"com.louiscad.splitties:splitties-material-colors:2.1.1\" implementation \"com.louiscad.splitties:splitties-viewdsl-recyclerview:2.1.1\" implementation \"com.louiscad.splitties:splitties-views-cardview:2.1.1\" implementation \"com.louiscad.splitties:splitties-views-design:2.1.1\" implementation \"com.louiscad.splitties:splitties-views-recyclerview:2.1.1\" All the lines above assume you defined the `splitties_version` ext property in your root project's `build.gradle` file to `2.0.0-alpha2` as shown in this snippet: allProjects { ext { splitties_version = '2.0.0-alpha2' } } Version 2.0.0-alpha1 (2018-03-11) \u00b6 26 new library modules (amounting to a total of 33 splits): \u00b6 Alert Dialog : Create simple alert dialogs with simple code Alert Dialog AppCompat : AppCompat version of Alert Dialog Arch Lifecycle : Extensions to get ViewModel s, use LiveData and observe Lifecycle s Arch Room : Room helpers to instantiate your DB and perform transactions in Kotlin Bit Flags : hasFlag , withFlag and minusFlag extensions on Long , Int , Short and Byte Bundle : BundleHelper to use Bundle with property syntax for Intent extras and more Dimensions : Android dp extensions for View and Context . Particularly handy when using View DSL Exceptions : illegal(\u2026) and similar functions that return Nothing , handy for impossible or illegal when branches Fragment Args : Fragment arguments without ceremony thanks to delegated properties Init Provider : Base class for ContentProvider s used for automatic initialization purposes Main Handler : Top-level mainHandler property to stop allocating multiple Handler s for main Looper Resources : Extensions to get resources like strings, colors or drawables easily, with support for themed attributes Selectable Views AppCompat : Selectable Views for AppCompatTextView Selectable Views ConstraintLayout : Selectable Views for ConstraintLayout Snackbar : Grab a snack without ceremony with snack(\u2026) and longSnack(\u2026) System Services : No more context.getSystemService(NAME_OF_SERVICE) as NameOfManager Toast : Show a toast by just calling toast(yourText) , and dodge API 25 BadTokenException UI Thread : Properties related to Android UI thread, and checkUiThread() precondition checker View DSL : Create UIs with readable Kotlin code View DSL AppCompat : AppCompat extension of View DSL View DSL AppCompat styles : AppCompat styles for View DSL View DSL ConstraintLayout : ConstraintLayout extension of View DSL View DSL Design : Design Support Library extension of View DSL View DSL IDE preview : Preview View DSL UIs in the IDE Views : Extensions function and properties on View s Views AppCompat : AppCompat extension of Views. Includes helpers for ImageView tinting, ActionBar and tooltip 1 renamed module: \u00b6 \u201cChecked Lazy\u201d replaces the \u201cConcurrency\u201d module. Other changes: \u00b6 The groupId of the library changed from xyz.louiscad.splitties to com.louiscad.splitties . Check dependencies list below. All previous modules migrated to Kotlin, excepted the ViewHolder class from the Typesafe RecyclerView module that can\u2019t be written in Kotlin at the moment due to hiding super fields not being supported. App Context module has a new, memory leak safe injectAsAppCtx() method, that uses the new canLeakMemory() extension function on Context that is also public. Preferences StringPref and stringPref don\u2019t allow null values anymore. Use StringOrNullPref and stringOrNullPref if you need nullable strings. Same for StringSetPref and stringSetPref . The isUiThread property moved from the old \u201cConcurrency\u201d module to the \u201cUI Thread\u201d module. Material Lists are now written in Kotlin with View DSL, fixing icon tinting support on day/night themes and behavior on long texts. Also, the naming has been improved. Old named items are now deprecated. Checked Lazy does no longer depend on Timber but is now more configurable, allowing to write reporting behavior if needed. Selectable Views has been split in base module (that includes only dependencies on Android platform), AppCompat module and ConstraintLayout module. Selectable Views don\u2019t support the foreground xml attribute from app namespace anymore, but there\u2019s a new foregroundSelector property. New artifacts \u00b6 Here are all the artifacts added in this version. Just use the ones you need. (Click to expand) implementation \"com.louiscad.splitties:splitties-alertdialog:2.1.1\" implementation \"com.louiscad.splitties:splitties-alertdialog-appcompat:2.1.1\" implementation \"com.louiscad.splitties:splitties-appctx:2.1.1\" implementation \"com.louiscad.splitties:splitties-arch-lifecycle:2.1.1\" implementation \"com.louiscad.splitties:splitties-arch-room:2.1.1\" implementation \"com.louiscad.splitties:splitties-bitflags:2.1.1\" implementation \"com.louiscad.splitties:splitties-bundle:2.1.1\" implementation \"com.louiscad.splitties:splitties-checkedlazy:2.1.1\" implementation \"com.louiscad.splitties:splitties-dimensions:2.1.1\" implementation \"com.louiscad.splitties:splitties-exceptions:2.1.1\" implementation \"com.louiscad.splitties:splitties-initprovider:2.1.1\" implementation \"com.louiscad.splitties:splitties-mainhandler:2.1.1\" implementation \"com.louiscad.splitties:splitties-material-lists:2.1.1\" implementation \"com.louiscad.splitties:splitties-preferences:2.1.1\" implementation \"com.louiscad.splitties:splitties-resources:2.1.1\" implementation \"com.louiscad.splitties:splitties-fragmentargs:2.1.1\" implementation \"com.louiscad.splitties:splitties-selectableviews:2.1.1\" implementation \"com.louiscad.splitties:splitties-selectableviews-appcompat:2.1.1\" implementation \"com.louiscad.splitties:splitties-selectableviews-constraintlayout:2.1.1\" debugImplementation \"com.louiscad.splitties:splitties-stetho-init:2.1.1\" implementation \"com.louiscad.splitties:splitties-systemservices:2.1.1\" implementation \"com.louiscad.splitties:splitties-toast:2.1.1\" implementation \"com.louiscad.splitties:splitties-typesaferecyclerview:2.1.1\" implementation \"com.louiscad.splitties:splitties-uithread:2.1.1\" implementation \"com.louiscad.splitties:splitties-snackbar:2.1.1\" implementation \"com.louiscad.splitties:splitties-viewdsl:2.1.1\" implementation \"com.louiscad.splitties:splitties-viewdsl-appcompat:2.1.1\" implementation \"com.louiscad.splitties:splitties-viewdsl-appcompat-styles:2.1.1\" implementation \"com.louiscad.splitties:splitties-viewdsl-constraintlayout:2.1.1\" implementation \"com.louiscad.splitties:splitties-viewdsl-design:2.1.1\" debugImplementation \"com.louiscad.splitties:splitties-viewdsl-ide-preview:2.1.1\" implementation \"com.louiscad.splitties:splitties-views:2.1.1\" implementation \"com.louiscad.splitties:splitties-views-appcompat:2.1.1\" All the lines above assume you defined the `splitties_version` ext property in your root project's `build.gradle` file to `2.0.0-alpha1` as show in this snippet: allProjects { ext { splitties_version = '2.0.0-alpha1' } } Version 1.3.0 (2017-04-17) \u00b6 5 new library modules: \u00b6 App Context : Have a Context everywhere Concurrency : Single thread lazy implementations, with reporting via Timber support Material Lists : List Items for RecyclerView implementing Material Design Guidelines Preferences : Property syntax for Android\u2019s SharedPreferences Stetho init : Have Stetho without writing any code! 1 renamed module: \u00b6 Selectable Views replaces Selectable ViewGroups Other changes: \u00b6 Selectable Views now has a SelectableTextView . Made to use it on simple, single-line list items. Typesafe RecyclerView now depends on Kotlin Typesafe RecyclerView has a new ItemViewHolder helper class for simple but common use cases. Version 1.2 (2016-09-19) \u00b6 This version adds the setHost(Host host) method in ViewWrapper.Binder interface where Host can be any type you want you can use from the implementing item View to communicate with your Activity, Fragment, Presenter, or whatever. Note this adds a third type parameter to the ViewWrapper class, and a second one for the ViewWrapper.Binder class. Version 1.1 (2016-09-11) \u00b6 This version adds the setViewHolder(ViewWrapper holder) method in ViewWrapper.Binder interface so list item View s can now get a reference to their ViewHolder , and call getAdapterPosition() on it for example. Version 1.0 (2016-08-24) \u00b6 This is the first release of Splitties. It includes two independent modules: - Typesafe RecyclerView - Selectable ViewGroups For gradle projects from jcenter() repo: compile 'xyz.louiscad.splitties:selectableviewgroups:1.0' compile 'xyz.louiscad.splitties:typesaferecyclerview:1.0'","title":"CHANGELOG"},{"location":"2/CHANGELOG/#change-log-for-splitties","text":"","title":"Change log for Splitties"},{"location":"2/CHANGELOG/#version-211-2018-11-25","text":"This release is compiled with Kotlin 1.3.10.","title":"Version 2.1.1 (2018-11-25)"},{"location":"2/CHANGELOG/#changes","text":"Enforce read-only in the withExtras extension function for Activity . Any attempt to mutate a property inside it will result in an IllegalStateException to be thrown, because this should be done in putExtras instead. You can see more info in the updated KDoc of these functions. Add a withExtras extension function for Intent (previously only available for Activity ). Add a putExtras extension function for Activity (previously only available for Intent ). Fix nullability warning in FragmentArgDelegate. Add KDoc to all public symbols from the Activities split. Add KDoc to all public symbols from the AlertDialog split. Add KDoc to all public symbols from the AlertDialog AppCompat split.","title":"Changes"},{"location":"2/CHANGELOG/#version-210-2018-11-13","text":"This release targets Android SDK 28, and splits depending on support libraries use version 28.0.0.","title":"Version 2.1.0 (2018-11-13)"},{"location":"2/CHANGELOG/#changes_1","text":"System Services from API 28 are now included into the same named split. Update ConfigChangesHandlingCollapsingToolbarLayout from View DSL Design to be compatible with design support library version 28.0.0. Update for nullability warnings brought by SDK 28.","title":"Changes"},{"location":"2/CHANGELOG/#version-200-2018-11-13","text":"This release targets Android SDK 27, and splits depending on support libraries use version 27.1.1.","title":"Version 2.0.0 (2018-11-13)"},{"location":"2/CHANGELOG/#changes_2","text":"Room updated to version 1.1.1 in Arch Room. Lambdas of onCreate and onOpen functions in Arch Room are now crossinline . The LifecycleObserver class is now marked as experimental.","title":"Changes"},{"location":"2/CHANGELOG/#version-200-beta1-2018-11-13","text":"This release breaks binary and source compatibility .","title":"Version 2.0.0-beta1 (2018-11-13)"},{"location":"2/CHANGELOG/#kotlin-130","text":"This is not just a compiler update for Splitties. This release already takes advantage of Kotlin 1.3 features, beyond stable coroutines: The XmlStyle class from Views DSL is now inline, for minimal footprint at runtime. SuspendPrefsAccessor from Preferences is no longer experimental as coroutines graduated. Functions that take a lambda in Views DSL (except lParams functions) have a contract. This directly translates to more freedom in your UI code as you can initialize a property later. withExtras , putExtras and with from Bundle have a contract. This allows to initialize local variables from contents of a Bundle passing through a BundleSpec naturally! Symbols that could change are marked as experimental, for less surprises in the future when they are replaced, renamed or removed (still with a deprecation cycle whenever possible). Only verticalListLayoutParams and horizontalListLayoutParams extension functions for RecyclerView.LayoutManager are experimental for now, but this could change, especially in alpha, or beta stage.","title":"Kotlin 1.3.0"},{"location":"2/CHANGELOG/#version-200-alpha9-2018-11-13","text":"This release breaks binary and source compatibility . It renames several package names and modules, for more consistency across the project. View DSL has a new name: Views DSL. That also applies to its additional modules. Just like an extra s can make a new generation of smartphones, it can also make a new version of Splitties. The artifact names of all Selectable Views and View DSL changed, and so did the package names. Consequently, after updating the artifact names and the version, you\u2019ll need to update the imports. Fortunately, this is easily done with the \u201cReplace in Path\u201d IDE option present in IntelliJ IDEA and Android Studio. All you need to do is find an old import ( import splitties.viewdsl. ), select it, select the \u201cReplace in Path\u201d option paste ( import splitties.views.dsl. ) in the second input field, and validate. Then, you just have to the same for Selectable Views with import splitties.selectableviews. and import splitties.views.selectable. \u2026 and voil\u00e0! You just migrated to latest Splitties version!","title":"Version 2.0.0-alpha9 (2018-11-13)"},{"location":"2/CHANGELOG/#new-artifacts","text":"Here are all the artifacts added in this version. Just use the ones you need. (Click to expand) implementation \"com.louiscad.splitties:splitties-views-dsl:2.1.1\" implementation \"com.louiscad.splitties:splitties-views-dsl-appcompat:2.1.1\" implementation \"com.louiscad.splitties:splitties-views-dsl-constraintlayout:2.1.1\" implementation \"com.louiscad.splitties:splitties-views-dsl-design:2.1.1\" debugImplementation \"com.louiscad.splitties:splitties-views-dsl-ide-preview:2.1.1\" implementation \"com.louiscad.splitties:splitties-views-dsl-recyclerview:2.1.1\" implementation \"com.louiscad.splitties:splitties-views-selectable:2.1.1\" implementation \"com.louiscad.splitties:splitties-views-selectable-appcompat:2.1.1\" implementation \"com.louiscad.splitties:splitties-views-selectable-constraintlayout:2.1.1\" All the lines above assume you defined the `splitties_version` ext property in your root project's `build.gradle` file to `2.0.0-alpha9` as shown in this snippet: allProjects { ext { splitties_version = '2.0.0-alpha9' } }","title":"New artifacts"},{"location":"2/CHANGELOG/#removed-artifacts","text":"This release removes all these artifacts: implementation \"com.louiscad.splitties:splitties-selectableviews:2.1.1\" implementation \"com.louiscad.splitties:splitties-selectableviews-appcompat:2.1.1\" implementation \"com.louiscad.splitties:splitties-selectableviews-constraintlayout:2.1.1\" implementation \"com.louiscad.splitties:splitties-viewdsl:2.1.1\" implementation \"com.louiscad.splitties:splitties-viewdsl-appcompat:2.1.1\" implementation \"com.louiscad.splitties:splitties-viewdsl-constraintlayout:2.1.1\" implementation \"com.louiscad.splitties:splitties-viewdsl-design:2.1.1\" debugImplementation \"com.louiscad.splitties:splitties-viewdsl-ide-preview:2.1.1\" implementation \"com.louiscad.splitties:splitties-viewdsl-recyclerview:2.1.1\"","title":"Removed artifacts"},{"location":"2/CHANGELOG/#version-200-alpha8-2018-11-12","text":"This release breaks binary compatibility . It removes all deprecated symbols that had their deprecation level raised to error in 2.0.0-alpha7. Make sure you don\u2019t rely on any library that uses an old version of a Splitties artifact that relies on these previously deprecated and now removed symbols, or your app is likely not build, or to crash at runtime because of not found classes.","title":"Version 2.0.0-alpha8 (2018-11-12)"},{"location":"2/CHANGELOG/#version-200-alpha7-2018-11-12","text":"Raise all deprecated symbols deprecation level to error. Use this version to make sure you don\u2019t use them in your projects, next version will remove them!","title":"Version 2.0.0-alpha7 (2018-11-12)"},{"location":"2/CHANGELOG/#version-200-alpha6-2018-11-11","text":"Version 2.0.0-alpha5 broke the API, this version fixes this.","title":"Version 2.0.0-alpha6 (2018-11-11)"},{"location":"2/CHANGELOG/#like-version-200-alpha5-but-without-breaking-the-api-from-200-alpha4","text":"This release is mostly the same as 2.0.0-alpha5, but also has 2 very important things: - binary compatibility (minor change in Preferences experimental API excluded) - source compatibility, except an overload resolution ambiguity in View DSL, see the migration guide for a smooth migration.","title":"Like version 2.0.0-alpha5, but without breaking the API from 2.0.0-alpha4"},{"location":"2/CHANGELOG/#removed-splits-and-versions-sync","text":"Version 2.0.0-alpha5 technically removed 2 splits (one was actually a renaming, the other one a merging). Consequently, you have to make sure your dependencies no longer reference these removed artifacts. Easily done. Problems arise when you depend on libraries that themselves depend on Splitties, which may be older versions. These libraries may bring transitive dependencies to old modules that will clash with ones from newer versions, and the versions they rely on may also mismatch with the ones you need, and these older versions will take precedence if they are in library modules of your project that don\u2019t depend explicitly on a newer version. Fortunately, Gradle dependency resolution strategy allows to easily fix these issues all over your project. All you need to do is to make sure you have the following snippet into your root project\u2019s build.gradle file: allprojects { ext { splitties_version = '2.0.0-alpha6' } configurations . all { resolutionStrategy . eachDependency { DependencyResolveDetails details -> def req = details . requested if ( req . group != \"com.louiscad.splitties\" ) return if ( req . name == \"splitties-uithread\" ) { details . useTarget ( group: req . group , name: \"splitties-mainthread\" , version: splitties_version ) details . because ( \"Splitties uithread has been renamed to mainthread\" ) } else if ( req . name == \"splitties-viewdsl-appcompat-styles\" ) { details . useTarget ( group: req . group , name: \"splitties-viewdsl-appcompat\" , version: splitties_version ) details . because ( \"[Splitties] Split merged and removed\" ) } else { details . useTarget ( group: req . group , name: req . name , version: splitties_version ) details . because ( \"Transitive dependencies could take precedence otherwise\" ) } } } } The snippet above, for all sub-projects (aka. modules): 1. defines Splitties version in an ext property so it can be used in all build.gradle files. 2. sets a resolution strategy for all configurations (like implementation or api ) which: 1. redirects any usage of the old splitties-mainthread artifact to the new splitties-mainthread one. 2. redirects any usage of the old splitties-viewdsl-appcompat-styles artifact to the one it has been merged into: splitties-viewdsl-appcompat . 3. makes sure all splitties artifacts versions are in sync, across all sub-projects. If you don\u2019t do this but have a library using an old artifact in your dependencies, you\u2019ll encounter gradle sync issues, or runtime issues, and the real cause may not appear clearly (because of bugs in tooling).","title":"Removed splits and versions sync"},{"location":"2/CHANGELOG/#changes-per-module","text":"","title":"Changes per module"},{"location":"2/CHANGELOG/#checked-lazy","text":"uiLazy has been deprecated in favor of mainThreadLazy .","title":"Checked Lazy"},{"location":"2/CHANGELOG/#view-dsl-recyclerview","text":"The wrapInRecyclerView extension function now accepts an optional lambda to configure the wrapping RecyclerView easily.","title":"View DSL RecyclerView"},{"location":"2/CHANGELOG/#version-200-alpha5-2018-11-02","text":"This release is breaking if you come from version 2.0.0-alpha4, especially if you were using View DSL. It\u2019s highly recommended to directly migrate from version 2.0.0-alpha4 to 2.0.0-alpha6, which has a smoother migration path, and a guide to do so.","title":"Version 2.0.0-alpha5 (2018-11-02)"},{"location":"2/CHANGELOG/#project-wide-changes","text":"Add consumer proguard rules for splits with optional dependencies. Update to Kotlin 1.2.71 Update kotlinx.coroutines to version 0.30.2","title":"Project wide changes"},{"location":"2/CHANGELOG/#changes-per-module_1","text":"","title":"Changes per module"},{"location":"2/CHANGELOG/#collections","text":"Add allocation-free reverse List forEach extensions: forEachReversedByIndex and forEachReversedWithIndex .","title":"Collections"},{"location":"2/CHANGELOG/#intents","text":"Add toPendingActivities() extension function for Array<Intent> .","title":"Intents"},{"location":"2/CHANGELOG/#material-lists","text":"The following previously deprecated classes have been removed: SingleLineIconListItem (use IconOneLineListItem instead) TwoLinesIconListItem (use IconTwoLinesListItem instead) TwoLinesIconSwitchListItem (use IconTwoLinesSwitchListItem instead) All the xml files (except view_ids.xml ) have been removed.","title":"Material Lists"},{"location":"2/CHANGELOG/#preferences","text":"","title":"Preferences"},{"location":"2/CHANGELOG/#enhancements","text":"The preferences are now loaded in Dispatchers.IO when using SuspendPrefsAccessor . Fix clash with private property name and non imported extension for Preferences. (#96).","title":"Enhancements"},{"location":"2/CHANGELOG/#breaking-changes-in-experimental-api","text":"The SuspendPrefsAccessor constructor parameter of type CoroutineDispatcher has been removed now that Dispatchers.IO is always used. If you didn\u2019t specify a custom dispatcher, you don\u2019t need to do anything.","title":"Breaking changes (in experimental API)"},{"location":"2/CHANGELOG/#selectable-views-all-variants","text":"All the final methods have been opened up, and now have the @CallSuper annotation instead. This makes the classes more useful to develop custom views, like the extended Floating Action Button with SelectableConstraintLayout where you need to clip the view in onDraw(\u2026) . The dispatchDrawableHotspotChanged overridden method in the classes of the Selectable Views splits family was annotated with @TargetApi , but is not correctly annotated with @RequiresApi . This likely caused no issue as you usually don\u2019t call this method directly but let Android do, but now, it\u2019s fixed!","title":"Selectable Views (all variants)"},{"location":"2/CHANGELOG/#ui-thread-main-thread","text":"The UI Thread split has been renamed to Main thread (for the same reasons kotlinx.coroutines replaced UI by Dispatchers.Main ). While the artifact has been changed , the old symbols have only been deprecated in favor of new ones defined in new package, with new names ( ui -> main ). If you use a library that depends on the old artifact, see \u201cRemoved splits and versions sync\u201d in version 2.0.0-alpha6 release notes.","title":"~UI Thread~ -&gt; Main Thread"},{"location":"2/CHANGELOG/#view-dsl-and-additional-modules","text":"The API of View DSL (and its additional modules) has been improved, and there\u2019s some new features, along with some deprecations. However, this release (2.0.0-alpha5) is breaking when updating from previous versions. This has been fixed in 2.0.0-alpha6, so please skip this release if you are upgrading , and follow thoroughly the migration guide . Regardless, there has been improvements in View DSL additional modules. Please, review them below.","title":"View DSL (and additional modules)"},{"location":"2/CHANGELOG/#view-dsl-appcompat-styles-view-dsl-appcompat","text":"The View DSL AppCompat Styles split has been merged into View DSL AppCompat. If you use a library that depends on the old artifact, see \u201cRemoved splits and versions sync\u201d in version 2.0.0-alpha6 release notes.","title":"~View DSL AppCompat Styles~ -&gt; View DSL AppCompat"},{"location":"2/CHANGELOG/#view-dsl-constraintlayout","text":"Probably the best change in this split is that now, you no longer need to specify any View id. If there\u2019s none and you add a constraint using extension functions from this split, an id that can\u2019t clash with aapt/xml ids will be generated and assigned to the view so constraints work. Keep in mind you may still want to use stable ids defined in xml or elsewhere in cases where you use views that need to have their state saved, like a RecyclerView , an EditText or a CheckBox . Added support for chains with the two horizontalChain and verticalChain new extension functions for ConstraintLayout . Also added horizontalMargin and verticalMargin extension properties for List<View> that are designed for use in a ConstraintLayout when you made a chain with the two new methods that take a list of views.","title":"View DSL ConstraintLayout"},{"location":"2/CHANGELOG/#view-dsl-design","text":"When instantiating an AppBarLayout or a CollapsingToolbarLayout with the new appBarLayout and collapsingToolbarLayout functions, you\u2019ll automatically get instances that have known bugs in the design support library fixed, including config changes handling (supports rotation or layout changes without recreating the Activity).","title":"View DSL Design"},{"location":"2/CHANGELOG/#view-dsl-recyclerview_1","text":"The setSingleView extension function for RecyclerView has been deprecated. Use the wrapInRecyclerView extension function for View instead, it is simpler to use and supports horizontal scrolling.","title":"View DSL RecyclerView"},{"location":"2/CHANGELOG/#views","text":"Deprecated View visibility extension properties and functions in favor of Android KTX ones. Added lines write only extension property for TextView . Change the signature of the lambda of the onClick extension function for View . It no longer passes the clicked view . This is to avoid it shadowing when you nest lambdas, and has been done because this parameter is almost never used. Add 1 extension function, 1 extension property and 1 top level function, related to View id generation: View.assignAndGetGeneratedId() , View.existingOrNewId and generateViewId() .","title":"Views"},{"location":"2/CHANGELOG/#upcoming-apis-preview-in-the-sample","text":"The sample of Splitties is a place where you can preview several extensions or other work that can be integrated into Splitties as a library later. In addition to what was already present in the sample, there has been an important addition: An example of how to request a dangerous permission with a single suspend call, plus a try/catch to handle user deny.","title":"Upcoming APIs preview in the sample"},{"location":"2/CHANGELOG/#new-artifact","text":"This release has a new artifact: implementation \"com.louiscad.splitties:splitties-mainthread:2.1.1\"","title":"New artifact"},{"location":"2/CHANGELOG/#removed-artifacts_1","text":"This release removes these two artifacts: implementation \"com.louiscad.splitties:splitties-uithread:2.1.1\" implementation \"com.louiscad.splitties:splitties-viewdsl-appcompat-styles:2.1.1\"","title":"Removed artifacts"},{"location":"2/CHANGELOG/#version-200-alpha4-2018-07-09","text":"Provide ReplaceWith migrations for add methods deprecated in version 2.0.0-alpha2. Add default empty lambda for startActivity(action: String\u2026) methods. Compiled with Kotlin 1.2.51","title":"Version 2.0.0-alpha4 (2018-07-09)"},{"location":"2/CHANGELOG/#version-200-alpha3-2018-06-09","text":"","title":"Version 2.0.0-alpha3 (2018-06-09)"},{"location":"2/CHANGELOG/#new-features","text":"","title":"New features"},{"location":"2/CHANGELOG/#bundle","text":"There are 2 new methods: bundleOrDefault(\u2026) and bundleOrElse { \u2026 } to allow default values in BundleSpec delegated properties.","title":"Bundle"},{"location":"2/CHANGELOG/#fragment-args","text":"Like for BundleSpec , there are 2 new methods: argOrDefault(\u2026) and argOrElse { \u2026 } to allow default values in Fragment delegated argument properties.","title":"Fragment Args"},{"location":"2/CHANGELOG/#breaking-changes","text":"","title":"Breaking changes"},{"location":"2/CHANGELOG/#bundle_1","text":"The delegates previously returned by bundle() and bundleOrNull() are no longer part of the public API and have been replaced by the ReadWriteProperty interface.","title":"Bundle"},{"location":"2/CHANGELOG/#fragment-args_1","text":"The arg() and argOrNull() functions have moved out of the support subpackage as there\u2019s no longer any ambiguity since platform Fragments are deprecated and going away. Auto-import should import the versions from the new package for you. The delegates previously returned by arg() and argOrNull() are no longer part of the public API and have been replaced by the ReadWriteProperty interface.","title":"Fragment Args"},{"location":"2/CHANGELOG/#version-200-alpha2-2018-05-21","text":"","title":"Version 2.0.0-alpha2 (2018-05-21)"},{"location":"2/CHANGELOG/#9-new-library-modules-amounting-to-a-total-of-42-splits","text":"Activities : Start activities with minimal boilerplate Collections : forEach for List s without Iterator allocation Fragments : Start activities from fragments and do transactions with minimal boilerplate Intents : Transform companion object s into powerful typesafe intent specs Material Colors : 2014 Material Design color palettes as color resources View DSL RecyclerView : RecyclerView extension of View DSL Views CardView : CardView extension of Views. Provides a contentPadding property View Design : Design Support library extension of Views Views RecyclerView : RecyclerView extension of Views","title":"9 new library modules (amounting to a total of 42 splits):"},{"location":"2/CHANGELOG/#other-changes","text":"","title":"Other changes:"},{"location":"2/CHANGELOG/#appctx","text":"The consume { \u2026 } utility function from the splitties.init package has been deprecated. Replace it with true.also { _ -> \u2026 } or false.also { _ -> \u2026 } .","title":"AppCtx"},{"location":"2/CHANGELOG/#arch-lifecycle","text":"New mapNotNull , switchMap and switchMapNotNull extension functions for LiveData . activityScope and fragmentScope extension functions to get a ViewModel now accept an optional lambda (which creates a ViewModelProvider under the hood. This allows to pass arguments to your ViewModel when it\u2019s first created. observe and observeNotNull now return the created Observer so it can be unregistered manually later if needed.","title":"Arch Lifecycle"},{"location":"2/CHANGELOG/#arch-room","text":"The new inTransaction { \u2026 } extension function for RoomDatabase s does the same as transaction { \u2026 } but also returns the value of the last expression of the lambda. New onCreate { \u2026 } and onOpen { \u2026 } extension functions for RoomDatabase.Builder .","title":"Arch Room"},{"location":"2/CHANGELOG/#bundle_2","text":"BundleHelper has been renamed to BundleSpec , but a typealias keeps the source compatibility. However, there\u2019s no binary compatibility, which means you\u2019ll need to recompile any library using it. BundleSpec and the methods relying on it can now be used safely on any thread!","title":"Bundle"},{"location":"2/CHANGELOG/#material-lists_1","text":"Allow disabling default icon tint on list items with optional constructor parameter.","title":"Material Lists"},{"location":"2/CHANGELOG/#preferences_1","text":"A new experimental SuspendPrefsAccessor for coroutines users allows you to ensure you can\u2019t load the preferences (which does I/O) on the UI thread.","title":"Preferences"},{"location":"2/CHANGELOG/#resources","text":"The str extension functions formatArgs now accept null arguments.","title":"Resources"},{"location":"2/CHANGELOG/#view-dsl","text":"The higher order function add has been deprecated because it went in the way of promoting a view to a property easily.","title":"View DSL"},{"location":"2/CHANGELOG/#view-dsl-appcompat-styles","text":"Added flatButton , imgActionButton and largeProgressBar .","title":"View DSL AppCompat styles"},{"location":"2/CHANGELOG/#view-dsl-constraintlayout_1","text":"Add baselineToBaselineOf(\u2026) extension function for ConstraintLayout.LayoutParams .","title":"View DSL ConstraintLayout"},{"location":"2/CHANGELOG/#view-dsl-ide-preview","text":"UiPreView injects a valid value into appCtx so your Ui s can depend on it (probably indirectly) without breaking preview!","title":"View DSL IDE Preview"},{"location":"2/CHANGELOG/#views_1","text":"New Gravity flags aliases (e.g. gravityStartCenter instead of Gravity.START or Gravity.CENTER_VERTICAL ). Change case of imageBitMap to imageBitmap to make it more consistent with the class name Bitmap","title":"Views"},{"location":"2/CHANGELOG/#views-appcompat","text":"tooltipTxt now accepts null to remove any tooltip previously set on the view.","title":"Views AppCompat"},{"location":"2/CHANGELOG/#new-artifacts_1","text":"Here are all the artifacts added in this version. Just use the ones you need. (Click to expand) implementation \"com.louiscad.splitties:splitties-activities:2.1.1\" implementation \"com.louiscad.splitties:splitties-collections:2.1.1\" implementation \"com.louiscad.splitties:splitties-fragments:2.1.1\" implementation \"com.louiscad.splitties:splitties-intents:2.1.1\" implementation \"com.louiscad.splitties:splitties-material-colors:2.1.1\" implementation \"com.louiscad.splitties:splitties-viewdsl-recyclerview:2.1.1\" implementation \"com.louiscad.splitties:splitties-views-cardview:2.1.1\" implementation \"com.louiscad.splitties:splitties-views-design:2.1.1\" implementation \"com.louiscad.splitties:splitties-views-recyclerview:2.1.1\" All the lines above assume you defined the `splitties_version` ext property in your root project's `build.gradle` file to `2.0.0-alpha2` as shown in this snippet: allProjects { ext { splitties_version = '2.0.0-alpha2' } }","title":"New artifacts"},{"location":"2/CHANGELOG/#version-200-alpha1-2018-03-11","text":"","title":"Version 2.0.0-alpha1 (2018-03-11)"},{"location":"2/CHANGELOG/#26-new-library-modules-amounting-to-a-total-of-33-splits","text":"Alert Dialog : Create simple alert dialogs with simple code Alert Dialog AppCompat : AppCompat version of Alert Dialog Arch Lifecycle : Extensions to get ViewModel s, use LiveData and observe Lifecycle s Arch Room : Room helpers to instantiate your DB and perform transactions in Kotlin Bit Flags : hasFlag , withFlag and minusFlag extensions on Long , Int , Short and Byte Bundle : BundleHelper to use Bundle with property syntax for Intent extras and more Dimensions : Android dp extensions for View and Context . Particularly handy when using View DSL Exceptions : illegal(\u2026) and similar functions that return Nothing , handy for impossible or illegal when branches Fragment Args : Fragment arguments without ceremony thanks to delegated properties Init Provider : Base class for ContentProvider s used for automatic initialization purposes Main Handler : Top-level mainHandler property to stop allocating multiple Handler s for main Looper Resources : Extensions to get resources like strings, colors or drawables easily, with support for themed attributes Selectable Views AppCompat : Selectable Views for AppCompatTextView Selectable Views ConstraintLayout : Selectable Views for ConstraintLayout Snackbar : Grab a snack without ceremony with snack(\u2026) and longSnack(\u2026) System Services : No more context.getSystemService(NAME_OF_SERVICE) as NameOfManager Toast : Show a toast by just calling toast(yourText) , and dodge API 25 BadTokenException UI Thread : Properties related to Android UI thread, and checkUiThread() precondition checker View DSL : Create UIs with readable Kotlin code View DSL AppCompat : AppCompat extension of View DSL View DSL AppCompat styles : AppCompat styles for View DSL View DSL ConstraintLayout : ConstraintLayout extension of View DSL View DSL Design : Design Support Library extension of View DSL View DSL IDE preview : Preview View DSL UIs in the IDE Views : Extensions function and properties on View s Views AppCompat : AppCompat extension of Views. Includes helpers for ImageView tinting, ActionBar and tooltip","title":"26 new library modules (amounting to a total of 33 splits):"},{"location":"2/CHANGELOG/#1-renamed-module","text":"\u201cChecked Lazy\u201d replaces the \u201cConcurrency\u201d module.","title":"1 renamed module:"},{"location":"2/CHANGELOG/#other-changes_1","text":"The groupId of the library changed from xyz.louiscad.splitties to com.louiscad.splitties . Check dependencies list below. All previous modules migrated to Kotlin, excepted the ViewHolder class from the Typesafe RecyclerView module that can\u2019t be written in Kotlin at the moment due to hiding super fields not being supported. App Context module has a new, memory leak safe injectAsAppCtx() method, that uses the new canLeakMemory() extension function on Context that is also public. Preferences StringPref and stringPref don\u2019t allow null values anymore. Use StringOrNullPref and stringOrNullPref if you need nullable strings. Same for StringSetPref and stringSetPref . The isUiThread property moved from the old \u201cConcurrency\u201d module to the \u201cUI Thread\u201d module. Material Lists are now written in Kotlin with View DSL, fixing icon tinting support on day/night themes and behavior on long texts. Also, the naming has been improved. Old named items are now deprecated. Checked Lazy does no longer depend on Timber but is now more configurable, allowing to write reporting behavior if needed. Selectable Views has been split in base module (that includes only dependencies on Android platform), AppCompat module and ConstraintLayout module. Selectable Views don\u2019t support the foreground xml attribute from app namespace anymore, but there\u2019s a new foregroundSelector property.","title":"Other changes:"},{"location":"2/CHANGELOG/#new-artifacts_2","text":"Here are all the artifacts added in this version. Just use the ones you need. (Click to expand) implementation \"com.louiscad.splitties:splitties-alertdialog:2.1.1\" implementation \"com.louiscad.splitties:splitties-alertdialog-appcompat:2.1.1\" implementation \"com.louiscad.splitties:splitties-appctx:2.1.1\" implementation \"com.louiscad.splitties:splitties-arch-lifecycle:2.1.1\" implementation \"com.louiscad.splitties:splitties-arch-room:2.1.1\" implementation \"com.louiscad.splitties:splitties-bitflags:2.1.1\" implementation \"com.louiscad.splitties:splitties-bundle:2.1.1\" implementation \"com.louiscad.splitties:splitties-checkedlazy:2.1.1\" implementation \"com.louiscad.splitties:splitties-dimensions:2.1.1\" implementation \"com.louiscad.splitties:splitties-exceptions:2.1.1\" implementation \"com.louiscad.splitties:splitties-initprovider:2.1.1\" implementation \"com.louiscad.splitties:splitties-mainhandler:2.1.1\" implementation \"com.louiscad.splitties:splitties-material-lists:2.1.1\" implementation \"com.louiscad.splitties:splitties-preferences:2.1.1\" implementation \"com.louiscad.splitties:splitties-resources:2.1.1\" implementation \"com.louiscad.splitties:splitties-fragmentargs:2.1.1\" implementation \"com.louiscad.splitties:splitties-selectableviews:2.1.1\" implementation \"com.louiscad.splitties:splitties-selectableviews-appcompat:2.1.1\" implementation \"com.louiscad.splitties:splitties-selectableviews-constraintlayout:2.1.1\" debugImplementation \"com.louiscad.splitties:splitties-stetho-init:2.1.1\" implementation \"com.louiscad.splitties:splitties-systemservices:2.1.1\" implementation \"com.louiscad.splitties:splitties-toast:2.1.1\" implementation \"com.louiscad.splitties:splitties-typesaferecyclerview:2.1.1\" implementation \"com.louiscad.splitties:splitties-uithread:2.1.1\" implementation \"com.louiscad.splitties:splitties-snackbar:2.1.1\" implementation \"com.louiscad.splitties:splitties-viewdsl:2.1.1\" implementation \"com.louiscad.splitties:splitties-viewdsl-appcompat:2.1.1\" implementation \"com.louiscad.splitties:splitties-viewdsl-appcompat-styles:2.1.1\" implementation \"com.louiscad.splitties:splitties-viewdsl-constraintlayout:2.1.1\" implementation \"com.louiscad.splitties:splitties-viewdsl-design:2.1.1\" debugImplementation \"com.louiscad.splitties:splitties-viewdsl-ide-preview:2.1.1\" implementation \"com.louiscad.splitties:splitties-views:2.1.1\" implementation \"com.louiscad.splitties:splitties-views-appcompat:2.1.1\" All the lines above assume you defined the `splitties_version` ext property in your root project's `build.gradle` file to `2.0.0-alpha1` as show in this snippet: allProjects { ext { splitties_version = '2.0.0-alpha1' } }","title":"New artifacts"},{"location":"2/CHANGELOG/#version-130-2017-04-17","text":"","title":"Version 1.3.0 (2017-04-17)"},{"location":"2/CHANGELOG/#5-new-library-modules","text":"App Context : Have a Context everywhere Concurrency : Single thread lazy implementations, with reporting via Timber support Material Lists : List Items for RecyclerView implementing Material Design Guidelines Preferences : Property syntax for Android\u2019s SharedPreferences Stetho init : Have Stetho without writing any code!","title":"5 new library modules:"},{"location":"2/CHANGELOG/#1-renamed-module_1","text":"Selectable Views replaces Selectable ViewGroups","title":"1 renamed module:"},{"location":"2/CHANGELOG/#other-changes_2","text":"Selectable Views now has a SelectableTextView . Made to use it on simple, single-line list items. Typesafe RecyclerView now depends on Kotlin Typesafe RecyclerView has a new ItemViewHolder helper class for simple but common use cases.","title":"Other changes:"},{"location":"2/CHANGELOG/#version-12-2016-09-19","text":"This version adds the setHost(Host host) method in ViewWrapper.Binder interface where Host can be any type you want you can use from the implementing item View to communicate with your Activity, Fragment, Presenter, or whatever. Note this adds a third type parameter to the ViewWrapper class, and a second one for the ViewWrapper.Binder class.","title":"Version 1.2 (2016-09-19)"},{"location":"2/CHANGELOG/#version-11-2016-09-11","text":"This version adds the setViewHolder(ViewWrapper holder) method in ViewWrapper.Binder interface so list item View s can now get a reference to their ViewHolder , and call getAdapterPosition() on it for example.","title":"Version 1.1 (2016-09-11)"},{"location":"2/CHANGELOG/#version-10-2016-08-24","text":"This is the first release of Splitties. It includes two independent modules: - Typesafe RecyclerView - Selectable ViewGroups For gradle projects from jcenter() repo: compile 'xyz.louiscad.splitties:selectableviewgroups:1.0' compile 'xyz.louiscad.splitties:typesaferecyclerview:1.0'","title":"Version 1.0 (2016-08-24)"},{"location":"2/Kotlin-UIs-vs-xml-layouts/","text":"Why a Kotlin Views DSL over xml layouts? \u00b6 There are reasons Splitties Views DSL, an alternative to xml layouts has been built for Android. This document is a simple pros and cons of each approach so you can judge by yourself. Facts \u00b6 If we don\u2019t count imports and copyright headers, the xml version of MainUi (from the sample) was more than 100% lengthier (50 lines with Kotlin, 102 lines in xml). Pros and cons \u00b6 Pros of xml layouts \u00b6 You can almost instantly preview a layout file (despite the huge RAM and CPU usage) from the IDE. You can declare a new compile time constant id resource on the fly with @+id/some_new_id You kind of have a WYSIWYG (what you see is what you get) experience in the IDE. Kind of because it includes only xml layouts and compiled custom views. Logic in code can\u2019t be previewed in the IDE with xml layouts. Cons of xml layouts \u00b6 You repeat android and app over and over, cluttering the code, resulting in hardly readable code . Layout parameters and view attributes are mixed together and are not so well ordered in some cases such as when using ConstraintLayout . Some things that affect your Views can only be done from code, leading to 2 problems: You can\u2019t preview them, and your UI code is split over at least 2 files . xml layout inflation involves reflection , which can slow down UI creating, on large layouts and/or lower end devices. Some attributes that could make layout files easier to read like horitontalMargin and verticalMargin are only available on API 26+ in xml . If you support API 16 and lower, LTR support is subpar . When specifying start/end margins, you still need to specify left and right values for API 16 or older (while start could default to left when RTL is not supported\u2026). You also need to keep them in sync manually when you change the values. You can\u2019t take advantage of Kotlin extensions and other Kotlin features. If you want to make your UI dynamic, you need to use code, and xml is not really code, so you need to split your UI logic, being more error-prone in the long run. Reusing parts of UI is hard and verbose, because you can only include other files, but there\u2019s no things like functions for example. Pros of Splitties Views DSL \u00b6 It is concise (most layouts converted from xml end up shorter, sometimes even when counting the import lines). Is is more expressive and you can make it even better by defining extension function or properties on the Views, LayoutParams, etc, so you can hide a set of operations behind a simple function call. There are no restrictions on the language features you can use in your UI code, you\u2019re not just limited to xml available attributes and resources. You can reuse UI code in much more and easier ways than you can do with xml layouts + code. Your Ui can implement an interface so you can easily swap implementations. This can be handy for A/B testing, allowing more user preferences to tweak or completely change the UI, and more. Layout direction defaults to LTR before API 17 and you can keep using start/end without added boilerplate. You can preview layouts in Android Studio (requires build), with any included logic being taken into account. Layout parameters are not mixed with View config. No reflection involved. No need for findViewById(\u2026) and the implied lookup costs. Cons of Splitties Views DSL \u00b6 Preview requires a build (but you\u2019re less likely to need preview thanks to additional type safety and more expressive UI code). You can\u2019t create a compile time constant View id on the fly (but you can have ids generated automatically at runtime, declare an id resource easily or reuse one declared on-the-fly from an existing xml layout).","title":"Kotlin-UIs-vs-xml-layouts"},{"location":"2/Kotlin-UIs-vs-xml-layouts/#why-a-kotlin-views-dsl-over-xml-layouts","text":"There are reasons Splitties Views DSL, an alternative to xml layouts has been built for Android. This document is a simple pros and cons of each approach so you can judge by yourself.","title":"Why a Kotlin Views DSL over xml layouts?"},{"location":"2/Kotlin-UIs-vs-xml-layouts/#facts","text":"If we don\u2019t count imports and copyright headers, the xml version of MainUi (from the sample) was more than 100% lengthier (50 lines with Kotlin, 102 lines in xml).","title":"Facts"},{"location":"2/Kotlin-UIs-vs-xml-layouts/#pros-and-cons","text":"","title":"Pros and cons"},{"location":"2/Kotlin-UIs-vs-xml-layouts/#pros-of-xml-layouts","text":"You can almost instantly preview a layout file (despite the huge RAM and CPU usage) from the IDE. You can declare a new compile time constant id resource on the fly with @+id/some_new_id You kind of have a WYSIWYG (what you see is what you get) experience in the IDE. Kind of because it includes only xml layouts and compiled custom views. Logic in code can\u2019t be previewed in the IDE with xml layouts.","title":"Pros of xml layouts"},{"location":"2/Kotlin-UIs-vs-xml-layouts/#cons-of-xml-layouts","text":"You repeat android and app over and over, cluttering the code, resulting in hardly readable code . Layout parameters and view attributes are mixed together and are not so well ordered in some cases such as when using ConstraintLayout . Some things that affect your Views can only be done from code, leading to 2 problems: You can\u2019t preview them, and your UI code is split over at least 2 files . xml layout inflation involves reflection , which can slow down UI creating, on large layouts and/or lower end devices. Some attributes that could make layout files easier to read like horitontalMargin and verticalMargin are only available on API 26+ in xml . If you support API 16 and lower, LTR support is subpar . When specifying start/end margins, you still need to specify left and right values for API 16 or older (while start could default to left when RTL is not supported\u2026). You also need to keep them in sync manually when you change the values. You can\u2019t take advantage of Kotlin extensions and other Kotlin features. If you want to make your UI dynamic, you need to use code, and xml is not really code, so you need to split your UI logic, being more error-prone in the long run. Reusing parts of UI is hard and verbose, because you can only include other files, but there\u2019s no things like functions for example.","title":"Cons of xml layouts"},{"location":"2/Kotlin-UIs-vs-xml-layouts/#pros-of-splitties-views-dsl","text":"It is concise (most layouts converted from xml end up shorter, sometimes even when counting the import lines). Is is more expressive and you can make it even better by defining extension function or properties on the Views, LayoutParams, etc, so you can hide a set of operations behind a simple function call. There are no restrictions on the language features you can use in your UI code, you\u2019re not just limited to xml available attributes and resources. You can reuse UI code in much more and easier ways than you can do with xml layouts + code. Your Ui can implement an interface so you can easily swap implementations. This can be handy for A/B testing, allowing more user preferences to tweak or completely change the UI, and more. Layout direction defaults to LTR before API 17 and you can keep using start/end without added boilerplate. You can preview layouts in Android Studio (requires build), with any included logic being taken into account. Layout parameters are not mixed with View config. No reflection involved. No need for findViewById(\u2026) and the implied lookup costs.","title":"Pros of Splitties Views DSL"},{"location":"2/Kotlin-UIs-vs-xml-layouts/#cons-of-splitties-views-dsl","text":"Preview requires a build (but you\u2019re less likely to need preview thanks to additional type safety and more expressive UI code). You can\u2019t create a compile time constant View id on the fly (but you can have ids generated automatically at runtime, declare an id resource easily or reuse one declared on-the-fly from an existing xml layout).","title":"Cons of Splitties Views DSL"},{"location":"2/activities/","text":"Activities \u00b6 Start activities with minimal boilerplate. Content \u00b6 Starting Activities \u00b6 The start extension function for Context takes advantage of reified type parameters to allow you to write such code: start<AboutActivity>() . There\u2019s an optional lambda where the Intent is the receiver so you can edit it (e.g. adding flags) before the activity is started with it. The startActivity extension function for Context is designed for implicit intents. It expects the Intent action as first parameter, and takes an optional lambda to edit the intent further, like start . Download \u00b6 implementation \"com.louiscad.splitties:splitties-activities:2.1.1\"","title":"activities"},{"location":"2/activities/#activities","text":"Start activities with minimal boilerplate.","title":"Activities"},{"location":"2/activities/#content","text":"","title":"Content"},{"location":"2/activities/#starting-activities","text":"The start extension function for Context takes advantage of reified type parameters to allow you to write such code: start<AboutActivity>() . There\u2019s an optional lambda where the Intent is the receiver so you can edit it (e.g. adding flags) before the activity is started with it. The startActivity extension function for Context is designed for implicit intents. It expects the Intent action as first parameter, and takes an optional lambda to edit the intent further, like start .","title":"Starting Activities"},{"location":"2/activities/#download","text":"implementation \"com.louiscad.splitties:splitties-activities:2.1.1\"","title":"Download"},{"location":"2/alertdialog-appcompat/","text":"Alert Dialog AppCompat \u00b6 Create simple alert dialogs with simple code Example \u00b6 import splitties.alertdialog.appcompat.alert import splitties.alertdialog.appcompat.cancelButton import splitties.alertdialog.appcompat.messageResource import splitties.alertdialog.appcompat.okButton import splitties.alertdialog.appcompat.onShow import splitties.alertdialog.appcompat.positiveButton class YourActivity : AppCompatActivity { //... private fun doIrreversibleStuffOrCancel () { alert { messageResource = R . string . dialog_msg_confirm_irreversible_stuff okButton { irreversibleStuff () } cancelButton () }. onShow { positiveButton . textColorResource = R . color . red_500 }. show () } } Download \u00b6 implementation \"com.louiscad.splitties:splitties-alertdialog-appcompat:2.1.1\"","title":"alertdialog-appcompat"},{"location":"2/alertdialog-appcompat/#alert-dialog-appcompat","text":"Create simple alert dialogs with simple code","title":"Alert Dialog AppCompat"},{"location":"2/alertdialog-appcompat/#example","text":"import splitties.alertdialog.appcompat.alert import splitties.alertdialog.appcompat.cancelButton import splitties.alertdialog.appcompat.messageResource import splitties.alertdialog.appcompat.okButton import splitties.alertdialog.appcompat.onShow import splitties.alertdialog.appcompat.positiveButton class YourActivity : AppCompatActivity { //... private fun doIrreversibleStuffOrCancel () { alert { messageResource = R . string . dialog_msg_confirm_irreversible_stuff okButton { irreversibleStuff () } cancelButton () }. onShow { positiveButton . textColorResource = R . color . red_500 }. show () } }","title":"Example"},{"location":"2/alertdialog-appcompat/#download","text":"implementation \"com.louiscad.splitties:splitties-alertdialog-appcompat:2.1.1\"","title":"Download"},{"location":"2/alertdialog/","text":"Alert Dialog \u00b6 Create simple alert dialogs with simple code You may be looking for the AppCompat version . Example \u00b6 import splitties.alertdialog.alert import splitties.alertdialog.cancelButton import splitties.alertdialog.messageResource import splitties.alertdialog.okButton import splitties.alertdialog.onShow import splitties.alertdialog.positiveButton class YourActivity : AppCompatActivity { //... private fun doIrreversibleStuffOrCancel () { alert { messageResource = R . string . dialog_msg_confirm_irreversible_stuff okButton { irreversibleStuff () } cancelButton () }. onShow { positiveButton . textColorResource = R . color . red_500 }. show () } } Download \u00b6 implementation \"com.louiscad.splitties:splitties-alertdialog:2.1.1\"","title":"alertdialog"},{"location":"2/alertdialog/#alert-dialog","text":"Create simple alert dialogs with simple code You may be looking for the AppCompat version .","title":"Alert Dialog"},{"location":"2/alertdialog/#example","text":"import splitties.alertdialog.alert import splitties.alertdialog.cancelButton import splitties.alertdialog.messageResource import splitties.alertdialog.okButton import splitties.alertdialog.onShow import splitties.alertdialog.positiveButton class YourActivity : AppCompatActivity { //... private fun doIrreversibleStuffOrCancel () { alert { messageResource = R . string . dialog_msg_confirm_irreversible_stuff okButton { irreversibleStuff () } cancelButton () }. onShow { positiveButton . textColorResource = R . color . red_500 }. show () } }","title":"Example"},{"location":"2/alertdialog/#download","text":"implementation \"com.louiscad.splitties:splitties-alertdialog:2.1.1\"","title":"Download"},{"location":"2/appctx/","text":"App Context \u00b6 Always have your application Context at hand with appCtx . This split provides two read-only properties: appCtx that returns your Application Context directBootCtx for your direct boot aware components where storage is involved, if any. It also brings these 2 extensions functions on Context for advanced usages: - injectAsAppCtx() - canLeakMemory() You can use appCtx and directBootCtx anywhere in your app (without risking leaking a short-lived context such as an Activity or a Service). This makes writing code that needs a Context for non Activity specific purposes more convenient. Important: use the right context! \u00b6 You may not want to use the Application Context in some cases. Context for storage \u00b6 If you need a Context to access storage from a library (for SharedPreferences, a database or other files), you should allow passing a specific Context that could default as appCtx , so it is possible for target apps to use a special Context like directBootCtx . Configuration dependent or themed Context \u00b6 Devices on which your app/library runs may (will) change configuration during the app\u2019s process lifecycle, such as screen density, language or orientation. Please, do not use appCtx or directBootCtx if you rely on a \u201cscoped\u201d Context to access themed resources from an Activity, or configuration dependent values/resources. Note that in some cases, configuration dependent context usage may be ok if your component handles onConfigurationChanged() properly. More generally, if you wonder if using Application Context is ok, test your app against configuration changes that may affect it and check it reacts correctly. How it works \u00b6 This library takes advantage of Content Providers to automatically initialize appCtx for you before even your Application \u2018s onCreate() is called! This library also takes advantage of manifest placeholders (with the default ${applicationId} ) and gradle manifest merging to avoid two apps using this library clashing with same authority Content Providers. This is the same trick used by Firebase to auto-initialize the library. You can read more on this here . Advanced use cases \u00b6 Multi-process apps and libraries \u00b6 While most apps run on single-process, on the default one, some need to run some components in different processes. If your app needs to access appCtx or directBootCtx directly, or indirectly in a component that has it\u2019s android:process tag in AndroidManifest.xml set to :the_name_of_your_private_process or the_fully_qualified_name_of_your_shared_process , you have 3 solutions: 1. Do nothing and let appCtx init itself with reflection on first access 2. Call injectAsAppCtx() in the onCreate() method of your custom Application subclass. 3. Subclass AppCtxInitProvider and declare it correctly in your AndroidManifest.xml for each non default process. This option may be the best one if you\u2019re making a library that has its own process as no further configuration will be required on the app side. See instructions below: How to declare an AppCtxInitProvider correctly (for multi-process usage) \u00b6 Subclass AppCtxInitProvider Register your subclass as a provider in your AndroidManifest.xml file. Specify it\u2019s android:process attribute to the name of your app\u2019s non default process. (beware of typos) Set android:exported to false. Set android:authorities to something other than ${applicationId}.appctxinitprovider . The suggested naming convention is ${applicationId}.appctxinitprovider.the_name_of_your_process so the content provider authority doesn\u2019t clash with another one from your app, or from a third-party app. If your component is Direct Boot aware, add android:directBootAware=\"true\" . If you use appCtx or directBootCtx in another Content Provider, make sure to specify android:initOrder to a higher value than the one of the other Content Provider which use the ctx properties. The result should look like this: <provider android:name= \".SecondProcessInitProvider\" android:authorities= \"${applicationId}.appctxinitprovider.second_process\" android:exported= \"false\" android:initOrder= \"900\" android:process= \":second_process\" /> import splitties.init.AppCtxInitProvider class SecondProcessInitProvider : AppCtxInitProvider () Download \u00b6 implementation \"com.louiscad.splitties:splitties-appctx:2.1.1\"","title":"appctx"},{"location":"2/appctx/#app-context","text":"Always have your application Context at hand with appCtx . This split provides two read-only properties: appCtx that returns your Application Context directBootCtx for your direct boot aware components where storage is involved, if any. It also brings these 2 extensions functions on Context for advanced usages: - injectAsAppCtx() - canLeakMemory() You can use appCtx and directBootCtx anywhere in your app (without risking leaking a short-lived context such as an Activity or a Service). This makes writing code that needs a Context for non Activity specific purposes more convenient.","title":"App Context"},{"location":"2/appctx/#important-use-the-right-context","text":"You may not want to use the Application Context in some cases.","title":"Important: use the right context!"},{"location":"2/appctx/#context-for-storage","text":"If you need a Context to access storage from a library (for SharedPreferences, a database or other files), you should allow passing a specific Context that could default as appCtx , so it is possible for target apps to use a special Context like directBootCtx .","title":"Context for storage"},{"location":"2/appctx/#configuration-dependent-or-themed-context","text":"Devices on which your app/library runs may (will) change configuration during the app\u2019s process lifecycle, such as screen density, language or orientation. Please, do not use appCtx or directBootCtx if you rely on a \u201cscoped\u201d Context to access themed resources from an Activity, or configuration dependent values/resources. Note that in some cases, configuration dependent context usage may be ok if your component handles onConfigurationChanged() properly. More generally, if you wonder if using Application Context is ok, test your app against configuration changes that may affect it and check it reacts correctly.","title":"Configuration dependent or themed Context"},{"location":"2/appctx/#how-it-works","text":"This library takes advantage of Content Providers to automatically initialize appCtx for you before even your Application \u2018s onCreate() is called! This library also takes advantage of manifest placeholders (with the default ${applicationId} ) and gradle manifest merging to avoid two apps using this library clashing with same authority Content Providers. This is the same trick used by Firebase to auto-initialize the library. You can read more on this here .","title":"How it works"},{"location":"2/appctx/#advanced-use-cases","text":"","title":"Advanced use cases"},{"location":"2/appctx/#multi-process-apps-and-libraries","text":"While most apps run on single-process, on the default one, some need to run some components in different processes. If your app needs to access appCtx or directBootCtx directly, or indirectly in a component that has it\u2019s android:process tag in AndroidManifest.xml set to :the_name_of_your_private_process or the_fully_qualified_name_of_your_shared_process , you have 3 solutions: 1. Do nothing and let appCtx init itself with reflection on first access 2. Call injectAsAppCtx() in the onCreate() method of your custom Application subclass. 3. Subclass AppCtxInitProvider and declare it correctly in your AndroidManifest.xml for each non default process. This option may be the best one if you\u2019re making a library that has its own process as no further configuration will be required on the app side. See instructions below:","title":"Multi-process apps and libraries"},{"location":"2/appctx/#how-to-declare-an-appctxinitprovider-correctly-for-multi-process-usage","text":"Subclass AppCtxInitProvider Register your subclass as a provider in your AndroidManifest.xml file. Specify it\u2019s android:process attribute to the name of your app\u2019s non default process. (beware of typos) Set android:exported to false. Set android:authorities to something other than ${applicationId}.appctxinitprovider . The suggested naming convention is ${applicationId}.appctxinitprovider.the_name_of_your_process so the content provider authority doesn\u2019t clash with another one from your app, or from a third-party app. If your component is Direct Boot aware, add android:directBootAware=\"true\" . If you use appCtx or directBootCtx in another Content Provider, make sure to specify android:initOrder to a higher value than the one of the other Content Provider which use the ctx properties. The result should look like this: <provider android:name= \".SecondProcessInitProvider\" android:authorities= \"${applicationId}.appctxinitprovider.second_process\" android:exported= \"false\" android:initOrder= \"900\" android:process= \":second_process\" /> import splitties.init.AppCtxInitProvider class SecondProcessInitProvider : AppCtxInitProvider ()","title":"How to declare an AppCtxInitProvider correctly (for multi-process usage)"},{"location":"2/appctx/#download","text":"implementation \"com.louiscad.splitties:splitties-appctx:2.1.1\"","title":"Download"},{"location":"2/arch-lifecycle/","text":"Arch Lifecycle \u00b6 Extensions to get ViewModel s, use LiveData and observe Lifecycle s. This makes using Android Architecture Components nicer in Kotlin. Content \u00b6 LifecycleObserver \u00b6 This is a GenericLifecycleObserver sub-interface that has lifecycle state change methods (like onResume(\u2026) or onPause(\u2026) ) with default implementations so you override only the ones you need. ViewModel providers \u00b6 ViewModels are instantiated by host Activity scope. The activityScope<YourViewModel>() extensions on FragmentActivity and support Fragment return a Lazy<YourViewModel instance that you can use on a delegated property in your Activity or Fragment : class YourActivity : AppCompatActivity () { private val viewModel : YourViewModel by activityScope () private val anotherViewModel by activityScope < AnotherViewModel >() } class SomeFragment : Fragment () { private val viewModel by activityScope < YourViewModel >() } LiveData observing and map extension \u00b6 observe and observeNotNull extension functions on LifecycleOwner \u00b6 class YourActivity : AppCompatActivity () { private val viewModel by activityScope < YourViewModel >() override fun onCreate ( savedInstanceState : Bundle ?) { observe ( viewModel . yourLiveData ) { data : YourData ? -> updateUi ( data ) } observeNotNull ( viewModel . anotherLiveData ) { doSomething ( it . someProperty ) doSomethingElse ( it ) } } } map extension function on LiveData \u00b6 class YourViewModel : ViewModel () { val yourLiveData : LiveData < YourData > = createYourLiveData () val anotherLiveData = yourLiveData . map { it ?. someProperty } } Note that the map lambda runs on UI thread, so very light operations like getting a property is right, but long/blocking operations are not (would result in lags or ANRs). Download \u00b6 implementation \"com.louiscad.splitties:splitties-arch-lifecycle:2.1.1\"","title":"arch-lifecycle"},{"location":"2/arch-lifecycle/#arch-lifecycle","text":"Extensions to get ViewModel s, use LiveData and observe Lifecycle s. This makes using Android Architecture Components nicer in Kotlin.","title":"Arch Lifecycle"},{"location":"2/arch-lifecycle/#content","text":"","title":"Content"},{"location":"2/arch-lifecycle/#lifecycleobserver","text":"This is a GenericLifecycleObserver sub-interface that has lifecycle state change methods (like onResume(\u2026) or onPause(\u2026) ) with default implementations so you override only the ones you need.","title":"LifecycleObserver"},{"location":"2/arch-lifecycle/#viewmodel-providers","text":"ViewModels are instantiated by host Activity scope. The activityScope<YourViewModel>() extensions on FragmentActivity and support Fragment return a Lazy<YourViewModel instance that you can use on a delegated property in your Activity or Fragment : class YourActivity : AppCompatActivity () { private val viewModel : YourViewModel by activityScope () private val anotherViewModel by activityScope < AnotherViewModel >() } class SomeFragment : Fragment () { private val viewModel by activityScope < YourViewModel >() }","title":"ViewModel providers"},{"location":"2/arch-lifecycle/#livedata-observing-and-map-extension","text":"","title":"LiveData observing and map extension"},{"location":"2/arch-lifecycle/#observe-and-observenotnull-extension-functions-on-lifecycleowner","text":"class YourActivity : AppCompatActivity () { private val viewModel by activityScope < YourViewModel >() override fun onCreate ( savedInstanceState : Bundle ?) { observe ( viewModel . yourLiveData ) { data : YourData ? -> updateUi ( data ) } observeNotNull ( viewModel . anotherLiveData ) { doSomething ( it . someProperty ) doSomethingElse ( it ) } } }","title":"observe and observeNotNull extension functions on LifecycleOwner"},{"location":"2/arch-lifecycle/#map-extension-function-on-livedata","text":"class YourViewModel : ViewModel () { val yourLiveData : LiveData < YourData > = createYourLiveData () val anotherLiveData = yourLiveData . map { it ?. someProperty } } Note that the map lambda runs on UI thread, so very light operations like getting a property is right, but long/blocking operations are not (would result in lags or ANRs).","title":"map extension function on LiveData"},{"location":"2/arch-lifecycle/#download","text":"implementation \"com.louiscad.splitties:splitties-arch-lifecycle:2.1.1\"","title":"Download"},{"location":"2/arch-room/","text":"Arch Room \u00b6 Room helpers to instantiate your DB and perform transactions in Kotlin. Content \u00b6 Room Database instantiation \u00b6 The roomDb(\u2026) function has a reified type parameter used to call Room.databaseBuilder with the proper arguments. name is the only required parameter. You can specify a Context as first parameter if you don\u2019t want to use the application context, if you want to use a different context (e.g. to use directBootCtx in a direct boot aware app component). The last parameter is a lambda with the db builder as receiver where you can things like migrations. Room Database transactions \u00b6 transaction { \u2026 } is the inline version of runInTransaction , with your database as receiver. inTransaction { \u2026 } does the same as transaction { \u2026 } but returns the value of the last expression of the lambda. Inlining brings a slight performance improvement at runtime and reduces the number of classes, making the apk smaller. Download \u00b6 implementation \"com.louiscad.splitties:splitties-arch-room:2.1.1\"","title":"arch-room"},{"location":"2/arch-room/#arch-room","text":"Room helpers to instantiate your DB and perform transactions in Kotlin.","title":"Arch Room"},{"location":"2/arch-room/#content","text":"","title":"Content"},{"location":"2/arch-room/#room-database-instantiation","text":"The roomDb(\u2026) function has a reified type parameter used to call Room.databaseBuilder with the proper arguments. name is the only required parameter. You can specify a Context as first parameter if you don\u2019t want to use the application context, if you want to use a different context (e.g. to use directBootCtx in a direct boot aware app component). The last parameter is a lambda with the db builder as receiver where you can things like migrations.","title":"Room Database instantiation"},{"location":"2/arch-room/#room-database-transactions","text":"transaction { \u2026 } is the inline version of runInTransaction , with your database as receiver. inTransaction { \u2026 } does the same as transaction { \u2026 } but returns the value of the last expression of the lambda. Inlining brings a slight performance improvement at runtime and reduces the number of classes, making the apk smaller.","title":"Room Database transactions"},{"location":"2/arch-room/#download","text":"implementation \"com.louiscad.splitties:splitties-arch-room:2.1.1\"","title":"Download"},{"location":"2/bitflags/","text":"Bit Flags \u00b6 hasFlag , withFlag and minusFlag extensions on Long , Int , Short and Byte These extensions make dealing with bit flags easier. These small inline extensions can be proven handy since bit flags are found in multiple places over the Android API, in low level stuff when you have to deal with raw bytes, and maybe in your own codebase too. Download \u00b6 implementation \"com.louiscad.splitties:splitties-bitflags:2.1.1\"","title":"bitflags"},{"location":"2/bitflags/#bit-flags","text":"hasFlag , withFlag and minusFlag extensions on Long , Int , Short and Byte These extensions make dealing with bit flags easier. These small inline extensions can be proven handy since bit flags are found in multiple places over the Android API, in low level stuff when you have to deal with raw bytes, and maybe in your own codebase too.","title":"Bit Flags"},{"location":"2/bitflags/#download","text":"implementation \"com.louiscad.splitties:splitties-bitflags:2.1.1\"","title":"Download"},{"location":"2/bundle/","text":"Bundle \u00b6 BundleSpec to use Bundle with property syntax for Intent extras and more. Non-exhaustive list of use cases \u00b6 Intent extras of Activities, BroadcastReceivers, Services, etc. Instance state of Activities, Fragments and Views. Can be used for Activity extras, but also in Service extras, BroadcastReceiver and other parts where an Intent or a Bundle is used. Usage \u00b6 For Activity extras \u00b6 Let\u2019s say you have an Activity subclass named YourActivity . In YourActivity , add a nested object named ExtrasSpec . Make it extend BundleSpec . For each required Intent extra you need, in ExtrasSpec , add a var property with explicit non null type, delegated by bundle() . For each optional Intent extra you need, still in ExtrasSpec , add a var property with either and explicit nullable type, delegated by bundleOrNull() , or with a non null type, delegated by bundleOrDefault(\u2026) or by bundleOrElse { \u2026 } . When setting up the Intent to start your Activity , call putExtras(YourActivity.ExtrasSpec) { \u2026 } on it, setting values on the ExtrasSpec properties in the lambda. From YourActivity , call withExtras(ExtrasSpec) { \u2026 } to get the extras as properties from the lambda (the result of the call is the result of the lambda). Other usages \u00b6 Only Activity has a withExtras(\u2026) { \u2026 } extension, but you can use with(\u2026) { \u2026 } extension on any Bundle and any Intent extras . The putExtras(\u2026) { \u2026 } extension works on any Intent , Activity or not. See the examples below. Important details \u00b6 See the implementation of the put(\u2026) extension on Bundle to check all the supported types (it is likely to suit your needs). You may only access the delegated properties of a BundleSpec subclass inside the withExtras(\u2026) { \u2026 } lambda or inside the someBundle.with(\u2026) { \u2026 } lambda. If you violate this rule, an IllegalStateException will be thrown. The implementation has been optimized for efficiency. The delegates under bundle() and bundleOrNull() are singletons and are shared for all properties app-wide. The versions that accept a key or a default value can\u2019t be singletons, but since you\u2019re likely using them in object backed specs, they are instantiated only once per property, having a minimal memory impact (especially when compared to the cost of data serialization in Bundles). Examples \u00b6 Extras in an Activity \u00b6 class DemoActivity : AppCompatActivity () { object ExtrasSpec : BundleSpec () { var userName : String by bundle () // Required extra var showGreetingToast by bundleOrDefault ( false ) // Optional extra, defaults to false var optionalExtra : String ? by bundleOrNull () // Optional extra } override fun onCreate ( savedInstanceState : Bundle ?) { super . onCreate ( savedInstanceState ) withExtras ( ExtrasSpec ) { // Populates ExtrasSpec with actual extras if ( showGreetingToast ) toast ( android . R . string . ok ) optionalExtras ?. forEach { Timber . i ( \"Character from optional extra: $it\" ) } } restOfYourCode () } } class StartDemoActivity : AppCompatActivity () { private fun someFunction ( name : String , isUserPolite : Boolean = false ) { startActivity ( Intent ( this , DemoActivity :: class . java ). apply { putExtras ( DemoActivity . ExtrasSpec ) { userName = name showGreetingToast = isUserPolite } }) } } Extras in a BroadcastReceiver \u00b6 class AirplaneModeReceiver : BroadcastReceiver () { object ExtrasSpec : BundleSpec () { var isAirplaneModeOn : Boolean by bundle ( \"state\" ) } override fun onReceive ( context : Context , intent : Intent ) { if ( intent . action != Intent . ACTION_AIRPLANE_MODE_CHANGED ) return val isAirplaneModeOn = intent . extras . with ( ExtrasSpec ) { isAirplaneModeOn } handleAirplaneMode ( isAirplaneModeOn ) } } Instance State in an Activity \u00b6 class DemoActivity : AppCompatActivity () { private object InstanceStateSpec : BundleSpec () { var startTime : Long by bundle () } private var startTimestamp = 0L override fun onCreate ( savedInstanceState : Bundle ?) { super . onCreate ( savedInstanceState ) startTimestamp = savedInstanceState ?. with ( InstanceStateSpec ) { startTime } ?: System . currentTimeMillis () restOfYourCode () } override fun onSaveInstanceState ( outState : Bundle ) { outState . with ( InstanceStateSpec ) { startTime = startTimestamp } super . onSaveInstanceState ( outState ) } } Download \u00b6 implementation \"com.louiscad.splitties:splitties-bundle:2.1.1\"","title":"bundle"},{"location":"2/bundle/#bundle","text":"BundleSpec to use Bundle with property syntax for Intent extras and more.","title":"Bundle"},{"location":"2/bundle/#non-exhaustive-list-of-use-cases","text":"Intent extras of Activities, BroadcastReceivers, Services, etc. Instance state of Activities, Fragments and Views. Can be used for Activity extras, but also in Service extras, BroadcastReceiver and other parts where an Intent or a Bundle is used.","title":"Non-exhaustive list of use cases"},{"location":"2/bundle/#usage","text":"","title":"Usage"},{"location":"2/bundle/#for-activity-extras","text":"Let\u2019s say you have an Activity subclass named YourActivity . In YourActivity , add a nested object named ExtrasSpec . Make it extend BundleSpec . For each required Intent extra you need, in ExtrasSpec , add a var property with explicit non null type, delegated by bundle() . For each optional Intent extra you need, still in ExtrasSpec , add a var property with either and explicit nullable type, delegated by bundleOrNull() , or with a non null type, delegated by bundleOrDefault(\u2026) or by bundleOrElse { \u2026 } . When setting up the Intent to start your Activity , call putExtras(YourActivity.ExtrasSpec) { \u2026 } on it, setting values on the ExtrasSpec properties in the lambda. From YourActivity , call withExtras(ExtrasSpec) { \u2026 } to get the extras as properties from the lambda (the result of the call is the result of the lambda).","title":"For Activity extras"},{"location":"2/bundle/#other-usages","text":"Only Activity has a withExtras(\u2026) { \u2026 } extension, but you can use with(\u2026) { \u2026 } extension on any Bundle and any Intent extras . The putExtras(\u2026) { \u2026 } extension works on any Intent , Activity or not. See the examples below.","title":"Other usages"},{"location":"2/bundle/#important-details","text":"See the implementation of the put(\u2026) extension on Bundle to check all the supported types (it is likely to suit your needs). You may only access the delegated properties of a BundleSpec subclass inside the withExtras(\u2026) { \u2026 } lambda or inside the someBundle.with(\u2026) { \u2026 } lambda. If you violate this rule, an IllegalStateException will be thrown. The implementation has been optimized for efficiency. The delegates under bundle() and bundleOrNull() are singletons and are shared for all properties app-wide. The versions that accept a key or a default value can\u2019t be singletons, but since you\u2019re likely using them in object backed specs, they are instantiated only once per property, having a minimal memory impact (especially when compared to the cost of data serialization in Bundles).","title":"Important details"},{"location":"2/bundle/#examples","text":"","title":"Examples"},{"location":"2/bundle/#extras-in-an-activity","text":"class DemoActivity : AppCompatActivity () { object ExtrasSpec : BundleSpec () { var userName : String by bundle () // Required extra var showGreetingToast by bundleOrDefault ( false ) // Optional extra, defaults to false var optionalExtra : String ? by bundleOrNull () // Optional extra } override fun onCreate ( savedInstanceState : Bundle ?) { super . onCreate ( savedInstanceState ) withExtras ( ExtrasSpec ) { // Populates ExtrasSpec with actual extras if ( showGreetingToast ) toast ( android . R . string . ok ) optionalExtras ?. forEach { Timber . i ( \"Character from optional extra: $it\" ) } } restOfYourCode () } } class StartDemoActivity : AppCompatActivity () { private fun someFunction ( name : String , isUserPolite : Boolean = false ) { startActivity ( Intent ( this , DemoActivity :: class . java ). apply { putExtras ( DemoActivity . ExtrasSpec ) { userName = name showGreetingToast = isUserPolite } }) } }","title":"Extras in an Activity"},{"location":"2/bundle/#extras-in-a-broadcastreceiver","text":"class AirplaneModeReceiver : BroadcastReceiver () { object ExtrasSpec : BundleSpec () { var isAirplaneModeOn : Boolean by bundle ( \"state\" ) } override fun onReceive ( context : Context , intent : Intent ) { if ( intent . action != Intent . ACTION_AIRPLANE_MODE_CHANGED ) return val isAirplaneModeOn = intent . extras . with ( ExtrasSpec ) { isAirplaneModeOn } handleAirplaneMode ( isAirplaneModeOn ) } }","title":"Extras in a BroadcastReceiver"},{"location":"2/bundle/#instance-state-in-an-activity","text":"class DemoActivity : AppCompatActivity () { private object InstanceStateSpec : BundleSpec () { var startTime : Long by bundle () } private var startTimestamp = 0L override fun onCreate ( savedInstanceState : Bundle ?) { super . onCreate ( savedInstanceState ) startTimestamp = savedInstanceState ?. with ( InstanceStateSpec ) { startTime } ?: System . currentTimeMillis () restOfYourCode () } override fun onSaveInstanceState ( outState : Bundle ) { outState . with ( InstanceStateSpec ) { startTime = startTimestamp } super . onSaveInstanceState ( outState ) } }","title":"Instance State in an Activity"},{"location":"2/bundle/#download","text":"implementation \"com.louiscad.splitties:splitties-bundle:2.1.1\"","title":"Download"},{"location":"2/checkedlazy/","text":"Checked Lazy \u00b6 This library provides a checkedLazy() method that returns a Lazy delegate, as well as mainThreadLazy() . checkedLazy() takes as first parameter a function where you can implement an access check. The second parameter is the lazy initializer, as in Kotlin stdlib lazy . mainThreadLazy { \u2026 } is a shorthand for checkedLazy(::checkMainThread) { \u2026 } . It\u2019s there because main thread checking is a common use case on Android due to its synchronized nature and its omnipresence. Example \u00b6 val noMainThreadChecker = noAccessOn ( mainThread ) class YourClass { val greeting : String by mainThreadLazy { \"Hello Splitties!\" } val expensiveObject by checkedLazy ( noMainThreadChecker ) { doHeavyInstantiation () } } Download \u00b6 implementation \"com.louiscad.splitties:splitties-checkedlazy:2.1.1\"","title":"checkedlazy"},{"location":"2/checkedlazy/#checked-lazy","text":"This library provides a checkedLazy() method that returns a Lazy delegate, as well as mainThreadLazy() . checkedLazy() takes as first parameter a function where you can implement an access check. The second parameter is the lazy initializer, as in Kotlin stdlib lazy . mainThreadLazy { \u2026 } is a shorthand for checkedLazy(::checkMainThread) { \u2026 } . It\u2019s there because main thread checking is a common use case on Android due to its synchronized nature and its omnipresence.","title":"Checked Lazy"},{"location":"2/checkedlazy/#example","text":"val noMainThreadChecker = noAccessOn ( mainThread ) class YourClass { val greeting : String by mainThreadLazy { \"Hello Splitties!\" } val expensiveObject by checkedLazy ( noMainThreadChecker ) { doHeavyInstantiation () } }","title":"Example"},{"location":"2/checkedlazy/#download","text":"implementation \"com.louiscad.splitties:splitties-checkedlazy:2.1.1\"","title":"Download"},{"location":"2/collections/","text":"Collections \u00b6 forEach for List s without Iterator allocation. Content \u00b6 The forEachByIndex and forEachWithIndex extension functions for List allows you to iterate on a List without allocating an Iterator . This is useful when you need to iterate on a List in performance critical conditions (e.g. code executed/called from an onDraw method, or code run on the UI thread more generally). You also have the reverse equivalents: forEachReversedByIndex and forEachReversedWithIndex . Download \u00b6 implementation \"com.louiscad.splitties:splitties-collections:2.1.1\"","title":"collections"},{"location":"2/collections/#collections","text":"forEach for List s without Iterator allocation.","title":"Collections"},{"location":"2/collections/#content","text":"The forEachByIndex and forEachWithIndex extension functions for List allows you to iterate on a List without allocating an Iterator . This is useful when you need to iterate on a List in performance critical conditions (e.g. code executed/called from an onDraw method, or code run on the UI thread more generally). You also have the reverse equivalents: forEachReversedByIndex and forEachReversedWithIndex .","title":"Content"},{"location":"2/collections/#download","text":"implementation \"com.louiscad.splitties:splitties-collections:2.1.1\"","title":"Download"},{"location":"2/dimensions/","text":"Dimensions \u00b6 Android dp extensions for View and Context . Particularly handy when using Views DSL . dip and dp extension functions on View and Context take an Int parameter and return the value in Android\u2019s dp. The former (dip) returns an Int while the latter (dp) returns a Float . Examples \u00b6 val minTapTargetSize = dip ( 48 ) val circleDiameter = dp ( 48 ) Download \u00b6 implementation \"com.louiscad.splitties:splitties-dimensions:2.1.1\"","title":"dimensions"},{"location":"2/dimensions/#dimensions","text":"Android dp extensions for View and Context . Particularly handy when using Views DSL . dip and dp extension functions on View and Context take an Int parameter and return the value in Android\u2019s dp. The former (dip) returns an Int while the latter (dp) returns a Float .","title":"Dimensions"},{"location":"2/dimensions/#examples","text":"val minTapTargetSize = dip ( 48 ) val circleDiameter = dp ( 48 )","title":"Examples"},{"location":"2/dimensions/#download","text":"implementation \"com.louiscad.splitties:splitties-dimensions:2.1.1\"","title":"Download"},{"location":"2/exceptions/","text":"Exceptions \u00b6 illegal(\u2026) and similar functions that return Nothing , handy for impossible or illegal when branches. Here\u2019s the list of these functions: * unexpectedValue(\u2026) (puts the value in the Exception message) * illegal(\u2026) (shortcut to throw IllegalStateException(\u2026) ) * illegalArg(\u2026) (shortcut to throw IllegalArgumentException(\u2026) ) * unsupported(\u2026) (shortcut to throw UnsupportedOperationException(\u2026) ) * unsupportedAction(\u2026) (designed for unsupported Intent actions) Download \u00b6 implementation \"com.louiscad.splitties:splitties-exceptions:2.1.1\"","title":"exceptions"},{"location":"2/exceptions/#exceptions","text":"illegal(\u2026) and similar functions that return Nothing , handy for impossible or illegal when branches. Here\u2019s the list of these functions: * unexpectedValue(\u2026) (puts the value in the Exception message) * illegal(\u2026) (shortcut to throw IllegalStateException(\u2026) ) * illegalArg(\u2026) (shortcut to throw IllegalArgumentException(\u2026) ) * unsupported(\u2026) (shortcut to throw UnsupportedOperationException(\u2026) ) * unsupportedAction(\u2026) (designed for unsupported Intent actions)","title":"Exceptions"},{"location":"2/exceptions/#download","text":"implementation \"com.louiscad.splitties:splitties-exceptions:2.1.1\"","title":"Download"},{"location":"2/fragmentargs/","text":"Fragment Args \u00b6 Fragment arguments without ceremony thanks to delegated properties. Example \u00b6 class YourFragment : Fragment () { var someRequiredId : Int by arg () var optionalArg : String ? by argOrNull () var nonNullOptionalArg : String by argOrDefault ( \"\" ) var anotherNonNullOptionalArg : String by argOrElse { \"splitties rock!\" . capitalize () } private fun yourMethod () = yourCode () } fun createYourFragment ( someId : Int ): Fragment = YourFragment (). apply { someRequiredId = someId } Download \u00b6 implementation \"com.louiscad.splitties:splitties-fragmentargs:2.1.1\"","title":"fragmentargs"},{"location":"2/fragmentargs/#fragment-args","text":"Fragment arguments without ceremony thanks to delegated properties.","title":"Fragment Args"},{"location":"2/fragmentargs/#example","text":"class YourFragment : Fragment () { var someRequiredId : Int by arg () var optionalArg : String ? by argOrNull () var nonNullOptionalArg : String by argOrDefault ( \"\" ) var anotherNonNullOptionalArg : String by argOrElse { \"splitties rock!\" . capitalize () } private fun yourMethod () = yourCode () } fun createYourFragment ( someId : Int ): Fragment = YourFragment (). apply { someRequiredId = someId }","title":"Example"},{"location":"2/fragmentargs/#download","text":"implementation \"com.louiscad.splitties:splitties-fragmentargs:2.1.1\"","title":"Download"},{"location":"2/fragments/","text":"Fragments \u00b6 Start activities from fragments and do transactions with minimal boilerplate. Content \u00b6 Starting Activities \u00b6 The start extension function for Context takes advantage of reified type parameters to allow you to write such code: start<AboutActivity>() . There\u2019s an optional lambda where the Intent is the receiver so you can edit it (e.g. adding flags) before the activity is started with it. The startActivity extension function for Context is designed for implicit intents. It expects the Intent action as first parameter, and takes a lambda to edit the intent further, like start . Fragment transactions \u00b6 The fragmentTransaction extension function for FragmentActivity allows to make a fragment transaction without having to write beginTransaction and the commit call repeatedly. It has two optional parameters: * now , that defaults to true so you can get the Fragment immediately after by default. * allowStateLoss that defaults to false . And the lambda is the required body of your transaction where you deal with your Fragments (e.g. adding, replacing\u2026). The addToBackStack() extension function for FragmentTransaction calls addToBackStack(null) . It effectively makes the name parameter optional. Download \u00b6 implementation \"com.louiscad.splitties:splitties-fragments:2.1.1\"","title":"fragments"},{"location":"2/fragments/#fragments","text":"Start activities from fragments and do transactions with minimal boilerplate.","title":"Fragments"},{"location":"2/fragments/#content","text":"","title":"Content"},{"location":"2/fragments/#starting-activities","text":"The start extension function for Context takes advantage of reified type parameters to allow you to write such code: start<AboutActivity>() . There\u2019s an optional lambda where the Intent is the receiver so you can edit it (e.g. adding flags) before the activity is started with it. The startActivity extension function for Context is designed for implicit intents. It expects the Intent action as first parameter, and takes a lambda to edit the intent further, like start .","title":"Starting Activities"},{"location":"2/fragments/#fragment-transactions","text":"The fragmentTransaction extension function for FragmentActivity allows to make a fragment transaction without having to write beginTransaction and the commit call repeatedly. It has two optional parameters: * now , that defaults to true so you can get the Fragment immediately after by default. * allowStateLoss that defaults to false . And the lambda is the required body of your transaction where you deal with your Fragments (e.g. adding, replacing\u2026). The addToBackStack() extension function for FragmentTransaction calls addToBackStack(null) . It effectively makes the name parameter optional.","title":"Fragment transactions"},{"location":"2/fragments/#download","text":"implementation \"com.louiscad.splitties:splitties-fragments:2.1.1\"","title":"Download"},{"location":"2/initprovider/","text":"Init Provider \u00b6 Base class for ContentProvider s used for automatic initialization purposes. See the Stetho Init and App Context implementations to see how it\u2019s meant to be used. Download \u00b6 implementation \"com.louiscad.splitties:splitties-initprovider:2.1.1\"","title":"initprovider"},{"location":"2/initprovider/#init-provider","text":"Base class for ContentProvider s used for automatic initialization purposes. See the Stetho Init and App Context implementations to see how it\u2019s meant to be used.","title":"Init Provider"},{"location":"2/initprovider/#download","text":"implementation \"com.louiscad.splitties:splitties-initprovider:2.1.1\"","title":"Download"},{"location":"2/intents/","text":"Intents \u00b6 Transform companion object s into powerful typesafe intent specs, and create PendingIntent s the clean and easy way. Table of contents \u00b6 Using companion object s as typesafe and key-safe intent specs The problem about intents in Android The solution IntentSpec interfaces IntentSpec implementations providers Using an IntentSpec IntentSpec example Creating PendingIntent s the clean and easy way Download Using companion object s as typesafe and key-safe intent specs \u00b6 The problem about intents in Android \u00b6 An Android component that can receive an Intent (like an Activity or a BroacastReceiver ) can expect an action, or extras. In case of an action, the string must match exactly in order to work properly. In case of an extra, the type must also match. This makes it not typesafe at all. You need to write some documentation to explain which constants to use, with which types, and you need to be sure to read the doc afterwards, to ensure you do it right. There should be a better way. The solution \u00b6 This split provides a few interfaces that your companion object s can implement using delegation so they become an intent specification, that you can use to build and Intent , start an Activity , start a Service or send a broadcast in a type safe way. IntentSpec interfaces \u00b6 The IntentSpec interface has two properties: * klass which is the class of the component * extrasSpec which is a BundleSpec (defined in the Bundle split). The ActivityIntentSpec , BroadcastReceiverIntentSpec and ServiceIntentSpec interfaces all extend the IntentSpec interface, but add a bound to the type parameter of the class. You should use them when defining the intent spec of an Activity , BroadcastReceiver or Service . IntentSpec implementations providers \u00b6 A few methods provide implementation of the interfaces mentioned above: * activitySpec * activityWithoutExtrasSpec where ExtrasSpec is Nothing * receiverSpec * receiverWithoutExtrasSpec where ExtrasSpec is Nothing * serviceSpec * serviceWithoutExtrasSpec where ExtrasSpec is Nothing They are designed to be used with by . Examples: * companion object : ActivityIntentSpec<ProductDetailsActivity, ExtrasSpec> by activitySpec(ExtrasSpec) * companion object : BroadcastReceiverIntentSpec<NotifDismissReceiver, ExtrasSpec> by receiverSpec(ExtrasSpec) Using an IntentSpec \u00b6 The intent method is an extension for IntentSpec . It takes a lambda where the receiver is the Intent . The first parameter is the companion object itself so you can access any constant or method defined in it easily. The second parameter of the lambda is optional, it is the extrasSpec. The start method is an extension for Context and for Fragment that takes the target ActivityIntentSpec as its first parameter. It then calls the intent extension function mentioned above, and the optional expected lambda has the same parameters as for intent . Finally, it calls startActivity with the created Intent . The sendBroadcast method is an extension for Context that takes the target BroadcastReceiverIntentSpec as its first parameter. It then calls the intent extension function mentioned above, and the optional expected lambda has the same parameters as for intent . Finally, it calls sendBroadcast with the created Intent . IntentSpec example \u00b6 Let\u2019s take the example shown in the Bundle README, adding an IntentSpec to it. Notice the new companion object and how we start the DemoActivity with the proper extras from the StartDemoActivity now. class DemoActivity : AppCompatActivity () { companion object : ActivityIntentSpec < DemoActivity , ExtrasSpec > by activitySpec ( ExtrasSpec ) { const val someText = \"Splitties is great!\" } object ExtrasSpec : BundleSpec () { var showGreetingToast : Boolean by bundle () // Required extra var optionalExtra : String ? by bundleOrNull () // Optional extra } override fun onCreate ( savedInstanceState : Bundle ?) { super . onCreate ( savedInstanceState ) withExtras ( ExtrasSpec ) { // Populates ExtrasSpec with actual extras if ( showGreetingToast ) toast ( android . R . string . ok ) optionalExtras ?. let { longToast ( it ) } } restOfYourCode () } } class StartDemoActivity : AppCompatActivity () { private fun someFunction ( isUserPolite : Boolean = false ) { start ( DemoActivity ) { intentSpec , extrasSpec -> // Magic happens here! extrasSpec . showGreetingToast = isUserPolite extrasSpec . optionalExtra = intentSpec . someText } } } Creating PendingIntent s the clean and easy way \u00b6 It\u2019s fair to say that the PendingIntent Android API is not designed for Kotlin, and for a reason, it has been there since API level 1, the first Android version. As a result, code using this API is not always the most readable part of a Kotlin codebase. This split provides several extension functions for Intent that return a PendingIntent : * toPendingActivity() * toPendingService() * toPendingForegroundService() , which also works before API 26 * toPendingBroadcast() and an extension for Array<Intent> : toPendingActivities() . All these functions have two optional parameters that default to zero: reqCode and flags . The toPendingActivity() and toPendingActivities() functions also have an options: Bundle? parameter that defaults to null (and is ignored below API 16). Download \u00b6 implementation \"com.louiscad.splitties:splitties-intents:2.1.1\"","title":"intents"},{"location":"2/intents/#intents","text":"Transform companion object s into powerful typesafe intent specs, and create PendingIntent s the clean and easy way.","title":"Intents"},{"location":"2/intents/#table-of-contents","text":"Using companion object s as typesafe and key-safe intent specs The problem about intents in Android The solution IntentSpec interfaces IntentSpec implementations providers Using an IntentSpec IntentSpec example Creating PendingIntent s the clean and easy way Download","title":"Table of contents"},{"location":"2/intents/#using-companion-objects-as-typesafe-and-key-safe-intent-specs","text":"","title":"Using companion objects as typesafe and key-safe intent specs"},{"location":"2/intents/#the-problem-about-intents-in-android","text":"An Android component that can receive an Intent (like an Activity or a BroacastReceiver ) can expect an action, or extras. In case of an action, the string must match exactly in order to work properly. In case of an extra, the type must also match. This makes it not typesafe at all. You need to write some documentation to explain which constants to use, with which types, and you need to be sure to read the doc afterwards, to ensure you do it right. There should be a better way.","title":"The problem about intents in Android"},{"location":"2/intents/#the-solution","text":"This split provides a few interfaces that your companion object s can implement using delegation so they become an intent specification, that you can use to build and Intent , start an Activity , start a Service or send a broadcast in a type safe way.","title":"The solution"},{"location":"2/intents/#intentspec-interfaces","text":"The IntentSpec interface has two properties: * klass which is the class of the component * extrasSpec which is a BundleSpec (defined in the Bundle split). The ActivityIntentSpec , BroadcastReceiverIntentSpec and ServiceIntentSpec interfaces all extend the IntentSpec interface, but add a bound to the type parameter of the class. You should use them when defining the intent spec of an Activity , BroadcastReceiver or Service .","title":"IntentSpec interfaces"},{"location":"2/intents/#intentspec-implementations-providers","text":"A few methods provide implementation of the interfaces mentioned above: * activitySpec * activityWithoutExtrasSpec where ExtrasSpec is Nothing * receiverSpec * receiverWithoutExtrasSpec where ExtrasSpec is Nothing * serviceSpec * serviceWithoutExtrasSpec where ExtrasSpec is Nothing They are designed to be used with by . Examples: * companion object : ActivityIntentSpec<ProductDetailsActivity, ExtrasSpec> by activitySpec(ExtrasSpec) * companion object : BroadcastReceiverIntentSpec<NotifDismissReceiver, ExtrasSpec> by receiverSpec(ExtrasSpec)","title":"IntentSpec implementations providers"},{"location":"2/intents/#using-an-intentspec","text":"The intent method is an extension for IntentSpec . It takes a lambda where the receiver is the Intent . The first parameter is the companion object itself so you can access any constant or method defined in it easily. The second parameter of the lambda is optional, it is the extrasSpec. The start method is an extension for Context and for Fragment that takes the target ActivityIntentSpec as its first parameter. It then calls the intent extension function mentioned above, and the optional expected lambda has the same parameters as for intent . Finally, it calls startActivity with the created Intent . The sendBroadcast method is an extension for Context that takes the target BroadcastReceiverIntentSpec as its first parameter. It then calls the intent extension function mentioned above, and the optional expected lambda has the same parameters as for intent . Finally, it calls sendBroadcast with the created Intent .","title":"Using an IntentSpec"},{"location":"2/intents/#intentspec-example","text":"Let\u2019s take the example shown in the Bundle README, adding an IntentSpec to it. Notice the new companion object and how we start the DemoActivity with the proper extras from the StartDemoActivity now. class DemoActivity : AppCompatActivity () { companion object : ActivityIntentSpec < DemoActivity , ExtrasSpec > by activitySpec ( ExtrasSpec ) { const val someText = \"Splitties is great!\" } object ExtrasSpec : BundleSpec () { var showGreetingToast : Boolean by bundle () // Required extra var optionalExtra : String ? by bundleOrNull () // Optional extra } override fun onCreate ( savedInstanceState : Bundle ?) { super . onCreate ( savedInstanceState ) withExtras ( ExtrasSpec ) { // Populates ExtrasSpec with actual extras if ( showGreetingToast ) toast ( android . R . string . ok ) optionalExtras ?. let { longToast ( it ) } } restOfYourCode () } } class StartDemoActivity : AppCompatActivity () { private fun someFunction ( isUserPolite : Boolean = false ) { start ( DemoActivity ) { intentSpec , extrasSpec -> // Magic happens here! extrasSpec . showGreetingToast = isUserPolite extrasSpec . optionalExtra = intentSpec . someText } } }","title":"IntentSpec example"},{"location":"2/intents/#creating-pendingintents-the-clean-and-easy-way","text":"It\u2019s fair to say that the PendingIntent Android API is not designed for Kotlin, and for a reason, it has been there since API level 1, the first Android version. As a result, code using this API is not always the most readable part of a Kotlin codebase. This split provides several extension functions for Intent that return a PendingIntent : * toPendingActivity() * toPendingService() * toPendingForegroundService() , which also works before API 26 * toPendingBroadcast() and an extension for Array<Intent> : toPendingActivities() . All these functions have two optional parameters that default to zero: reqCode and flags . The toPendingActivity() and toPendingActivities() functions also have an options: Bundle? parameter that defaults to null (and is ignored below API 16).","title":"Creating PendingIntents the clean and easy way"},{"location":"2/intents/#download","text":"implementation \"com.louiscad.splitties:splitties-intents:2.1.1\"","title":"Download"},{"location":"2/mainhandler/","text":"Main Handler \u00b6 Top-level mainHandler property to stop allocating multiple Handler s for main Looper . If the sentence above is not clear enough or if you need more explanations, please open an issue. Download \u00b6 implementation \"com.louiscad.splitties:splitties-mainhandler:2.1.1\"","title":"mainhandler"},{"location":"2/mainhandler/#main-handler","text":"Top-level mainHandler property to stop allocating multiple Handler s for main Looper . If the sentence above is not clear enough or if you need more explanations, please open an issue.","title":"Main Handler"},{"location":"2/mainhandler/#download","text":"implementation \"com.louiscad.splitties:splitties-mainhandler:2.1.1\"","title":"Download"},{"location":"2/mainthread/","text":"Main Thread \u00b6 Properties and precondition checkers related to Android main thread. Content \u00b6 This split provides several properties related to Android main Thread and 2 precondition checkers. Here\u2019s the list: mainLooper : Shortcut to Looper.getMainLooper()!! with caching. mainThread : Shortcut to Looper.getMainLooper()!!.thread with caching. isMainThread : Boolean property that is true if the current Thread is the main Thread. checkMainThread() : Throws an IllegalStateException if not run on the main Thread. checkNotMainThread() : Throws an IllegalStateException if run on the main Thread. Download \u00b6 implementation \"com.louiscad.splitties:splitties-mainthread:2.1.1\"","title":"mainthread"},{"location":"2/mainthread/#main-thread","text":"Properties and precondition checkers related to Android main thread.","title":"Main Thread"},{"location":"2/mainthread/#content","text":"This split provides several properties related to Android main Thread and 2 precondition checkers. Here\u2019s the list: mainLooper : Shortcut to Looper.getMainLooper()!! with caching. mainThread : Shortcut to Looper.getMainLooper()!!.thread with caching. isMainThread : Boolean property that is true if the current Thread is the main Thread. checkMainThread() : Throws an IllegalStateException if not run on the main Thread. checkNotMainThread() : Throws an IllegalStateException if run on the main Thread.","title":"Content"},{"location":"2/mainthread/#download","text":"implementation \"com.louiscad.splitties:splitties-mainthread:2.1.1\"","title":"Download"},{"location":"2/material-colors/","text":"Material Colors \u00b6 2014 Material Design color palettes as color resources. Content \u00b6 This split contains color resources for all the colors referenced in the Material Design guidelines before 2018 change (which added a material palette generator). Examples: \u00b6 Red 500: R.color.red_500 / @color/red_500 Cyan accent 400: R.color.cyan_a400 / @color/cyan_a400 Download \u00b6 implementation \"com.louiscad.splitties:splitties-material-colors:2.1.1\"","title":"material-colors"},{"location":"2/material-colors/#material-colors","text":"2014 Material Design color palettes as color resources.","title":"Material Colors"},{"location":"2/material-colors/#content","text":"This split contains color resources for all the colors referenced in the Material Design guidelines before 2018 change (which added a material palette generator).","title":"Content"},{"location":"2/material-colors/#examples","text":"Red 500: R.color.red_500 / @color/red_500 Cyan accent 400: R.color.cyan_a400 / @color/cyan_a400","title":"Examples:"},{"location":"2/material-colors/#download","text":"implementation \"com.louiscad.splitties:splitties-material-colors:2.1.1\"","title":"Download"},{"location":"2/material-lists/","text":"Material Lists \u00b6 List item Views implementing Material Design guidelines (perfect for usage in a RecyclerView ). This split provides Android View s that are the implementation for most of the lists components and the lists controls from Material Design guidelines. Here\u2019s the list of the list item View implementations currently included in this module: * IconOneLineListItem * IconTwoLinesListItem * IconTwoLinesSwitchListItem * SwitchTwoLinesIconListItem Feel free to open an issue if you need the implementation of a list item that is not in this library yet, or feel one can be improved. If so, pull requests are welcome as long as the code style is kept intact (you can debate about it in an issue if you feel there\u2019s room for improvement). See an example in the sample module . Download \u00b6 implementation \"com.louiscad.splitties:splitties-material-lists:2.1.1\"","title":"material-lists"},{"location":"2/material-lists/#material-lists","text":"List item Views implementing Material Design guidelines (perfect for usage in a RecyclerView ). This split provides Android View s that are the implementation for most of the lists components and the lists controls from Material Design guidelines. Here\u2019s the list of the list item View implementations currently included in this module: * IconOneLineListItem * IconTwoLinesListItem * IconTwoLinesSwitchListItem * SwitchTwoLinesIconListItem Feel free to open an issue if you need the implementation of a list item that is not in this library yet, or feel one can be improved. If so, pull requests are welcome as long as the code style is kept intact (you can debate about it in an issue if you feel there\u2019s room for improvement). See an example in the sample module .","title":"Material Lists"},{"location":"2/material-lists/#download","text":"implementation \"com.louiscad.splitties:splitties-material-lists:2.1.1\"","title":"Download"},{"location":"2/preferences/","text":"Preferences \u00b6 Property syntax for Android\u2019s SharedPreferences. This library uses Kotlin\u2019s property delegation to make using SharedPreferences as easy as accessing a property on an object. It relies on the appCtx module of this library to allow usage in object , and can support storage on device encrypted storage for devices supporting Direct Boot. See the source code for more information. Table of contents \u00b6 Defining the preferences properties in an object Why object and not class ? Loading the preferences without blocking the main thread Download Defining the preferences properties in an object \u00b6 Define your preferences in an object that extends splitties.preferences.Preferences , like in the example below: import splitties.preferences.Preferences object GamePreferences : Preferences ( \"gameState\" ) { var magicNumber by intPref ( 0 ) // The property name is used as the key. var currentLevel by IntPref ( \"currentLevel\" , 1 ) var bossesFought by IntPref ( \"bossBattleVictories\" , 0 ) var lastTimePlayed by LongPref ( \"lastSessionTime\" , 0L ) var pseudo by StringPref ( \"playerPseudo\" , \"Player 1\" ) var favoriteCharacter by stringOrNullPref () } Then just use the properties: fun setResponseOfTheUltimateQuestionOfLifeTheUniverseAndEverything () { GamePreferences . magicNumber = 42 } fun doSomeMagic () { toast ( \"Magic: ${GamePreferences.magicNumber}!\" ) } fun resetProgress () { GamePreferences . edit { // Batch edit currentLevel = 1 bossesFought = 0 } } The supported types are: * Boolean * Int * Float * Long * String * String? * Set<String> * Set<String>? For default SharedPreferences , make an object that extends DefaultPreferences instead of Preferences . Why object and not class ? \u00b6 Unless you use coroutines (read more about this in next section just below), a class instead of an object is not recommended because it would mean you can instantiate it multiple times, while the underlying preferences xml file is cached for the rest of your app\u2019s process lifetime once loaded, so in a class you\u2019d be allocating the delegates more times than needed, leading to an additional, unneeded, small pressure on the garbage collector. However, you may make an abstract subclass of Preferences for specific use cases where adding logic to base Preferences or sharing some properties may be desirable. (If you do, please open an issue to tell us about this use case. It may become an example shown here.) Loading the preferences without blocking the main thread \u00b6 The object approach described above has several advantages, one of the most significant being ease of use anywhere in your app, but that also means you can easily access it from the main thread, and the first time you access the object, the underlying xml file where the preferences are stored is loaded, which may block the main thread for longer that you would want, possibly dropping a few frames. With coroutines, it\u2019s easy to offload something on another thread, and this split embraces this capability. Let\u2019s see a modified version of the GamePreferences described above, before passing in review each change. import splitties.preferences.SuspendPrefsAccessor import splitties.preferences.Preferences class GamePreferences private constructor () : Preferences ( \"gameState\" ) { companion object : SuspendPrefsAccessor < GamePreferences >( :: GamePreferences ) var magicNumber by intPref ( 0 ) // The property name is used as the key. var currentLevel by IntPref ( \"currentLevel\" , 1 ) var bossesFought by IntPref ( \"bossBattleVictories\" , 0 ) var lastTimePlayed by LongPref ( \"lastSessionTime\" , 0L ) var pseudo by StringPref ( \"playerPseudo\" , \"Player 1\" ) var favoriteCharacter by stringOrNullPref () } Here are all the changes: - We moved from object to class . - We added a private constructor() . - We added a companion object that extends the SuspendPrefsAccessor abstract class and calls its constructor with a reference to the constructor. With this change, we can no longer access the GamePreferences singleton directly from anywhere\u2026 unless we are in a coroutine! From any suspend function, you just have to call GamePreferences() like you were calling a constructor, but in reality, it is a function call that suspends while loading the preferences for the first time in process life in Dispatchers.IO . If the preferences have already been loaded, it immediately returns the now instantiated singleton. If you have non suspending functions that would need to access the preferences, you have two options: pass your Preferences subclass as a parameter, or make it a suspend function. Download \u00b6 implementation \"com.louiscad.splitties:splitties-preferences:2.1.1\"","title":"preferences"},{"location":"2/preferences/#preferences","text":"Property syntax for Android\u2019s SharedPreferences. This library uses Kotlin\u2019s property delegation to make using SharedPreferences as easy as accessing a property on an object. It relies on the appCtx module of this library to allow usage in object , and can support storage on device encrypted storage for devices supporting Direct Boot. See the source code for more information.","title":"Preferences"},{"location":"2/preferences/#table-of-contents","text":"Defining the preferences properties in an object Why object and not class ? Loading the preferences without blocking the main thread Download","title":"Table of contents"},{"location":"2/preferences/#defining-the-preferences-properties-in-an-object","text":"Define your preferences in an object that extends splitties.preferences.Preferences , like in the example below: import splitties.preferences.Preferences object GamePreferences : Preferences ( \"gameState\" ) { var magicNumber by intPref ( 0 ) // The property name is used as the key. var currentLevel by IntPref ( \"currentLevel\" , 1 ) var bossesFought by IntPref ( \"bossBattleVictories\" , 0 ) var lastTimePlayed by LongPref ( \"lastSessionTime\" , 0L ) var pseudo by StringPref ( \"playerPseudo\" , \"Player 1\" ) var favoriteCharacter by stringOrNullPref () } Then just use the properties: fun setResponseOfTheUltimateQuestionOfLifeTheUniverseAndEverything () { GamePreferences . magicNumber = 42 } fun doSomeMagic () { toast ( \"Magic: ${GamePreferences.magicNumber}!\" ) } fun resetProgress () { GamePreferences . edit { // Batch edit currentLevel = 1 bossesFought = 0 } } The supported types are: * Boolean * Int * Float * Long * String * String? * Set<String> * Set<String>? For default SharedPreferences , make an object that extends DefaultPreferences instead of Preferences .","title":"Defining the preferences properties in an object"},{"location":"2/preferences/#why-object-and-not-class","text":"Unless you use coroutines (read more about this in next section just below), a class instead of an object is not recommended because it would mean you can instantiate it multiple times, while the underlying preferences xml file is cached for the rest of your app\u2019s process lifetime once loaded, so in a class you\u2019d be allocating the delegates more times than needed, leading to an additional, unneeded, small pressure on the garbage collector. However, you may make an abstract subclass of Preferences for specific use cases where adding logic to base Preferences or sharing some properties may be desirable. (If you do, please open an issue to tell us about this use case. It may become an example shown here.)","title":"Why object and not class?"},{"location":"2/preferences/#loading-the-preferences-without-blocking-the-main-thread","text":"The object approach described above has several advantages, one of the most significant being ease of use anywhere in your app, but that also means you can easily access it from the main thread, and the first time you access the object, the underlying xml file where the preferences are stored is loaded, which may block the main thread for longer that you would want, possibly dropping a few frames. With coroutines, it\u2019s easy to offload something on another thread, and this split embraces this capability. Let\u2019s see a modified version of the GamePreferences described above, before passing in review each change. import splitties.preferences.SuspendPrefsAccessor import splitties.preferences.Preferences class GamePreferences private constructor () : Preferences ( \"gameState\" ) { companion object : SuspendPrefsAccessor < GamePreferences >( :: GamePreferences ) var magicNumber by intPref ( 0 ) // The property name is used as the key. var currentLevel by IntPref ( \"currentLevel\" , 1 ) var bossesFought by IntPref ( \"bossBattleVictories\" , 0 ) var lastTimePlayed by LongPref ( \"lastSessionTime\" , 0L ) var pseudo by StringPref ( \"playerPseudo\" , \"Player 1\" ) var favoriteCharacter by stringOrNullPref () } Here are all the changes: - We moved from object to class . - We added a private constructor() . - We added a companion object that extends the SuspendPrefsAccessor abstract class and calls its constructor with a reference to the constructor. With this change, we can no longer access the GamePreferences singleton directly from anywhere\u2026 unless we are in a coroutine! From any suspend function, you just have to call GamePreferences() like you were calling a constructor, but in reality, it is a function call that suspends while loading the preferences for the first time in process life in Dispatchers.IO . If the preferences have already been loaded, it immediately returns the now instantiated singleton. If you have non suspending functions that would need to access the preferences, you have two options: pass your Preferences subclass as a parameter, or make it a suspend function.","title":"Loading the preferences without blocking the main thread"},{"location":"2/preferences/#download","text":"implementation \"com.louiscad.splitties:splitties-preferences:2.1.1\"","title":"Download"},{"location":"2/resources/","text":"Resources \u00b6 Extensions to get resources like strings, colors or drawables easily, with support for themed attributes. Content \u00b6 All the extensions of this module are currently available on Context , Fragment and View types. Each one also has an app prefixed version (e.g. appColor(\u2026) ) that is available everywhere but only returns the resources using the application Context, which means they will not use the theme of the current Activity. Colors \u00b6 color(\u2026) takes a color resource id and returns a color Int colorSL(\u2026) takes a color resource id and returns a ColorStateList styledColor(\u2026) takes a color theme attribute and returns a Int styledColorSL(\u2026) takes a color theme attribute and returns a ColorStateList Example \u00b6 val brandPrimaryColor = color ( R . color . brand_primary ) val accentColor = styledColor ( R . attr . colorAccent ) Dimensions \u00b6 dimen(\u2026) takes a dimension resource id and returns its Float value dimenPxSize(\u2026) takes a dimension resource id and returns its rounded Int value dimenPxOffset(\u2026) takes a dimension resource id and returns its truncated Int value Like for colors , there are styled prefixed versions that take a theme attribute. Drawables \u00b6 drawable(\u2026) takes a drawable resource id and returns a Drawable? styledDrawable(\u2026) takes a drawable theme attribute and returns a Drawable? Primitives \u00b6 bool(\u2026) takes a boolean resource id and returns its Boolean value int(\u2026) takes an integer resource id and returns its Int value intArray(\u2026) takes an integer array resource id and returns an IntArray There are styledBool and styledInt that take a theme attribute. Text \u00b6 txt(\u2026) takes a string resource id and returns a CharSequence str(\u2026) takes a string resource id and returns a String . There\u2019s also optional format arguments. qtyTxt(\u2026) (for plurals) returns a CharSequence qtyStr(\u2026) (for plurals) returns a String . There\u2019s also optional format arguments. txtArray(\u2026) takes an array resource id and returns an Array<out CharSequence> strArray(\u2026) takes an array resource id and returns an Array<String> styledTxt(\u2026) takes a string theme attribute and returns a CharSequence? styledStr(\u2026) takes a string theme attribute and returns a String? There\u2019s also optional format arguments. styledTxtArray(\u2026) takes an array theme attribute and returns an Array<out CharSequence>? Download \u00b6 implementation \"com.louiscad.splitties:splitties-resources:2.1.1\"","title":"resources"},{"location":"2/resources/#resources","text":"Extensions to get resources like strings, colors or drawables easily, with support for themed attributes.","title":"Resources"},{"location":"2/resources/#content","text":"All the extensions of this module are currently available on Context , Fragment and View types. Each one also has an app prefixed version (e.g. appColor(\u2026) ) that is available everywhere but only returns the resources using the application Context, which means they will not use the theme of the current Activity.","title":"Content"},{"location":"2/resources/#colors","text":"color(\u2026) takes a color resource id and returns a color Int colorSL(\u2026) takes a color resource id and returns a ColorStateList styledColor(\u2026) takes a color theme attribute and returns a Int styledColorSL(\u2026) takes a color theme attribute and returns a ColorStateList","title":"Colors"},{"location":"2/resources/#example","text":"val brandPrimaryColor = color ( R . color . brand_primary ) val accentColor = styledColor ( R . attr . colorAccent )","title":"Example"},{"location":"2/resources/#dimensions","text":"dimen(\u2026) takes a dimension resource id and returns its Float value dimenPxSize(\u2026) takes a dimension resource id and returns its rounded Int value dimenPxOffset(\u2026) takes a dimension resource id and returns its truncated Int value Like for colors , there are styled prefixed versions that take a theme attribute.","title":"Dimensions"},{"location":"2/resources/#drawables","text":"drawable(\u2026) takes a drawable resource id and returns a Drawable? styledDrawable(\u2026) takes a drawable theme attribute and returns a Drawable?","title":"Drawables"},{"location":"2/resources/#primitives","text":"bool(\u2026) takes a boolean resource id and returns its Boolean value int(\u2026) takes an integer resource id and returns its Int value intArray(\u2026) takes an integer array resource id and returns an IntArray There are styledBool and styledInt that take a theme attribute.","title":"Primitives"},{"location":"2/resources/#text","text":"txt(\u2026) takes a string resource id and returns a CharSequence str(\u2026) takes a string resource id and returns a String . There\u2019s also optional format arguments. qtyTxt(\u2026) (for plurals) returns a CharSequence qtyStr(\u2026) (for plurals) returns a String . There\u2019s also optional format arguments. txtArray(\u2026) takes an array resource id and returns an Array<out CharSequence> strArray(\u2026) takes an array resource id and returns an Array<String> styledTxt(\u2026) takes a string theme attribute and returns a CharSequence? styledStr(\u2026) takes a string theme attribute and returns a String? There\u2019s also optional format arguments. styledTxtArray(\u2026) takes an array theme attribute and returns an Array<out CharSequence>?","title":"Text"},{"location":"2/resources/#download","text":"implementation \"com.louiscad.splitties:splitties-resources:2.1.1\"","title":"Download"},{"location":"2/sample/","text":"Splitties Sample \u00b6","title":"sample"},{"location":"2/sample/#splitties-sample","text":"","title":"Splitties Sample"},{"location":"2/snackbar/","text":"Snackbar \u00b6 Grab a snack without ceremony with snack(\u2026) and longSnack(\u2026) This split provides extensions to show a Snackbar , boilerplate free. It also has a small extension functions based DSL to add an action and execute action on dismiss. Usage \u00b6 On a CoordinatorLayout , call snack(\u2026) , longSnack(\u2026) (if you\u2019re really hungry), or snackForever(\u2026) for an indefinite duration, with a string resource id, or a CharSequence . You can add optional braces to access the Snackbar instance before it is shown, so you can add an action (using action(\u2026) { \u2026 } ) and add callback for dismissal (using onDismiss(\u2026) ). Note that snackbar(\u2026) , longSnack(\u2026) and snackForever(\u2026) return the created Snackbar instance. That means you can as well add onDismiss(\u2026) on the result of the call instead of inside the optional inline lambda. Download \u00b6 implementation \"com.louiscad.splitties:splitties-snackbar:2.1.1\"","title":"snackbar"},{"location":"2/snackbar/#snackbar","text":"Grab a snack without ceremony with snack(\u2026) and longSnack(\u2026) This split provides extensions to show a Snackbar , boilerplate free. It also has a small extension functions based DSL to add an action and execute action on dismiss.","title":"Snackbar"},{"location":"2/snackbar/#usage","text":"On a CoordinatorLayout , call snack(\u2026) , longSnack(\u2026) (if you\u2019re really hungry), or snackForever(\u2026) for an indefinite duration, with a string resource id, or a CharSequence . You can add optional braces to access the Snackbar instance before it is shown, so you can add an action (using action(\u2026) { \u2026 } ) and add callback for dismissal (using onDismiss(\u2026) ). Note that snackbar(\u2026) , longSnack(\u2026) and snackForever(\u2026) return the created Snackbar instance. That means you can as well add onDismiss(\u2026) on the result of the call instead of inside the optional inline lambda.","title":"Usage"},{"location":"2/snackbar/#download","text":"implementation \"com.louiscad.splitties:splitties-snackbar:2.1.1\"","title":"Download"},{"location":"2/stetho-init/","text":"Stetho Init \u00b6 Have Stetho for your debug builds, without writing any code! This library uses an InitProvider (like appCtx , and similarly to Firebase) to initialize Stetho automatically. You just have to include the dependency on your debug build and voil\u00e0! Usage \u00b6 Add the dependency to your debug build like in the example below: debugImplementation \"com.louiscad.splitties:splitties-stetho-init:2.1.1\" Assuming your Android device is visible from adb on your computer, you can now navigate to chrome://inspect to see your updated debug app in Chrome Dev Tools, no further configuration required. Download \u00b6 debugImplementation \"com.louiscad.splitties:splitties-stetho-init:2.1.1\"","title":"stetho-init"},{"location":"2/stetho-init/#stetho-init","text":"Have Stetho for your debug builds, without writing any code! This library uses an InitProvider (like appCtx , and similarly to Firebase) to initialize Stetho automatically. You just have to include the dependency on your debug build and voil\u00e0!","title":"Stetho Init"},{"location":"2/stetho-init/#usage","text":"Add the dependency to your debug build like in the example below: debugImplementation \"com.louiscad.splitties:splitties-stetho-init:2.1.1\" Assuming your Android device is visible from adb on your computer, you can now navigate to chrome://inspect to see your updated debug app in Chrome Dev Tools, no further configuration required.","title":"Usage"},{"location":"2/stetho-init/#download","text":"debugImplementation \"com.louiscad.splitties:splitties-stetho-init:2.1.1\"","title":"Download"},{"location":"2/systemservices/","text":"System Services \u00b6 No more context.getSystemService(NAME_OF_SERVICE) as NameOfManager . This library contains all the Android System Services as of API 27. It allows accessing them with a simple property. Most System Services use the application Context and are available anywhere in the code of your app, but some that can vary depending on the Context (like LayoutInflater or WindowManager ) are extensions on Context , View or AccessibilityService . Example \u00b6 Before: fun performSomeVibration ( vibe : VibrationEffect ) { val vibrator = context . getSystemService ( VIBRATOR_SERVICE ) as Vibrator vibrator . vibrate ( vibe ) } After: fun performSomeVibration ( vibe : VibrationEffect ) { vibrator . vibrate ( vibe ) } Download \u00b6 implementation \"com.louiscad.splitties:splitties-systemservices:2.1.1\"","title":"systemservices"},{"location":"2/systemservices/#system-services","text":"No more context.getSystemService(NAME_OF_SERVICE) as NameOfManager . This library contains all the Android System Services as of API 27. It allows accessing them with a simple property. Most System Services use the application Context and are available anywhere in the code of your app, but some that can vary depending on the Context (like LayoutInflater or WindowManager ) are extensions on Context , View or AccessibilityService .","title":"System Services"},{"location":"2/systemservices/#example","text":"Before: fun performSomeVibration ( vibe : VibrationEffect ) { val vibrator = context . getSystemService ( VIBRATOR_SERVICE ) as Vibrator vibrator . vibrate ( vibe ) } After: fun performSomeVibration ( vibe : VibrationEffect ) { vibrator . vibrate ( vibe ) }","title":"Example"},{"location":"2/systemservices/#download","text":"implementation \"com.louiscad.splitties:splitties-systemservices:2.1.1\"","title":"Download"},{"location":"2/toast/","text":"Toast \u00b6 Show a toast by just calling toast(yourText) , and dodge API 25 BadTokenException . To create and show a Toast , just call toast(\u2026) (for breakfast) or longToast(\u2026) (for breakslow) with either a string resource id or a CharSequence . Download \u00b6 implementation \"com.louiscad.splitties:splitties-toast:2.1.1\"","title":"toast"},{"location":"2/toast/#toast","text":"Show a toast by just calling toast(yourText) , and dodge API 25 BadTokenException . To create and show a Toast , just call toast(\u2026) (for breakfast) or longToast(\u2026) (for breakslow) with either a string resource id or a CharSequence .","title":"Toast"},{"location":"2/toast/#download","text":"implementation \"com.louiscad.splitties:splitties-toast:2.1.1\"","title":"Download"},{"location":"2/typesaferecyclerview/","text":"Typesafe RecyclerView \u00b6 Typesafe ViewHolder and ItemViewHolder for easy basic usage of RecyclerView . This modules consists of two ViewHolder subclasses that make it typesafe, and easier to use for the common use case which is to bind a ViewHolder to a POJO (plain-old Java Object ) or a POKA (plain-old Kotlin Any ). See the sample to understand how it works. Usage \u00b6 When using ViewHolder , use the one from Splitties to get the typesafe one. See it in action in the sample: DemoAdapter . Download \u00b6 implementation \"com.louiscad.splitties:splitties-typesaferecyclerview:2.1.1\"","title":"typesaferecyclerview"},{"location":"2/typesaferecyclerview/#typesafe-recyclerview","text":"Typesafe ViewHolder and ItemViewHolder for easy basic usage of RecyclerView . This modules consists of two ViewHolder subclasses that make it typesafe, and easier to use for the common use case which is to bind a ViewHolder to a POJO (plain-old Java Object ) or a POKA (plain-old Kotlin Any ). See the sample to understand how it works.","title":"Typesafe RecyclerView"},{"location":"2/typesaferecyclerview/#usage","text":"When using ViewHolder , use the one from Splitties to get the typesafe one. See it in action in the sample: DemoAdapter .","title":"Usage"},{"location":"2/typesaferecyclerview/#download","text":"implementation \"com.louiscad.splitties:splitties-typesaferecyclerview:2.1.1\"","title":"Download"},{"location":"2/views-appcompat/","text":"Views AppCompat \u00b6 AppCompat extension of Views Content \u00b6 Tooltip helpers \u00b6 tooltipTxt allows to set a tooltip text on any View using property syntax even on pre-O devices (using AndroidX\u2019s TooltipCompat in these cases). The contentDescAsTooltip() extension function for View takes the content description of your view (used for accessibility) and sets it as the tooltip text so users can long press or hover on the view and see what it is. ImageView tinting \u00b6 The imgTintList and imgTintMode extension properties for ImageView are the same as imageTintList and imageTintMode \u2026 except they work before API 21 because they delegate to AndroidX\u2019s ImageViewCompat . ActionBar extensions \u00b6 The configActionBar { \u2026 } extension function for AppCompatActivity allows to easily setup the supportActionBar . If it is null, the passed lambda is ignored, and an AssertionError is logged. The write only showTitle , showHome , showHomeAsUp , useLogo and showCustomView boolean extension properties are meant to be used on an Actionbar (usually inside the configActionBar { \u2026 } lambda). They are more readable than the setDisplayHomeAsUpEnabled and alike methods. Config changes handling Toolbar \u00b6 AppCompat Toolbar from AndroidX has different dimensions and text sizes for portrait and landscape modes, but they are not updated when the configuration changes. splitties.views.appcompat.Toolbar extends it and updates it when configuration changes so you can avoid restarting your Activity when the device rotates, goes into multi-window mode or undergoes any other window size related config change if the rest of your content handles this without needing to be recreated. Download \u00b6 implementation \"com.louiscad.splitties:splitties-views-appcompat:2.1.1\"","title":"views-appcompat"},{"location":"2/views-appcompat/#views-appcompat","text":"AppCompat extension of Views","title":"Views AppCompat"},{"location":"2/views-appcompat/#content","text":"","title":"Content"},{"location":"2/views-appcompat/#tooltip-helpers","text":"tooltipTxt allows to set a tooltip text on any View using property syntax even on pre-O devices (using AndroidX\u2019s TooltipCompat in these cases). The contentDescAsTooltip() extension function for View takes the content description of your view (used for accessibility) and sets it as the tooltip text so users can long press or hover on the view and see what it is.","title":"Tooltip helpers"},{"location":"2/views-appcompat/#imageview-tinting","text":"The imgTintList and imgTintMode extension properties for ImageView are the same as imageTintList and imageTintMode \u2026 except they work before API 21 because they delegate to AndroidX\u2019s ImageViewCompat .","title":"ImageView tinting"},{"location":"2/views-appcompat/#actionbar-extensions","text":"The configActionBar { \u2026 } extension function for AppCompatActivity allows to easily setup the supportActionBar . If it is null, the passed lambda is ignored, and an AssertionError is logged. The write only showTitle , showHome , showHomeAsUp , useLogo and showCustomView boolean extension properties are meant to be used on an Actionbar (usually inside the configActionBar { \u2026 } lambda). They are more readable than the setDisplayHomeAsUpEnabled and alike methods.","title":"ActionBar extensions"},{"location":"2/views-appcompat/#config-changes-handling-toolbar","text":"AppCompat Toolbar from AndroidX has different dimensions and text sizes for portrait and landscape modes, but they are not updated when the configuration changes. splitties.views.appcompat.Toolbar extends it and updates it when configuration changes so you can avoid restarting your Activity when the device rotates, goes into multi-window mode or undergoes any other window size related config change if the rest of your content handles this without needing to be recreated.","title":"Config changes handling Toolbar"},{"location":"2/views-appcompat/#download","text":"implementation \"com.louiscad.splitties:splitties-views-appcompat:2.1.1\"","title":"Download"},{"location":"2/views-cardview/","text":"Views CardView \u00b6 CardView extension of Views Content \u00b6 contentPadding allows to set the padding of the content of a CardView using property syntax. This is all this split provides at the moment. Download \u00b6 implementation \"com.louiscad.splitties:splitties-views-cardview:2.1.1\"","title":"views-cardview"},{"location":"2/views-cardview/#views-cardview","text":"CardView extension of Views","title":"Views CardView"},{"location":"2/views-cardview/#content","text":"contentPadding allows to set the padding of the content of a CardView using property syntax. This is all this split provides at the moment.","title":"Content"},{"location":"2/views-cardview/#download","text":"implementation \"com.louiscad.splitties:splitties-views-cardview:2.1.1\"","title":"Download"},{"location":"2/views-design/","text":"Views Design \u00b6 Design Support library extension of Views . Content \u00b6 CollapsingToolbarLayout extensions \u00b6 contentScrimColor allows to set the content scrim color of a CollapsingToolbarLayout using property syntax. TextInputLayout extensions \u00b6 The text read/write extension property for TextInputLayout is an alias to the text property of the child EditText . The string read only extension property for TextInputLayout allows to easily get the String (immutable) representation of the text of the child EditText . Download \u00b6 implementation \"com.louiscad.splitties:splitties-views-design:2.1.1\"","title":"views-design"},{"location":"2/views-design/#views-design","text":"Design Support library extension of Views .","title":"Views Design"},{"location":"2/views-design/#content","text":"","title":"Content"},{"location":"2/views-design/#collapsingtoolbarlayout-extensions","text":"contentScrimColor allows to set the content scrim color of a CollapsingToolbarLayout using property syntax.","title":"CollapsingToolbarLayout extensions"},{"location":"2/views-design/#textinputlayout-extensions","text":"The text read/write extension property for TextInputLayout is an alias to the text property of the child EditText . The string read only extension property for TextInputLayout allows to easily get the String (immutable) representation of the text of the child EditText .","title":"TextInputLayout extensions"},{"location":"2/views-design/#download","text":"implementation \"com.louiscad.splitties:splitties-views-design:2.1.1\"","title":"Download"},{"location":"2/views-dsl-appcompat/","text":"Views DSL AppCompat \u00b6 AppCompat extension of Views DSL How AppCompat works with xml \u00b6 When using an AppCompat theme, the LayoutInflater replaces the platform widgets like TextView and Button found in your xml layouts by a compatibility version (i.e. AppCompatButton , AppCompatTextView , etc.). If you\u2019re curious to see how it works, look for the method createView in the AppCompatViewInflater class from the android.support.v7.app package. How AppCompat works with Splitties Views DSL \u00b6 Since the LayoutInflater only works on xml, if you use view(::Button) with Views DSL, you get a Button instance, not an AppCompatButton instance. This means it will not have AppCompat features and styling. However, if you use button() , or v<Button>() , it will automatically delegate to this split if in the dependencies, returning an AppCompatButton instance. This works for all AppCompat widgets. Supported widgets \u00b6 All AppCompat widgets are supported as of version 27.1.1 of the support library. Here\u2019s the full list: * TextView * ImageView * Button * EditText * Spinner * ImageButton * CheckBox * RadioButton * CheckedTextView * AutoCompleteTextView * MultiAutoCompleteTextView * RatingBar * SeekBar Just call the related method that is the camelCase version of the PascalCase constructor. For example, you can call seekBar(\u2026) { \u2026 } and you\u2019ll receive an AppCompatSeekBar instance. As an alternative, you can also use these types with the reified type parameter version of v , like v<Spinner>() , and you\u2019ll automatically get the AppCompat version! In fact, that\u2019s what the more specialized inline functions like button do under the \u201chood\u201d. Note that automatically doesn\u2019t mean magically. In fact, no reflection is involved (contrary to xml inflation). You can also see the source of the function that maps to AppCompat widgets versions , and the InitProvider that makes it zero initialization on your side . There\u2019s also support for Toolbar with the toolbar function, and SwitchCompat with the switch function. Note that the returned Toolbar handles config changes. Multi-process apps \u00b6 If your app needs to use AppCompat themed widgets in the non default process, you\u2019ll need to manually setup ViewFactory so it uses AppCompat. Here\u2019s how you need to it: Copy paste this InitProvider into a package of an android library/app module of your project, then declare it in the AndroidManifest.xml of the module exactly like it is done here . To do so, copy paste it, then fix the package of the class under the android:name xml attribute of the provider tag, then specify the android:process value to the one of your non default process. Be sure to test it to make sure you have set it up properly. Download \u00b6 implementation \"com.louiscad.splitties:splitties-views-dsl-appcompat:2.1.1\"","title":"views-dsl-appcompat"},{"location":"2/views-dsl-appcompat/#views-dsl-appcompat","text":"AppCompat extension of Views DSL","title":"Views DSL AppCompat"},{"location":"2/views-dsl-appcompat/#how-appcompat-works-with-xml","text":"When using an AppCompat theme, the LayoutInflater replaces the platform widgets like TextView and Button found in your xml layouts by a compatibility version (i.e. AppCompatButton , AppCompatTextView , etc.). If you\u2019re curious to see how it works, look for the method createView in the AppCompatViewInflater class from the android.support.v7.app package.","title":"How AppCompat works with xml"},{"location":"2/views-dsl-appcompat/#how-appcompat-works-with-splitties-views-dsl","text":"Since the LayoutInflater only works on xml, if you use view(::Button) with Views DSL, you get a Button instance, not an AppCompatButton instance. This means it will not have AppCompat features and styling. However, if you use button() , or v<Button>() , it will automatically delegate to this split if in the dependencies, returning an AppCompatButton instance. This works for all AppCompat widgets.","title":"How AppCompat works with Splitties Views DSL"},{"location":"2/views-dsl-appcompat/#supported-widgets","text":"All AppCompat widgets are supported as of version 27.1.1 of the support library. Here\u2019s the full list: * TextView * ImageView * Button * EditText * Spinner * ImageButton * CheckBox * RadioButton * CheckedTextView * AutoCompleteTextView * MultiAutoCompleteTextView * RatingBar * SeekBar Just call the related method that is the camelCase version of the PascalCase constructor. For example, you can call seekBar(\u2026) { \u2026 } and you\u2019ll receive an AppCompatSeekBar instance. As an alternative, you can also use these types with the reified type parameter version of v , like v<Spinner>() , and you\u2019ll automatically get the AppCompat version! In fact, that\u2019s what the more specialized inline functions like button do under the \u201chood\u201d. Note that automatically doesn\u2019t mean magically. In fact, no reflection is involved (contrary to xml inflation). You can also see the source of the function that maps to AppCompat widgets versions , and the InitProvider that makes it zero initialization on your side . There\u2019s also support for Toolbar with the toolbar function, and SwitchCompat with the switch function. Note that the returned Toolbar handles config changes.","title":"Supported widgets"},{"location":"2/views-dsl-appcompat/#multi-process-apps","text":"If your app needs to use AppCompat themed widgets in the non default process, you\u2019ll need to manually setup ViewFactory so it uses AppCompat. Here\u2019s how you need to it: Copy paste this InitProvider into a package of an android library/app module of your project, then declare it in the AndroidManifest.xml of the module exactly like it is done here . To do so, copy paste it, then fix the package of the class under the android:name xml attribute of the provider tag, then specify the android:process value to the one of your non default process. Be sure to test it to make sure you have set it up properly.","title":"Multi-process apps"},{"location":"2/views-dsl-appcompat/#download","text":"implementation \"com.louiscad.splitties:splitties-views-dsl-appcompat:2.1.1\"","title":"Download"},{"location":"2/views-dsl-constraintlayout/","text":"Views DSL ConstraintLayout \u00b6 ConstraintLayout extension of Views DSL . Table of contents \u00b6 ConstraintLayout tailored lParams extension ConstraintLayout.LayoutParams extensions for safe and readable usage Download ConstraintLayout tailored lParams extension \u00b6 The lParams() extension function on ConstraintLayout looks to be similar to the similarly named extensions on LinearLayout and FrameLayout , but there are two key differences: * Since ConstraintLayout children are meant to have constraints, their default width and height are matchConstraints , not wrapContent . That means that you\u2019ll often have to specify height = wrapContent for things like TextView s and Button s. * In xml, match_parent is not supported for ConstraintLayout and can decrease performance (the alternative being adding 0dp + 2 parent relative constraints). This is not the case here as matchParent is rewritten as matchConstraints with the appropriate parent relative constraints . The result is a more readable UI code, without performance compromises. ConstraintLayout.LayoutParams extensions for safe and readable usage \u00b6 With this split also comes a set of extension functions to use in lParams(\u2026) { \u2026 } . Center relatively to parent: * centerHorizontally() * centerVertically() * centerInParent() Parent relative constraints: * topOfParent() * bottomOfParent() * startOfParent() * endOfParent() * leftOfParent() * rightOfParent() Center relatively to another View : * alignVerticallyOn(\u2026) * alignHorizontallyOn(\u2026) * centerOn(\u2026) View relative constraints: * topToTopOf(\u2026) * topToBottomOf(\u2026) * bottomToTopOf(\u2026) * bottomToBottomOf(\u2026) * baselineToBaselineOf(\u2026) * startToStartOf(\u2026) * startToEndOf(\u2026) * endToStartOf(\u2026) * endToEndOf(\u2026) * leftToLeftOf(\u2026) * leftToRightOf(\u2026) * rightToRightOf(\u2026) * rightToLeftOf(\u2026) Chains: * horizontalChain(\u2026) { \u2026 } and its companion horizontalMargin extension for List<View> . * verticalChain(\u2026) { \u2026 } and its companion verticalMargin extension for List<View> . These methods come with a great bonus feature: If a View involved in a constraint has no valid id , then a generated one is automatically assigned to it! These generated ids can\u2019t clash with aapt/xml ids, so it\u2019s safe to put xml defined ids on some views that need to have their state saved (e.g. a RecyclerView , an EditText or a CheckBox ) in the same layout. Note that View ids are crucial to ConstraintLayout machinery. Download \u00b6 implementation \"com.louiscad.splitties:splitties-views-dsl-constraintlayout:2.1.1\"","title":"views-dsl-constraintlayout"},{"location":"2/views-dsl-constraintlayout/#views-dsl-constraintlayout","text":"ConstraintLayout extension of Views DSL .","title":"Views DSL ConstraintLayout"},{"location":"2/views-dsl-constraintlayout/#table-of-contents","text":"ConstraintLayout tailored lParams extension ConstraintLayout.LayoutParams extensions for safe and readable usage Download","title":"Table of contents"},{"location":"2/views-dsl-constraintlayout/#constraintlayout-tailored-lparams-extension","text":"The lParams() extension function on ConstraintLayout looks to be similar to the similarly named extensions on LinearLayout and FrameLayout , but there are two key differences: * Since ConstraintLayout children are meant to have constraints, their default width and height are matchConstraints , not wrapContent . That means that you\u2019ll often have to specify height = wrapContent for things like TextView s and Button s. * In xml, match_parent is not supported for ConstraintLayout and can decrease performance (the alternative being adding 0dp + 2 parent relative constraints). This is not the case here as matchParent is rewritten as matchConstraints with the appropriate parent relative constraints . The result is a more readable UI code, without performance compromises.","title":"ConstraintLayout tailored lParams extension"},{"location":"2/views-dsl-constraintlayout/#constraintlayoutlayoutparams-extensions-for-safe-and-readable-usage","text":"With this split also comes a set of extension functions to use in lParams(\u2026) { \u2026 } . Center relatively to parent: * centerHorizontally() * centerVertically() * centerInParent() Parent relative constraints: * topOfParent() * bottomOfParent() * startOfParent() * endOfParent() * leftOfParent() * rightOfParent() Center relatively to another View : * alignVerticallyOn(\u2026) * alignHorizontallyOn(\u2026) * centerOn(\u2026) View relative constraints: * topToTopOf(\u2026) * topToBottomOf(\u2026) * bottomToTopOf(\u2026) * bottomToBottomOf(\u2026) * baselineToBaselineOf(\u2026) * startToStartOf(\u2026) * startToEndOf(\u2026) * endToStartOf(\u2026) * endToEndOf(\u2026) * leftToLeftOf(\u2026) * leftToRightOf(\u2026) * rightToRightOf(\u2026) * rightToLeftOf(\u2026) Chains: * horizontalChain(\u2026) { \u2026 } and its companion horizontalMargin extension for List<View> . * verticalChain(\u2026) { \u2026 } and its companion verticalMargin extension for List<View> . These methods come with a great bonus feature: If a View involved in a constraint has no valid id , then a generated one is automatically assigned to it! These generated ids can\u2019t clash with aapt/xml ids, so it\u2019s safe to put xml defined ids on some views that need to have their state saved (e.g. a RecyclerView , an EditText or a CheckBox ) in the same layout. Note that View ids are crucial to ConstraintLayout machinery.","title":"ConstraintLayout.LayoutParams extensions for safe and readable usage"},{"location":"2/views-dsl-constraintlayout/#download","text":"implementation \"com.louiscad.splitties:splitties-views-dsl-constraintlayout:2.1.1\"","title":"Download"},{"location":"2/views-dsl-design/","text":"Views DSL Design \u00b6 Design Support Library extension of Views DSL Table of contents \u00b6 Functions to instantiate Views and ViewGroups from the Design Support Library Multi-process apps Extensions on ViewGroups from the Design Support Library AppBarLayout extensions defaultLParams Values for scrollFlags CollapsingToolbarLayout extensions defaultLParams actionBarLParams Values for collapseMode CoordinatorLayout extensions defaultLParams appBarLParams contentScrollingWithAppBarLParams() Bottom sheet behavior extensions bottomSheetBehavior Bottom sheet state extensions TextInputLayout helper Download Functions to instantiate Views and ViewGroups from the Design Support Library \u00b6 Instead of using v<AppBarLayout>(\u2026) { \u2026 } and similar, you can use appBarLayout(\u2026) { \u2026 } . All widgets from the Design Support Library are supported. To see the list, check the implementations for Views and ViewGroups . Note that there two bonuses in this split: * When calling appBarLayout(\u2026) { \u2026 } , you get an implementation that fixes a scrolling bug from Design Support Library where first click is ignored. * When calling collapsingToolbarLayout(\u2026) { \u2026 } , you get an implementation that handles config changes. Multi-process apps \u00b6 If your app needs to use AppCompat themed widgets in the non default process, you\u2019ll need to manually setup ViewFactory so it uses AppCompat. Here\u2019s how you need to it: Copy paste this InitProvider into a package of an android library/app module of your project, then declare it in the AndroidManifest.xml of the module exactly like it is done here . To do so, copy paste it, then fix the package of the class under the android:name xml attribute of the provider tag, then specify the android:process value to the one of your non default process. Be sure to test it to make sure you have set it up properly. Extensions on ViewGroups from the Design Support Library \u00b6 AppBarLayout extensions \u00b6 defaultLParams \u00b6 This extension function has a default width of matchParent and a default height of wrapContent so you don\u2019t have to specify them in most of the cases. It also has a scrollFlags parameter which defaults to ENTER_ALWAYS , same as when inflated from an xml layout. Use it when you add a View to an AppBarLayout . Values for scrollFlags \u00b6 SCROLL , EXIT_UNTIL_COLLAPSED , ENTER_ALWAYS , ENTER_ALWAYS_COLLAPSED and SNAP are extension properties on AppBarLayout that are meant to be used as flags (using or if you use multiple ones) with the scrollFlags parameter of the defaultLParams function mentioned above. They are provided for your convenience so they appear in autocomplete when relevant. CollapsingToolbarLayout extensions \u00b6 defaultLParams \u00b6 As for AppBarLayout , this extension function has a default width of matchParent and a default height of wrapContent so you don\u2019t have to specify them in most of the cases. It also has two optional parameters: - collapseMode , which defaults to COLLAPSE_MODE_OFF - parallaxMultiplier , which defaults to 0.5f (default value as of 27.1.1) Use it when you add a View to a CollapsingToolbarLayout . actionBarLParams \u00b6 Similar to defaultLParams , but the height is R.attr.actionBarSize instead of wrapContent . Use it when adding a Toolbar . Values for collapseMode \u00b6 PIN and PARALLAX are extension properties on CollapsingToolbarLayout that are meant to be used for the collapseMode parameter of the defaultLParams and actionBarLParams functions mentioned above. They are provided for your convenience so they appear in autocomplete when relevant. CoordinatorLayout extensions \u00b6 defaultLParams \u00b6 This extension has default width and height set to wrapContent and an optional gravity parameter. appBarLParams \u00b6 Has a matchParent width. Use it when adding an AppBarLayout . contentScrollingWithAppBarLParams() \u00b6 If your CoordinatorLayout has an AppbarLayout and scrolling content (e.g. a RecyclerView ), use this method to add the scrolling content View. It sets an AppBarLayout.ScrollingViewBehavior under the hood. This function accepts an optional config lambda. Bottom sheet behavior extensions \u00b6 bottomSheetBehavior \u00b6 This extension function on Ui that takes an optional initialization lambda creates a BottomSheetBehavior to use on CoordinatorLayout.LayoutParams . Bottom sheet state extensions \u00b6 This split also includes extensions on BottomSheetBehavior : * hidden and expanded : read-write extension properties. * hide() and expand() : extension functions. They make playing with your bottom sheets programmatically a breeze. See their KDoc to see their exact behavior. TextInputLayout helper \u00b6 The addInput extension function on TextInputLayout takes a required id used for the TextInputEditText that it creates and adds to the layout. The id is required so the content of the user input is saved in instance state even if the host Activity is killed by the system. Download \u00b6 implementation \"com.louiscad.splitties:splitties-views-dsl-design:2.1.1\"","title":"views-dsl-design"},{"location":"2/views-dsl-design/#views-dsl-design","text":"Design Support Library extension of Views DSL","title":"Views DSL Design"},{"location":"2/views-dsl-design/#table-of-contents","text":"Functions to instantiate Views and ViewGroups from the Design Support Library Multi-process apps Extensions on ViewGroups from the Design Support Library AppBarLayout extensions defaultLParams Values for scrollFlags CollapsingToolbarLayout extensions defaultLParams actionBarLParams Values for collapseMode CoordinatorLayout extensions defaultLParams appBarLParams contentScrollingWithAppBarLParams() Bottom sheet behavior extensions bottomSheetBehavior Bottom sheet state extensions TextInputLayout helper Download","title":"Table of contents"},{"location":"2/views-dsl-design/#functions-to-instantiate-views-and-viewgroups-from-the-design-support-library","text":"Instead of using v<AppBarLayout>(\u2026) { \u2026 } and similar, you can use appBarLayout(\u2026) { \u2026 } . All widgets from the Design Support Library are supported. To see the list, check the implementations for Views and ViewGroups . Note that there two bonuses in this split: * When calling appBarLayout(\u2026) { \u2026 } , you get an implementation that fixes a scrolling bug from Design Support Library where first click is ignored. * When calling collapsingToolbarLayout(\u2026) { \u2026 } , you get an implementation that handles config changes.","title":"Functions to instantiate Views and ViewGroups from the Design Support Library"},{"location":"2/views-dsl-design/#multi-process-apps","text":"If your app needs to use AppCompat themed widgets in the non default process, you\u2019ll need to manually setup ViewFactory so it uses AppCompat. Here\u2019s how you need to it: Copy paste this InitProvider into a package of an android library/app module of your project, then declare it in the AndroidManifest.xml of the module exactly like it is done here . To do so, copy paste it, then fix the package of the class under the android:name xml attribute of the provider tag, then specify the android:process value to the one of your non default process. Be sure to test it to make sure you have set it up properly.","title":"Multi-process apps"},{"location":"2/views-dsl-design/#extensions-on-viewgroups-from-the-design-support-library","text":"","title":"Extensions on ViewGroups from the Design Support Library"},{"location":"2/views-dsl-design/#appbarlayout-extensions","text":"","title":"AppBarLayout extensions"},{"location":"2/views-dsl-design/#defaultlparams","text":"This extension function has a default width of matchParent and a default height of wrapContent so you don\u2019t have to specify them in most of the cases. It also has a scrollFlags parameter which defaults to ENTER_ALWAYS , same as when inflated from an xml layout. Use it when you add a View to an AppBarLayout .","title":"defaultLParams"},{"location":"2/views-dsl-design/#values-for-scrollflags","text":"SCROLL , EXIT_UNTIL_COLLAPSED , ENTER_ALWAYS , ENTER_ALWAYS_COLLAPSED and SNAP are extension properties on AppBarLayout that are meant to be used as flags (using or if you use multiple ones) with the scrollFlags parameter of the defaultLParams function mentioned above. They are provided for your convenience so they appear in autocomplete when relevant.","title":"Values for scrollFlags"},{"location":"2/views-dsl-design/#collapsingtoolbarlayout-extensions","text":"","title":"CollapsingToolbarLayout extensions"},{"location":"2/views-dsl-design/#defaultlparams_1","text":"As for AppBarLayout , this extension function has a default width of matchParent and a default height of wrapContent so you don\u2019t have to specify them in most of the cases. It also has two optional parameters: - collapseMode , which defaults to COLLAPSE_MODE_OFF - parallaxMultiplier , which defaults to 0.5f (default value as of 27.1.1) Use it when you add a View to a CollapsingToolbarLayout .","title":"defaultLParams"},{"location":"2/views-dsl-design/#actionbarlparams","text":"Similar to defaultLParams , but the height is R.attr.actionBarSize instead of wrapContent . Use it when adding a Toolbar .","title":"actionBarLParams"},{"location":"2/views-dsl-design/#values-for-collapsemode","text":"PIN and PARALLAX are extension properties on CollapsingToolbarLayout that are meant to be used for the collapseMode parameter of the defaultLParams and actionBarLParams functions mentioned above. They are provided for your convenience so they appear in autocomplete when relevant.","title":"Values for collapseMode"},{"location":"2/views-dsl-design/#coordinatorlayout-extensions","text":"","title":"CoordinatorLayout extensions"},{"location":"2/views-dsl-design/#defaultlparams_2","text":"This extension has default width and height set to wrapContent and an optional gravity parameter.","title":"defaultLParams"},{"location":"2/views-dsl-design/#appbarlparams","text":"Has a matchParent width. Use it when adding an AppBarLayout .","title":"appBarLParams"},{"location":"2/views-dsl-design/#contentscrollingwithappbarlparams","text":"If your CoordinatorLayout has an AppbarLayout and scrolling content (e.g. a RecyclerView ), use this method to add the scrolling content View. It sets an AppBarLayout.ScrollingViewBehavior under the hood. This function accepts an optional config lambda.","title":"contentScrollingWithAppBarLParams()"},{"location":"2/views-dsl-design/#bottom-sheet-behavior-extensions","text":"","title":"Bottom sheet behavior extensions"},{"location":"2/views-dsl-design/#bottomsheetbehavior","text":"This extension function on Ui that takes an optional initialization lambda creates a BottomSheetBehavior to use on CoordinatorLayout.LayoutParams .","title":"bottomSheetBehavior"},{"location":"2/views-dsl-design/#bottom-sheet-state-extensions","text":"This split also includes extensions on BottomSheetBehavior : * hidden and expanded : read-write extension properties. * hide() and expand() : extension functions. They make playing with your bottom sheets programmatically a breeze. See their KDoc to see their exact behavior.","title":"Bottom sheet state extensions"},{"location":"2/views-dsl-design/#textinputlayout-helper","text":"The addInput extension function on TextInputLayout takes a required id used for the TextInputEditText that it creates and adds to the layout. The id is required so the content of the user input is saved in instance state even if the host Activity is killed by the system.","title":"TextInputLayout helper"},{"location":"2/views-dsl-design/#download","text":"implementation \"com.louiscad.splitties:splitties-views-dsl-design:2.1.1\"","title":"Download"},{"location":"2/views-dsl-ide-preview/","text":"Views DSL IDE preview \u00b6 Preview UIs made with Splitties Views DSL. This split provides a class named UiPreView that you can use in xml layout files to preview your Ui subclasses made using Views DSL . To avoid embedding unused code in your production app, add the dependency only for the debug buildType (using debugImplementation in your gradle file) and put the preview xml layout files in the src/debug/res/layout/ directory (not in src/main/res/layout/ ). Example \u00b6 Below is a preview xml layout example that the IDE can display. It assumes there\u2019s a class implementing Ui named MainUi in the main subpackage (relative to the app/library package name). <splitties.views.dsl.idepreview.UiPreView xmlns:android= \"http://schemas.android.com/apk/res/android\" xmlns:app= \"http://schemas.android.com/apk/res-auto\" android:layout_width= \"match_parent\" android:layout_height= \"match_parent\" app:splitties_class_package_name_relative= \"main.MainUi\" /> Here\u2019s a screenshot of how it looks like with DemoUi from the sample : Important info \u00b6 Known issues and their workaround \u00b6 If preview doesn\u2019t work or doesn\u2019t reflect latest changes, it\u2019s likely because you didn\u2019t build your project. IDE preview currently only works with compiled classes and xml layouts, so make sure your project is built before attempting to preview your Ui . IDE preview is unstable from my experience on Android Studio 3.1 rc01, so if you encounter a weird problem with preview, just restarting the IDE may fix your issue, as it did for me. Finding a suitable constructor to instantiate your UI \u00b6 UiPreView is compatible with Ui implementations with two kind of constructors: * Constructors with a single Context parameter. * Constructors whose first parameter is a Context and other parameters are interfaces. Note that the interface methods need to not be called during preview, or an UnsupportedOperationException will be raised because UiPreView can only create stub implementations. You can use View.isInEditMode to skip code for preview if really needed. Finding the class \u00b6 When using the splitties_class_package_name_relative attribute, the UiPreView class will take the packageName returned from the Context and append a dot plus the value of the attribute to get the class name of your Ui implementation. However, you may have configured your build so your debug buildType has an applicationId suffix that is usually .debug like show in the example below: buildTypes { debug { applicationIdSuffix \".debug\" // This changes the packageName returned from a Context versionNameSuffix \"-DEBUG\" } release { // Config of your release build } } That\u2019s why by default, the UiPreView class will drop any .debug suffix found in the package name before trying to instantiate the class. If you use another suffix, or have other suffixes for other debuggable buildTypes, or use productFlavors, you\u2019re in luck! The package name suffix to drop is configurable from your resources. Just copy paste the string resource below in your project in a value resource file named something like config.xml or do_not_translate.xml , and edit it to the suffix you use: <string name= \"splitties_views_dsl_ide_preview_package_name_suffix\" translatable= \"false\" > .debug </string> This will override the default value from the library. Alternatively, you can use the splitties_class_fully_qualified_name attribute instead and specify the full class name with its package. Download \u00b6 debugImplementation \"com.louiscad.splitties:splitties-views-dsl-ide-preview:2.1.1\"","title":"views-dsl-ide-preview"},{"location":"2/views-dsl-ide-preview/#views-dsl-ide-preview","text":"Preview UIs made with Splitties Views DSL. This split provides a class named UiPreView that you can use in xml layout files to preview your Ui subclasses made using Views DSL . To avoid embedding unused code in your production app, add the dependency only for the debug buildType (using debugImplementation in your gradle file) and put the preview xml layout files in the src/debug/res/layout/ directory (not in src/main/res/layout/ ).","title":"Views DSL IDE preview"},{"location":"2/views-dsl-ide-preview/#example","text":"Below is a preview xml layout example that the IDE can display. It assumes there\u2019s a class implementing Ui named MainUi in the main subpackage (relative to the app/library package name). <splitties.views.dsl.idepreview.UiPreView xmlns:android= \"http://schemas.android.com/apk/res/android\" xmlns:app= \"http://schemas.android.com/apk/res-auto\" android:layout_width= \"match_parent\" android:layout_height= \"match_parent\" app:splitties_class_package_name_relative= \"main.MainUi\" /> Here\u2019s a screenshot of how it looks like with DemoUi from the sample :","title":"Example"},{"location":"2/views-dsl-ide-preview/#important-info","text":"","title":"Important info"},{"location":"2/views-dsl-ide-preview/#known-issues-and-their-workaround","text":"If preview doesn\u2019t work or doesn\u2019t reflect latest changes, it\u2019s likely because you didn\u2019t build your project. IDE preview currently only works with compiled classes and xml layouts, so make sure your project is built before attempting to preview your Ui . IDE preview is unstable from my experience on Android Studio 3.1 rc01, so if you encounter a weird problem with preview, just restarting the IDE may fix your issue, as it did for me.","title":"Known issues and their workaround"},{"location":"2/views-dsl-ide-preview/#finding-a-suitable-constructor-to-instantiate-your-ui","text":"UiPreView is compatible with Ui implementations with two kind of constructors: * Constructors with a single Context parameter. * Constructors whose first parameter is a Context and other parameters are interfaces. Note that the interface methods need to not be called during preview, or an UnsupportedOperationException will be raised because UiPreView can only create stub implementations. You can use View.isInEditMode to skip code for preview if really needed.","title":"Finding a suitable constructor to instantiate your UI"},{"location":"2/views-dsl-ide-preview/#finding-the-class","text":"When using the splitties_class_package_name_relative attribute, the UiPreView class will take the packageName returned from the Context and append a dot plus the value of the attribute to get the class name of your Ui implementation. However, you may have configured your build so your debug buildType has an applicationId suffix that is usually .debug like show in the example below: buildTypes { debug { applicationIdSuffix \".debug\" // This changes the packageName returned from a Context versionNameSuffix \"-DEBUG\" } release { // Config of your release build } } That\u2019s why by default, the UiPreView class will drop any .debug suffix found in the package name before trying to instantiate the class. If you use another suffix, or have other suffixes for other debuggable buildTypes, or use productFlavors, you\u2019re in luck! The package name suffix to drop is configurable from your resources. Just copy paste the string resource below in your project in a value resource file named something like config.xml or do_not_translate.xml , and edit it to the suffix you use: <string name= \"splitties_views_dsl_ide_preview_package_name_suffix\" translatable= \"false\" > .debug </string> This will override the default value from the library. Alternatively, you can use the splitties_class_fully_qualified_name attribute instead and specify the full class name with its package.","title":"Finding the class"},{"location":"2/views-dsl-ide-preview/#download","text":"debugImplementation \"com.louiscad.splitties:splitties-views-dsl-ide-preview:2.1.1\"","title":"Download"},{"location":"2/views-dsl-recyclerview/","text":"Views DSL RecyclerView \u00b6 RecyclerView extension of Views DSL Table of contents \u00b6 RecyclerView with scrollbars Make any view scrollable RecyclerView item layout parameters Download RecyclerView with scrollbars \u00b6 To get scrollbars on a View in Android, you need to enable it in the android:scrollbars xml attribute first. Only then you can disable and re-enable them back using the isHorizontalScrollBarEnabled and isVerticalScrollBarEnabled properties. To overcome this problem, this split provides a recyclerView function . This function inflates a RecyclerView with both horizontal and vertical scrollbars enabled in xml, but the scrollbars will only ever appear if your content can scroll in that direction, so you likely just have to use it. Make any view scrollable \u00b6 Let\u2019s say you have a LinearLayout , or a TextView that is just a bit too long to fit into all screen sizes. In xml, you\u2019d likely use NestedScrollView , or good old ScrollView . Unfortunately, NestedScrollView has bugs that may cut off the content in some hard to reproduce consistently cases, and ScrollView doesn\u2019t support nested scroll as you may need in your app. On the other hand, there\u2019s RecyclerView , which has none of these issues. This split provides a wrapInRecyclerView extension function for View that returns a RecyclerView wrapping the View is has been called on. It is vertical by default, but you can set the horizontal parameter to true Also, you can (should) specify the id so scrolling position is saved into instance state and restored when needed. And you have an optional lambda to configure the RecyclerView , which can be useful for things like setting the padding and disabling clipping, setting the background, etc. Here\u2019s two small examples: val content = textView { textResource = R . string . a_very_long_string }. wrapInRecyclerView ( id = R . id . main_content ) { verticalPadding = dip ( 8 ) horizontalPadding = dip ( 16 ) clipToPadding = false } val content = textView { textResource = R . string . good_luck_scrolling_these_10_thousand_characters textSize = 48f // This size is interpreted in sp unit BTW }. wrapInRecyclerView ( horizontal = true ) RecyclerView item layout parameters \u00b6 RecyclerView.onCreateViewHolder method passes the parent ViewGroup so layout parameters are properly generated when the item view is inflated from xml. When using Views DSL in a RecyclerView , you are not inflating xml, so this parent parameter is of no use. However, you can set the item view layout parameters manually. This split provides two extension functions on RecyclerView.LayoutManager to make it easy: verticalListLayoutParams and horizontalListLayoutParams . Download \u00b6 implementation \"com.louiscad.splitties:splitties-views-dsl-recyclerview:2.1.1\"","title":"views-dsl-recyclerview"},{"location":"2/views-dsl-recyclerview/#views-dsl-recyclerview","text":"RecyclerView extension of Views DSL","title":"Views DSL RecyclerView"},{"location":"2/views-dsl-recyclerview/#table-of-contents","text":"RecyclerView with scrollbars Make any view scrollable RecyclerView item layout parameters Download","title":"Table of contents"},{"location":"2/views-dsl-recyclerview/#recyclerview-with-scrollbars","text":"To get scrollbars on a View in Android, you need to enable it in the android:scrollbars xml attribute first. Only then you can disable and re-enable them back using the isHorizontalScrollBarEnabled and isVerticalScrollBarEnabled properties. To overcome this problem, this split provides a recyclerView function . This function inflates a RecyclerView with both horizontal and vertical scrollbars enabled in xml, but the scrollbars will only ever appear if your content can scroll in that direction, so you likely just have to use it.","title":"RecyclerView with scrollbars"},{"location":"2/views-dsl-recyclerview/#make-any-view-scrollable","text":"Let\u2019s say you have a LinearLayout , or a TextView that is just a bit too long to fit into all screen sizes. In xml, you\u2019d likely use NestedScrollView , or good old ScrollView . Unfortunately, NestedScrollView has bugs that may cut off the content in some hard to reproduce consistently cases, and ScrollView doesn\u2019t support nested scroll as you may need in your app. On the other hand, there\u2019s RecyclerView , which has none of these issues. This split provides a wrapInRecyclerView extension function for View that returns a RecyclerView wrapping the View is has been called on. It is vertical by default, but you can set the horizontal parameter to true Also, you can (should) specify the id so scrolling position is saved into instance state and restored when needed. And you have an optional lambda to configure the RecyclerView , which can be useful for things like setting the padding and disabling clipping, setting the background, etc. Here\u2019s two small examples: val content = textView { textResource = R . string . a_very_long_string }. wrapInRecyclerView ( id = R . id . main_content ) { verticalPadding = dip ( 8 ) horizontalPadding = dip ( 16 ) clipToPadding = false } val content = textView { textResource = R . string . good_luck_scrolling_these_10_thousand_characters textSize = 48f // This size is interpreted in sp unit BTW }. wrapInRecyclerView ( horizontal = true )","title":"Make any view scrollable"},{"location":"2/views-dsl-recyclerview/#recyclerview-item-layout-parameters","text":"RecyclerView.onCreateViewHolder method passes the parent ViewGroup so layout parameters are properly generated when the item view is inflated from xml. When using Views DSL in a RecyclerView , you are not inflating xml, so this parent parameter is of no use. However, you can set the item view layout parameters manually. This split provides two extension functions on RecyclerView.LayoutManager to make it easy: verticalListLayoutParams and horizontalListLayoutParams .","title":"RecyclerView item layout parameters"},{"location":"2/views-dsl-recyclerview/#download","text":"implementation \"com.louiscad.splitties:splitties-views-dsl-recyclerview:2.1.1\"","title":"Download"},{"location":"2/views-dsl/","text":"Views DSL \u00b6 Create UIs with readable Kotlin code. There\u2019s a whole document about Views DSL vs xml layouts if you are not convinced yet. TL;DR: Kotlin code is more concise than xml, and a small library like this one is the proof of what is already possible with this great language. Splitties Views DSL has been designed to be: * Simple * Concise * Expressive * Explicit * Efficient * Reliable * Flexible That\u2019s 7 key considerations, which are all necessary to make a great library. Introduction \u00b6 As said above, Splitties Views DSL has been designed to be simple . Consequently, you\u2019ll find no class in this split (API-wise, as strictly speaking, all functions and properties, even top-level ones and extensions belong to a class in the bytecode). That means you won\u2019t have to learn a whole new API to use Splitties Views DSL. You\u2019ll just have to discover the extension functions and properties as you need them to craft your Android user interfaces with Kotlin code. It turns out that you just need a few extension functions and properties to make UI-related code at least as readable as xml counterparts. Note that while putting all of your UI code directly in an Activity or a Fragment is possible with Splitties Views DSL (and can surely help for throwaway prototyping), we will be recommending a cleaner, yet simple approach (spoiler: a custom class). Before we dive into the details of the API, let\u2019s take a look at a simple example: val launchDemoBtn = button { textResource = R . string . go_to_the_demo } This example was meaningless , because no one ever publishes an app with only one button. Also, the snippet above just creates a button. If you want it into a ViewGroup , or as the content of an Activity or a Fragment , you need to do so explicitly. There are real examples in the sample . You can start by taking a look at MainUi . You can also see a simple example that uses ConstraintLayout in AboutUi . Opening the project in your IDE and navigating the sample UI code while reading this documentation may certainly help you have a hands-on experience and be comfortable more quickly writing UIs with Kotlin, a programming language that is probably already familiar to you. Table of contents \u00b6 The extensions Creating and configuring views The most generic way: view Using styles defined in xml Using Android styles Using AppCompat styles Using any other xml style The most beautiful ways: explicitly named aliases to the generic way View extensions Inflating existing xml layouts Laying out the views ViewGroup.add(\u2026) , an alias to ViewGroup.addView(\u2026) ViewGroups extension functions to instantiate LayoutParams WARNING regarding lParams and defaultLParams usage Other extensions for ViewGroup The interface for user interfaces, named Ui Why this interface What it is made of Implementing the interface Using Ui implementations Simple examples Possibilities brought by the Ui interface IDE Preview Modular user interface contracts Easier multi form factors support Multiplatform user interface contracts Testing Redesign A/B Testing Additional modules Download The extensions \u00b6 Splitties is primarily made of extension functions and properties, to create views with minimal code but maximum flexibility. Just calling the constructor, then calling needed methods in an apply { ... } block could be enough to use Kotlin instead of xml for your user interfaces, but Splitties Views DSL allows something more readable , more concise, and with a few features, like themes, styles, and seamless AppCompat support, without the boilerplate . Creating and configuring views \u00b6 The most generic way: view \u00b6 The view extension functions are a primitive of Splitties Views DSL. They are generic, so they allow you to instantiate a View of any type. There are 6 functions named view , because there\u2019s 2 overload types , and they are made available for 3 receiver types: Ui , View and Context . With respect to efficiency, they are all inline . That means no unnecessary allocation that would slightly decrease performance otherwise. Both overloads allow the following 3 optional parameters: * @IdRes id: Int , the id of the View. Example argument: R.id.input_name , given you declared it in xml, as done in the sample * @StyleRes theme: Int , resource of a theme overlay that will be applied to the View. Example argument: R.style.AppTheme_AppBarOverlay * initView: V.() -> Unit , a lambda that is like apply for the created View. The first overload of view takes a required first parameter that is a function taking a Context , and returning a View . Since constructors are also methods in Kotlin, you can directly use a method reference like so: view(::View) . The same goes for any other View subclass (e.g. view(::FrameLayout) ). You can also use a lambda instead: view({ FrameLayout(it) }) . In fact, that\u2019s how you should do it while autocomplete for method references is not optimal, then use the IDE quick action ( alt / \u2325 option + \u23ce enter ) to convert it to method reference. You can of course use any custom method reference that is not a reference to a constructor as long as that method takes a Context parameter and returns a View or any subclass of it. Here\u2019s a simple but typical example of this first overload: val myView : MyCustomView = view ( :: MyCustomView , R . id . my_view ) { backgroundColor = Color . BLACK } The second overload of view takes no required parameter, but relies on explicit (reified) type parameter to work properly. Just v<TextView>() is enough to instantiate a TextView . However, this version relies on a \u201cview factory\u201d that can automatically provide subclasses of the requested type as necessary. If you use the Views DSL AppCompat, you\u2019ll automatically receive instances of AppCompatButton with v<Button> thanks to the underlying View factory. Here\u2019s a simple example of this second overload: val submitBtn = v < Button >( R . id . btn_submit ) { textResource = R . string . submit } Using styles defined in xml \u00b6 There are some times where you need to use an xml defined style, such as when using a style defined in AppCompat like Widget_AppCompat_Button_Colored . Splitties makes it really easy to use xml styles defined in Android and AppCompat. It also gives you the ability to do the same for custom or third-party styles defined in xml. Using Android styles \u00b6 Let\u2019s say you want to create a horizontal ProgressBar instance. First, type the following with autocomplete/auto-imports: val progressbar = AndroidStyles . progressBar . horizontal . invoke ( ctx ) Then, remove .invoke to have function call syntax directly on the horizontal property. It should look like this: val progressbar = AndroidStyles . progressBar . horizontal ( ctx ) Other styles defined in the Android platform are provided in AndroidStyles . Just let auto-completion guide you. Note that you have exactly the same optional parameters as view , including the optional lambda. Using AppCompat styles \u00b6 Since AppCompat styles are not included by default inside the theme, you need to load them first. This is simply done with the following code: private val appCompatStyles = AppCompatStyles ( ctx ) You can then use styles using the AppCompatStyles instance. Here\u2019s an example: val bePoliteBtn = appCompatStyles . button . colored ( ctx ) { textResource = R . string . be_polite } Don\u2019t forget to first write .invoke before the parenthesis to have the IDE import the function (you can immediately remove it afterwards). Using any other xml style \u00b6 The colored , horizontal and other properties you can find in the AndroidStyles and the AppCompatStyles have the XmlStyle type. It is easy to instantiate it and support any xml style after the style is loaded into the current theme, but before we see how it\u2019s done, let\u2019s see what is this type. The XmlStyle inline class has: * A type parameter, for the target View type. * A single Int value, a theme attribute ( @AttrRes , not @StyleRes ). As you can see, its constructor doesn\u2019t expect a style resource (e.g. R.style.Widget_AppCompat_ActionButton ), but a theme attribute resource (e.g. R.attr.Widget_AppCompat_ActionButton ). This is because of a limitation in Android where you can programmatically only use xml styles that are inside a theme. That doesn\u2019t mean that you will have to pollute all the themes you\u2019re using with styles definitions though. Android allows you to combine multiple themes with the applyStyle(\u2026) method that you can call on any theme , which any Context has. That way, you can apply a theme that already includes references the xml styles you need with only one line of code. This is what the AppCompatStyles(ctx) function mentioned does under the hood. Here\u2019s a short example: ctx . theme . applyStyle ( R . style . ThirdPartyStyles , false ) val clapButton = XmlStyle < Button >( R . attr . Widget_ThirdParty_FancyButton )( ctx ) { imageResource = R . drawable . ic_clap_white_24dp } The first line makes sure the theme associated to the Context named ctx can resolve all the style attributes defined into R.style.ThirdPartyStyles , such as R.attr.Widget_ThirdParty_FancyButton . To make this work, you have to do the following: 1. Declare ThirdPartyStyles in xml (usually in a file named styles.xml ) 2. Declare the Widget_ThirdParty_FancyButton attribute (usually in a file named attrs.xml ) 3. Declare Widget_ThirdParty_FancyButton into ThirdPartyStyles and make sure it references the style target resource (named Widget_ThirdParty_FancyButton too). Using the same name for the target style and the attribute is a recommendation (for clarity), but not a requirement. After this is done, you can make a class to group related styles, as done in the Views DSL AppCompat split , so you get type inference, and a nicer syntax. The most beautiful ways: explicitly named aliases to the generic way \u00b6 Instead of using v<Button>(\u2026) { \u2026 } to create a Button instance, you can use button(\u2026) { \u2026 } . The parameters are exactly the same as view . Such methods exist for most View s and ViewGroup s included in Android, and there\u2019s more in the additional modules . You can see implementations for Views and ViewGroups . These methods are a bit more natural to read and to write, but they are really just inline aliases, purely syntactic sugar. You can define your own if you want. Just make sure to write it first for Context and add two overloads for View and Ui that delegate to the one for Context . Also, remember to make them inline to avoid lambda allocation. View extensions \u00b6 For even more expressive UI code, Splitties Views DSL has a transitive dependency on the Views split that provides a useful set of Kotlin-friendly extension functions and properties dedicated to View s and some of their subclasses. Inflating existing xml layouts \u00b6 Splitties Views DSL works well with xml layouts too! The inflate extension functions is a variant to the view function mentioned earlier in this guide which has an additional first parameter: the layout resource id you want to inflate. Also, if the xml layout defines an id for the root view, it will be kept, unless you specified an explicit id (including View.NO_ID ). Just like view , inflate is defined for Context , View and Ui . Here\u2019s a short example: val mySecretFancyView = inflate ( R . layout . my_fancy_layout ) { isVisible = false } Laying out the views \u00b6 ViewGroup.add(\u2026) , an alias to ViewGroup.addView(\u2026) \u00b6 To add a View to a ViewGroup in code, you can use View.addView(\u2026) . However, this can become quite redundant to have View repeated over and over when it\u2019s already obvious that you are in a UI centric class that passes a parameter that is clearly a View . That\u2019s why this split has an inline alias to it named just add(\u2026) for ViewGroup . It has the extra benefit of returning the passed View , which can be handy in some situations. The ViewGroup.add(\u2026) function requires an instance of ViewGroup.LayoutParams , see how Splitties helps instantiating it with minimal, yet explicit code. ViewGroups extension functions to instantiate LayoutParams \u00b6 Splitties provides several methods named lParams(\u2026) { \u2026 } for the 2 Android\u2019s built-in ViewGroup s: LinearLayout and FrameLayout . You can find support for additional ViewGroup s in the additional modules . These methods make it easy to instantiate LayoutParams with typesafe and readable code (unlike xml). Here\u2019s the contract that every lParams or alike function must respect: 1. The receiver is the type of the target ViewGroup subclass. 2. The function returns the LayoutParams for the target ViewGroup . 3. The first parameter is width and defaults to wrapContent , unless otherwise noted. 4. The second parameter is height and defaults to the same value as width , unless otherwise noted. 5. The width or height parameters may be missing in case they shall always have the same value for this target ViewGroup or for this function. 5. There may be additional parameters, with default values if possible. 6. The last parameter is a lambda with LayoutParams as a receiver and is executed exactly once, last (i.e. after any logic that the lParams implementation may have). 7. If the lParams function targets a ViewGroup that has a superclass that also has its own LayoutParams , and its own lParams function, it should be named defaultLParams instead to prevent any overload resolution ambiguity. A great example is AppBarLayout that is a child class of LinearLayout and has such extension functions for LayoutParams . 8. In case the function is specialized for non default use case (e.g. adding an AppBarLayout into a CoordinatorLayout ), it can have a custom name, but should always end with LParams (e.g. appBarLParams ). WARNING regarding lParams and defaultLParams usage: \u00b6 lParams and similar functions are resolved based on the type of their receiver. However, unless you prepend lParams or defaultLParams call with this. , the received is picked implicitly, and can be indirect, possibly causing the wrong lParams method to be used. Here\u2019s a short, example : You\u2019re in a FrameLayout (because you\u2019re writing a subclass of it, or because of a lambda receiver, like inside frameLayout { \u2026 } ). You call constraintLayout { \u2026 } and start adding views inside it, but when you call lParams , you may use the implementation for FrameLayout , and wonder why the ConstraintLayout.LayoutParams properties and extensions are not available. To highlight such errors, you can prepend this. to your suspicious lParams calls, and if they are in red, then you used the wrong one for the ViewGroup you\u2019re in. The IDE should quickly fix it, adding the proper import at this point. After this is done, you can then safely remove the this. prefix. To avoid this issue, you can be alert when you\u2019re typing/auto-completing lParams and defaultLParams and make sure that you\u2019re selecting the extension for the type of the ViewGroup you\u2019re in (direct parent of the child View you are adding). Other extensions for ViewGroup \u00b6 wrapContent and matchParent inline extensions properties on ViewGroup are convenience aliases to ViewGroup.LayoutParams.WRAP_CONTENT and ViewGroup.LayoutParams.MATCH_PARENT . horizontalMargin , verticalMargin and margin for convenient margins definition in layout parameters ( ViewGroup.MarginLayoutParams which is the base of nearly all LayoutParams). startMargin and endMargin which are compatible below API 17 (using LTR) and fix the inconsistent name ordering ( leftMargin , but marginStart ?). The interface for user interfaces, named Ui \u00b6 This section doesn\u2019t just writes so many words about how the Ui interface has only 2 properties . It explains why it is useful , how to use it the right way , and the possibilities it offers. FYI, the declaration of this interface looks like this: interface Ui { val ctx : Context val root : View } Why this interface \u00b6 As said above, you can put your UI code directly in an Activity or a Fragment , but the fact you can doesn\u2019t mean you should. Mixing UI code with business logic, data storage code, network calls and miscellaneous boilerplate in the same \u201cgod\u201d class will quickly make further work (like feature additions and maintenance) very hard, because you\u2019re likely not a god programmer, and even if you are, your coworkers, or successors, are likely not. Xml layouts alleviate this issue by forcing you to put most of your UI code into a separate xml file, but you often need complementary code (e.g. to handle transitions, dynamic visibility), and this is often put into a Fragment or an Activity , which makes things worse, as you now have your UI code spread over at least two places that are tightly coupled. What it is made of \u00b6 With Splitties Views DSL, there\u2019s an optional interface named Ui , whose implementations are meant to contain your UI code. It has a ctx property because in Android, a Context is needed to create a View . It has a root property because you need a View to display in the end. Since you\u2019re using Kotlin code, you can put all the UI related logic in it too, in a single place this time. Also, since Ui is an interface, you can get creative by creating sub-interfaces or sub-classes to have different implementations of the same UI, which is nice for A/B testing, user preferences (different styles that the user can pick), configuration (like screen orientation), and more. Implementing the Ui interface \u00b6 When writing a Ui implementation, override the ctx property as the first constructor parameter (e.g. class MainUi(override val ctx: Context) : Ui { ), and override the root parameter as a property with a backing field by assigning it a View (e.g. override val root = coordinatorLayout { ... } ). Then create your views (usually putting them as final properties, like root ), and add them to the ViewGroup s they belong to, so they are direct, or indirect children of root (in the likely case where you have multiple views in your UI and root is therefore a ViewGroup ). Using Ui implementations \u00b6 To use a Ui implementation from an Activity subclass, just call setContentView(ui) . To use it from any other place, just get the root property. In a Fragment subclass, that will mean returning it from onCreateView(\u2026) . You can also use any function or property you\u2019ve declared in your sub-interface or implementation. Here are two examples: * Using a public property of type Button to set it an OnClickListener in the place where the Ui is used (like an Activity or a Fragment that connects your UI to a ViewModel and any other components). * Call a method called animateGoalReached() . Simple examples \u00b6 See concrete examples in MainUi and DemoUi with their respective Activities MainActivity and DemoActivity . Possibilities brought by the Ui interface \u00b6 IDE Preview \u00b6 You can preview Ui implementations in the IDE. See the Views DSL IDE preview split . Modular user interface contracts \u00b6 While having a dedicated class for user interface, that is agnostic from where it will be used (Activity, Fragment, IDE Preview\u2026), is a great first step to a modular user interface code, you can go further. Instead of exposing your Ui implementation directly to the Activity or Fragment, you can decide to write several interfaces that define a contract that your Activity, Fragment, ViewModel (beware of leaks), or whatever will need, and implement all of these with one or more classes. For example, let\u2019s say you are developing an email app. You write two interfaces: InboxUi and ComposeUi that both extend the Ui interface. You add to the interfaces all the functions (including any suspend fun ), properties and other symbols you may need to expose to the Activity, Fragment, ViewModel or whatever. Then you implement these two interfaces, with either one class or two, depending on whether you want to display them separately or not. Easier multi form factors support \u00b6 Modular UI contracts open the door to a great benefit: an easier way to support multiple form factors (smartphones, smartwatches, tablets, laptops, cars\u2026). In the previous example, we highlighted the fact that you could have multiple interfaces that expose the needed symbols, and then decide to implement these interfaces in one, or multiple classes. This can help you support different form factors with zero, or only a few changes in non-UI code as it is no longer relies on a specific implementation. It is planned to add such examples in the samples of this repository. If you want to have them faster, please open an issue so the examples can be discussed. Also, maybe you, or someone you know, can contribute. Multiplatform user interface contracts \u00b6 Here\u2019s an example of how you may write multiplatform user interface contracts: In Kotlin common code, you would write an interface that is platform agnostic but declares the needed symbols that all platforms can share: Continuing our email app example, you would write these two interfaces: interface InboxUiContract { // Whatever you need } interface ComposeUiContract { // Whatever you need } Then write to sub-interfaces for each platform you want to support, Android and iOS in this example: interface AndroidInboxUi : InboxUiContract , Ui interface IOSInboxUi : InboxUiContract { val root : UIView } And you may finally implement them for each platform, still supporting multiple form-factors and platform variants if needed. The two common interfaces ( InboxUiContract and ComposeUiContract ) could be replaced by abstract classes in case you need to have backing fields, final declarations or final implementations, as long as they don\u2019t reference Splitties Ui interface and no platform specific code. Testing \u00b6 Having your user interface as an interface can make it easy to mock it, and simulate user interactions for testing purposes. Redesign \u00b6 If you expect an interface for the user interface, then it becomes easy to replace an implementation by another one in case you\u2019re redesigning your app. You can also split your UI contracts (the interface s) into smaller subsets before starting a redesign if needed, this can be helpful if you want to move some UI controls to another area of the application, or just organize things differently. A/B Testing \u00b6 When you have multiple UI interface s implementations, you can then swap them at runtime for A/B testing, allowing you to test which UI works the best for what you determined. Additional modules \u00b6 There are additional splits for extended support. Views DSL\u2026 * AppCompat provides proper styling to Button , TextView , EdiText and other widgets. views like coloredFlatButton . * ConstraintLayout provides support for ConstraintLayout.LayoutParameters . * Design provides extensions for design support library ViewGroup s and bottom sheets. * IDE preview provides the ability to preview your user interfaces right from the IDE. * RecyclerView provides extensions to have scrollbars and proper itemView layout parameters. Download \u00b6 implementation \"com.louiscad.splitties:splitties-views-dsl:2.1.1\"","title":"views-dsl"},{"location":"2/views-dsl/#views-dsl","text":"Create UIs with readable Kotlin code. There\u2019s a whole document about Views DSL vs xml layouts if you are not convinced yet. TL;DR: Kotlin code is more concise than xml, and a small library like this one is the proof of what is already possible with this great language. Splitties Views DSL has been designed to be: * Simple * Concise * Expressive * Explicit * Efficient * Reliable * Flexible That\u2019s 7 key considerations, which are all necessary to make a great library.","title":"Views DSL"},{"location":"2/views-dsl/#introduction","text":"As said above, Splitties Views DSL has been designed to be simple . Consequently, you\u2019ll find no class in this split (API-wise, as strictly speaking, all functions and properties, even top-level ones and extensions belong to a class in the bytecode). That means you won\u2019t have to learn a whole new API to use Splitties Views DSL. You\u2019ll just have to discover the extension functions and properties as you need them to craft your Android user interfaces with Kotlin code. It turns out that you just need a few extension functions and properties to make UI-related code at least as readable as xml counterparts. Note that while putting all of your UI code directly in an Activity or a Fragment is possible with Splitties Views DSL (and can surely help for throwaway prototyping), we will be recommending a cleaner, yet simple approach (spoiler: a custom class). Before we dive into the details of the API, let\u2019s take a look at a simple example: val launchDemoBtn = button { textResource = R . string . go_to_the_demo } This example was meaningless , because no one ever publishes an app with only one button. Also, the snippet above just creates a button. If you want it into a ViewGroup , or as the content of an Activity or a Fragment , you need to do so explicitly. There are real examples in the sample . You can start by taking a look at MainUi . You can also see a simple example that uses ConstraintLayout in AboutUi . Opening the project in your IDE and navigating the sample UI code while reading this documentation may certainly help you have a hands-on experience and be comfortable more quickly writing UIs with Kotlin, a programming language that is probably already familiar to you.","title":"Introduction"},{"location":"2/views-dsl/#table-of-contents","text":"The extensions Creating and configuring views The most generic way: view Using styles defined in xml Using Android styles Using AppCompat styles Using any other xml style The most beautiful ways: explicitly named aliases to the generic way View extensions Inflating existing xml layouts Laying out the views ViewGroup.add(\u2026) , an alias to ViewGroup.addView(\u2026) ViewGroups extension functions to instantiate LayoutParams WARNING regarding lParams and defaultLParams usage Other extensions for ViewGroup The interface for user interfaces, named Ui Why this interface What it is made of Implementing the interface Using Ui implementations Simple examples Possibilities brought by the Ui interface IDE Preview Modular user interface contracts Easier multi form factors support Multiplatform user interface contracts Testing Redesign A/B Testing Additional modules Download","title":"Table of contents"},{"location":"2/views-dsl/#the-extensions","text":"Splitties is primarily made of extension functions and properties, to create views with minimal code but maximum flexibility. Just calling the constructor, then calling needed methods in an apply { ... } block could be enough to use Kotlin instead of xml for your user interfaces, but Splitties Views DSL allows something more readable , more concise, and with a few features, like themes, styles, and seamless AppCompat support, without the boilerplate .","title":"The extensions"},{"location":"2/views-dsl/#creating-and-configuring-views","text":"","title":"Creating and configuring views"},{"location":"2/views-dsl/#the-most-generic-way-view","text":"The view extension functions are a primitive of Splitties Views DSL. They are generic, so they allow you to instantiate a View of any type. There are 6 functions named view , because there\u2019s 2 overload types , and they are made available for 3 receiver types: Ui , View and Context . With respect to efficiency, they are all inline . That means no unnecessary allocation that would slightly decrease performance otherwise. Both overloads allow the following 3 optional parameters: * @IdRes id: Int , the id of the View. Example argument: R.id.input_name , given you declared it in xml, as done in the sample * @StyleRes theme: Int , resource of a theme overlay that will be applied to the View. Example argument: R.style.AppTheme_AppBarOverlay * initView: V.() -> Unit , a lambda that is like apply for the created View. The first overload of view takes a required first parameter that is a function taking a Context , and returning a View . Since constructors are also methods in Kotlin, you can directly use a method reference like so: view(::View) . The same goes for any other View subclass (e.g. view(::FrameLayout) ). You can also use a lambda instead: view({ FrameLayout(it) }) . In fact, that\u2019s how you should do it while autocomplete for method references is not optimal, then use the IDE quick action ( alt / \u2325 option + \u23ce enter ) to convert it to method reference. You can of course use any custom method reference that is not a reference to a constructor as long as that method takes a Context parameter and returns a View or any subclass of it. Here\u2019s a simple but typical example of this first overload: val myView : MyCustomView = view ( :: MyCustomView , R . id . my_view ) { backgroundColor = Color . BLACK } The second overload of view takes no required parameter, but relies on explicit (reified) type parameter to work properly. Just v<TextView>() is enough to instantiate a TextView . However, this version relies on a \u201cview factory\u201d that can automatically provide subclasses of the requested type as necessary. If you use the Views DSL AppCompat, you\u2019ll automatically receive instances of AppCompatButton with v<Button> thanks to the underlying View factory. Here\u2019s a simple example of this second overload: val submitBtn = v < Button >( R . id . btn_submit ) { textResource = R . string . submit }","title":"The most generic way: view"},{"location":"2/views-dsl/#using-styles-defined-in-xml","text":"There are some times where you need to use an xml defined style, such as when using a style defined in AppCompat like Widget_AppCompat_Button_Colored . Splitties makes it really easy to use xml styles defined in Android and AppCompat. It also gives you the ability to do the same for custom or third-party styles defined in xml.","title":"Using styles defined in xml"},{"location":"2/views-dsl/#using-android-styles","text":"Let\u2019s say you want to create a horizontal ProgressBar instance. First, type the following with autocomplete/auto-imports: val progressbar = AndroidStyles . progressBar . horizontal . invoke ( ctx ) Then, remove .invoke to have function call syntax directly on the horizontal property. It should look like this: val progressbar = AndroidStyles . progressBar . horizontal ( ctx ) Other styles defined in the Android platform are provided in AndroidStyles . Just let auto-completion guide you. Note that you have exactly the same optional parameters as view , including the optional lambda.","title":"Using Android styles"},{"location":"2/views-dsl/#using-appcompat-styles","text":"Since AppCompat styles are not included by default inside the theme, you need to load them first. This is simply done with the following code: private val appCompatStyles = AppCompatStyles ( ctx ) You can then use styles using the AppCompatStyles instance. Here\u2019s an example: val bePoliteBtn = appCompatStyles . button . colored ( ctx ) { textResource = R . string . be_polite } Don\u2019t forget to first write .invoke before the parenthesis to have the IDE import the function (you can immediately remove it afterwards).","title":"Using AppCompat styles"},{"location":"2/views-dsl/#using-any-other-xml-style","text":"The colored , horizontal and other properties you can find in the AndroidStyles and the AppCompatStyles have the XmlStyle type. It is easy to instantiate it and support any xml style after the style is loaded into the current theme, but before we see how it\u2019s done, let\u2019s see what is this type. The XmlStyle inline class has: * A type parameter, for the target View type. * A single Int value, a theme attribute ( @AttrRes , not @StyleRes ). As you can see, its constructor doesn\u2019t expect a style resource (e.g. R.style.Widget_AppCompat_ActionButton ), but a theme attribute resource (e.g. R.attr.Widget_AppCompat_ActionButton ). This is because of a limitation in Android where you can programmatically only use xml styles that are inside a theme. That doesn\u2019t mean that you will have to pollute all the themes you\u2019re using with styles definitions though. Android allows you to combine multiple themes with the applyStyle(\u2026) method that you can call on any theme , which any Context has. That way, you can apply a theme that already includes references the xml styles you need with only one line of code. This is what the AppCompatStyles(ctx) function mentioned does under the hood. Here\u2019s a short example: ctx . theme . applyStyle ( R . style . ThirdPartyStyles , false ) val clapButton = XmlStyle < Button >( R . attr . Widget_ThirdParty_FancyButton )( ctx ) { imageResource = R . drawable . ic_clap_white_24dp } The first line makes sure the theme associated to the Context named ctx can resolve all the style attributes defined into R.style.ThirdPartyStyles , such as R.attr.Widget_ThirdParty_FancyButton . To make this work, you have to do the following: 1. Declare ThirdPartyStyles in xml (usually in a file named styles.xml ) 2. Declare the Widget_ThirdParty_FancyButton attribute (usually in a file named attrs.xml ) 3. Declare Widget_ThirdParty_FancyButton into ThirdPartyStyles and make sure it references the style target resource (named Widget_ThirdParty_FancyButton too). Using the same name for the target style and the attribute is a recommendation (for clarity), but not a requirement. After this is done, you can make a class to group related styles, as done in the Views DSL AppCompat split , so you get type inference, and a nicer syntax.","title":"Using any other xml style"},{"location":"2/views-dsl/#the-most-beautiful-ways-explicitly-named-aliases-to-the-generic-way","text":"Instead of using v<Button>(\u2026) { \u2026 } to create a Button instance, you can use button(\u2026) { \u2026 } . The parameters are exactly the same as view . Such methods exist for most View s and ViewGroup s included in Android, and there\u2019s more in the additional modules . You can see implementations for Views and ViewGroups . These methods are a bit more natural to read and to write, but they are really just inline aliases, purely syntactic sugar. You can define your own if you want. Just make sure to write it first for Context and add two overloads for View and Ui that delegate to the one for Context . Also, remember to make them inline to avoid lambda allocation.","title":"The most beautiful ways: explicitly named aliases to the generic way"},{"location":"2/views-dsl/#view-extensions","text":"For even more expressive UI code, Splitties Views DSL has a transitive dependency on the Views split that provides a useful set of Kotlin-friendly extension functions and properties dedicated to View s and some of their subclasses.","title":"View extensions"},{"location":"2/views-dsl/#inflating-existing-xml-layouts","text":"Splitties Views DSL works well with xml layouts too! The inflate extension functions is a variant to the view function mentioned earlier in this guide which has an additional first parameter: the layout resource id you want to inflate. Also, if the xml layout defines an id for the root view, it will be kept, unless you specified an explicit id (including View.NO_ID ). Just like view , inflate is defined for Context , View and Ui . Here\u2019s a short example: val mySecretFancyView = inflate ( R . layout . my_fancy_layout ) { isVisible = false }","title":"Inflating existing xml layouts"},{"location":"2/views-dsl/#laying-out-the-views","text":"","title":"Laying out the views"},{"location":"2/views-dsl/#viewgroupadd-an-alias-to-viewgroupaddview","text":"To add a View to a ViewGroup in code, you can use View.addView(\u2026) . However, this can become quite redundant to have View repeated over and over when it\u2019s already obvious that you are in a UI centric class that passes a parameter that is clearly a View . That\u2019s why this split has an inline alias to it named just add(\u2026) for ViewGroup . It has the extra benefit of returning the passed View , which can be handy in some situations. The ViewGroup.add(\u2026) function requires an instance of ViewGroup.LayoutParams , see how Splitties helps instantiating it with minimal, yet explicit code.","title":"ViewGroup.add(\u2026), an alias to ViewGroup.addView(\u2026)"},{"location":"2/views-dsl/#viewgroups-extension-functions-to-instantiate-layoutparams","text":"Splitties provides several methods named lParams(\u2026) { \u2026 } for the 2 Android\u2019s built-in ViewGroup s: LinearLayout and FrameLayout . You can find support for additional ViewGroup s in the additional modules . These methods make it easy to instantiate LayoutParams with typesafe and readable code (unlike xml). Here\u2019s the contract that every lParams or alike function must respect: 1. The receiver is the type of the target ViewGroup subclass. 2. The function returns the LayoutParams for the target ViewGroup . 3. The first parameter is width and defaults to wrapContent , unless otherwise noted. 4. The second parameter is height and defaults to the same value as width , unless otherwise noted. 5. The width or height parameters may be missing in case they shall always have the same value for this target ViewGroup or for this function. 5. There may be additional parameters, with default values if possible. 6. The last parameter is a lambda with LayoutParams as a receiver and is executed exactly once, last (i.e. after any logic that the lParams implementation may have). 7. If the lParams function targets a ViewGroup that has a superclass that also has its own LayoutParams , and its own lParams function, it should be named defaultLParams instead to prevent any overload resolution ambiguity. A great example is AppBarLayout that is a child class of LinearLayout and has such extension functions for LayoutParams . 8. In case the function is specialized for non default use case (e.g. adding an AppBarLayout into a CoordinatorLayout ), it can have a custom name, but should always end with LParams (e.g. appBarLParams ).","title":"ViewGroups extension functions to instantiate LayoutParams"},{"location":"2/views-dsl/#warning-regarding-lparams-and-defaultlparams-usage","text":"lParams and similar functions are resolved based on the type of their receiver. However, unless you prepend lParams or defaultLParams call with this. , the received is picked implicitly, and can be indirect, possibly causing the wrong lParams method to be used. Here\u2019s a short, example : You\u2019re in a FrameLayout (because you\u2019re writing a subclass of it, or because of a lambda receiver, like inside frameLayout { \u2026 } ). You call constraintLayout { \u2026 } and start adding views inside it, but when you call lParams , you may use the implementation for FrameLayout , and wonder why the ConstraintLayout.LayoutParams properties and extensions are not available. To highlight such errors, you can prepend this. to your suspicious lParams calls, and if they are in red, then you used the wrong one for the ViewGroup you\u2019re in. The IDE should quickly fix it, adding the proper import at this point. After this is done, you can then safely remove the this. prefix. To avoid this issue, you can be alert when you\u2019re typing/auto-completing lParams and defaultLParams and make sure that you\u2019re selecting the extension for the type of the ViewGroup you\u2019re in (direct parent of the child View you are adding).","title":"WARNING regarding lParams and defaultLParams usage:"},{"location":"2/views-dsl/#other-extensions-for-viewgroup","text":"wrapContent and matchParent inline extensions properties on ViewGroup are convenience aliases to ViewGroup.LayoutParams.WRAP_CONTENT and ViewGroup.LayoutParams.MATCH_PARENT . horizontalMargin , verticalMargin and margin for convenient margins definition in layout parameters ( ViewGroup.MarginLayoutParams which is the base of nearly all LayoutParams). startMargin and endMargin which are compatible below API 17 (using LTR) and fix the inconsistent name ordering ( leftMargin , but marginStart ?).","title":"Other extensions for ViewGroup"},{"location":"2/views-dsl/#the-interface-for-user-interfaces-named-ui","text":"This section doesn\u2019t just writes so many words about how the Ui interface has only 2 properties . It explains why it is useful , how to use it the right way , and the possibilities it offers. FYI, the declaration of this interface looks like this: interface Ui { val ctx : Context val root : View }","title":"The interface for user interfaces, named Ui"},{"location":"2/views-dsl/#why-this-interface","text":"As said above, you can put your UI code directly in an Activity or a Fragment , but the fact you can doesn\u2019t mean you should. Mixing UI code with business logic, data storage code, network calls and miscellaneous boilerplate in the same \u201cgod\u201d class will quickly make further work (like feature additions and maintenance) very hard, because you\u2019re likely not a god programmer, and even if you are, your coworkers, or successors, are likely not. Xml layouts alleviate this issue by forcing you to put most of your UI code into a separate xml file, but you often need complementary code (e.g. to handle transitions, dynamic visibility), and this is often put into a Fragment or an Activity , which makes things worse, as you now have your UI code spread over at least two places that are tightly coupled.","title":"Why this interface"},{"location":"2/views-dsl/#what-it-is-made-of","text":"With Splitties Views DSL, there\u2019s an optional interface named Ui , whose implementations are meant to contain your UI code. It has a ctx property because in Android, a Context is needed to create a View . It has a root property because you need a View to display in the end. Since you\u2019re using Kotlin code, you can put all the UI related logic in it too, in a single place this time. Also, since Ui is an interface, you can get creative by creating sub-interfaces or sub-classes to have different implementations of the same UI, which is nice for A/B testing, user preferences (different styles that the user can pick), configuration (like screen orientation), and more.","title":"What it is made of"},{"location":"2/views-dsl/#implementing-the-ui-interface","text":"When writing a Ui implementation, override the ctx property as the first constructor parameter (e.g. class MainUi(override val ctx: Context) : Ui { ), and override the root parameter as a property with a backing field by assigning it a View (e.g. override val root = coordinatorLayout { ... } ). Then create your views (usually putting them as final properties, like root ), and add them to the ViewGroup s they belong to, so they are direct, or indirect children of root (in the likely case where you have multiple views in your UI and root is therefore a ViewGroup ).","title":"Implementing the Ui interface"},{"location":"2/views-dsl/#using-ui-implementations","text":"To use a Ui implementation from an Activity subclass, just call setContentView(ui) . To use it from any other place, just get the root property. In a Fragment subclass, that will mean returning it from onCreateView(\u2026) . You can also use any function or property you\u2019ve declared in your sub-interface or implementation. Here are two examples: * Using a public property of type Button to set it an OnClickListener in the place where the Ui is used (like an Activity or a Fragment that connects your UI to a ViewModel and any other components). * Call a method called animateGoalReached() .","title":"Using Ui implementations"},{"location":"2/views-dsl/#simple-examples","text":"See concrete examples in MainUi and DemoUi with their respective Activities MainActivity and DemoActivity .","title":"Simple examples"},{"location":"2/views-dsl/#possibilities-brought-by-the-ui-interface","text":"","title":"Possibilities brought by the Ui interface"},{"location":"2/views-dsl/#ide-preview","text":"You can preview Ui implementations in the IDE. See the Views DSL IDE preview split .","title":"IDE Preview"},{"location":"2/views-dsl/#modular-user-interface-contracts","text":"While having a dedicated class for user interface, that is agnostic from where it will be used (Activity, Fragment, IDE Preview\u2026), is a great first step to a modular user interface code, you can go further. Instead of exposing your Ui implementation directly to the Activity or Fragment, you can decide to write several interfaces that define a contract that your Activity, Fragment, ViewModel (beware of leaks), or whatever will need, and implement all of these with one or more classes. For example, let\u2019s say you are developing an email app. You write two interfaces: InboxUi and ComposeUi that both extend the Ui interface. You add to the interfaces all the functions (including any suspend fun ), properties and other symbols you may need to expose to the Activity, Fragment, ViewModel or whatever. Then you implement these two interfaces, with either one class or two, depending on whether you want to display them separately or not.","title":"Modular user interface contracts"},{"location":"2/views-dsl/#easier-multi-form-factors-support","text":"Modular UI contracts open the door to a great benefit: an easier way to support multiple form factors (smartphones, smartwatches, tablets, laptops, cars\u2026). In the previous example, we highlighted the fact that you could have multiple interfaces that expose the needed symbols, and then decide to implement these interfaces in one, or multiple classes. This can help you support different form factors with zero, or only a few changes in non-UI code as it is no longer relies on a specific implementation. It is planned to add such examples in the samples of this repository. If you want to have them faster, please open an issue so the examples can be discussed. Also, maybe you, or someone you know, can contribute.","title":"Easier multi form factors support"},{"location":"2/views-dsl/#multiplatform-user-interface-contracts","text":"Here\u2019s an example of how you may write multiplatform user interface contracts: In Kotlin common code, you would write an interface that is platform agnostic but declares the needed symbols that all platforms can share: Continuing our email app example, you would write these two interfaces: interface InboxUiContract { // Whatever you need } interface ComposeUiContract { // Whatever you need } Then write to sub-interfaces for each platform you want to support, Android and iOS in this example: interface AndroidInboxUi : InboxUiContract , Ui interface IOSInboxUi : InboxUiContract { val root : UIView } And you may finally implement them for each platform, still supporting multiple form-factors and platform variants if needed. The two common interfaces ( InboxUiContract and ComposeUiContract ) could be replaced by abstract classes in case you need to have backing fields, final declarations or final implementations, as long as they don\u2019t reference Splitties Ui interface and no platform specific code.","title":"Multiplatform user interface contracts"},{"location":"2/views-dsl/#testing","text":"Having your user interface as an interface can make it easy to mock it, and simulate user interactions for testing purposes.","title":"Testing"},{"location":"2/views-dsl/#redesign","text":"If you expect an interface for the user interface, then it becomes easy to replace an implementation by another one in case you\u2019re redesigning your app. You can also split your UI contracts (the interface s) into smaller subsets before starting a redesign if needed, this can be helpful if you want to move some UI controls to another area of the application, or just organize things differently.","title":"Redesign"},{"location":"2/views-dsl/#ab-testing","text":"When you have multiple UI interface s implementations, you can then swap them at runtime for A/B testing, allowing you to test which UI works the best for what you determined.","title":"A/B Testing"},{"location":"2/views-dsl/#additional-modules","text":"There are additional splits for extended support. Views DSL\u2026 * AppCompat provides proper styling to Button , TextView , EdiText and other widgets. views like coloredFlatButton . * ConstraintLayout provides support for ConstraintLayout.LayoutParameters . * Design provides extensions for design support library ViewGroup s and bottom sheets. * IDE preview provides the ability to preview your user interfaces right from the IDE. * RecyclerView provides extensions to have scrollbars and proper itemView layout parameters.","title":"Additional modules"},{"location":"2/views-dsl/#download","text":"implementation \"com.louiscad.splitties:splitties-views-dsl:2.1.1\"","title":"Download"},{"location":"2/views-recyclerview/","text":"Views RecyclerView \u00b6 Content \u00b6 RecyclerView extensions \u00b6 The fixedSize extension property for RecyclerView is an alias to the hasFixedSize() and setHasFixedSize(\u2026) methods. functions to create a LinearLayoutManager \u00b6 The verticalLayoutManager and horizontalLayoutManager functions allow you to instantiate and customize a LinearLayoutManager with more idiomatic Kotlin code. functions to create a GridLayoutManager \u00b6 The gridLayoutManager and horizontalGridLayoutManager functions allow you to instantiate and customize a GridLayoutManager with more idiomatic Kotlin code. Download \u00b6 implementation \"com.louiscad.splitties:splitties-views-recyclerview:2.1.1\"","title":"views-recyclerview"},{"location":"2/views-recyclerview/#views-recyclerview","text":"","title":"Views RecyclerView"},{"location":"2/views-recyclerview/#content","text":"","title":"Content"},{"location":"2/views-recyclerview/#recyclerview-extensions","text":"The fixedSize extension property for RecyclerView is an alias to the hasFixedSize() and setHasFixedSize(\u2026) methods.","title":"RecyclerView extensions"},{"location":"2/views-recyclerview/#functions-to-create-a-linearlayoutmanager","text":"The verticalLayoutManager and horizontalLayoutManager functions allow you to instantiate and customize a LinearLayoutManager with more idiomatic Kotlin code.","title":"functions to create a LinearLayoutManager"},{"location":"2/views-recyclerview/#functions-to-create-a-gridlayoutmanager","text":"The gridLayoutManager and horizontalGridLayoutManager functions allow you to instantiate and customize a GridLayoutManager with more idiomatic Kotlin code.","title":"functions to create a GridLayoutManager"},{"location":"2/views-recyclerview/#download","text":"implementation \"com.louiscad.splitties:splitties-views-recyclerview:2.1.1\"","title":"Download"},{"location":"2/views-selectable-appcompat/","text":"Selectable Views AppCompat \u00b6 Selectable Views for AppCompatTextView. Usage \u00b6 Just use SelectableTextView with the proper import instead of TextView or AppCompatTextView , and change the foregroundSelector Drawable if the default doesn\u2019t suit your needs. Download \u00b6 implementation \"com.louiscad.splitties:splitties-views-selectable-appcompat:2.1.1\"","title":"views-selectable-appcompat"},{"location":"2/views-selectable-appcompat/#selectable-views-appcompat","text":"Selectable Views for AppCompatTextView.","title":"Selectable Views AppCompat"},{"location":"2/views-selectable-appcompat/#usage","text":"Just use SelectableTextView with the proper import instead of TextView or AppCompatTextView , and change the foregroundSelector Drawable if the default doesn\u2019t suit your needs.","title":"Usage"},{"location":"2/views-selectable-appcompat/#download","text":"implementation \"com.louiscad.splitties:splitties-views-selectable-appcompat:2.1.1\"","title":"Download"},{"location":"2/views-selectable-constraintlayout/","text":"Selectable Views ConstraintLayout \u00b6 Selectable Views for ConstraintLayout. Usage \u00b6 Just use SelectableConstraintLayout with the proper import instead of ConstraintLayout , and change the foregroundSelector Drawable if the default doesn\u2019t suit your needs. Download \u00b6 implementation \"com.louiscad.splitties:splitties-views-selectable-constraintlayout:2.1.1\"","title":"views-selectable-constraintlayout"},{"location":"2/views-selectable-constraintlayout/#selectable-views-constraintlayout","text":"Selectable Views for ConstraintLayout.","title":"Selectable Views ConstraintLayout"},{"location":"2/views-selectable-constraintlayout/#usage","text":"Just use SelectableConstraintLayout with the proper import instead of ConstraintLayout , and change the foregroundSelector Drawable if the default doesn\u2019t suit your needs.","title":"Usage"},{"location":"2/views-selectable-constraintlayout/#download","text":"implementation \"com.louiscad.splitties:splitties-views-selectable-constraintlayout:2.1.1\"","title":"Download"},{"location":"2/views-selectable/","text":"Selectable Views \u00b6 Selectable Views with foreground property before API 23. This split provides selectable LinearLayout and platform TextView . See also the AppCompat and ConstraintLayout versions. Selectable views are particularly handy for list items that can be clicked. They have a foregroundSelector property that is like foregound property available on FrameLayout and all Views on API 23+. It defaults to android.R.attr.selectableItemBackground , showing visual feedback when the user selects the View (ripple effect on Lollipop and newer Android versions). Usage \u00b6 Just use SelectableLinearLayout and SelectableTextView instead of LinearLayout and TextView , and change the foregroundSelector Drawable if the default doesn\u2019t suit your needs. Download \u00b6 implementation \"com.louiscad.splitties:splitties-views-selectable:2.1.1\"","title":"views-selectable"},{"location":"2/views-selectable/#selectable-views","text":"Selectable Views with foreground property before API 23. This split provides selectable LinearLayout and platform TextView . See also the AppCompat and ConstraintLayout versions. Selectable views are particularly handy for list items that can be clicked. They have a foregroundSelector property that is like foregound property available on FrameLayout and all Views on API 23+. It defaults to android.R.attr.selectableItemBackground , showing visual feedback when the user selects the View (ripple effect on Lollipop and newer Android versions).","title":"Selectable Views"},{"location":"2/views-selectable/#usage","text":"Just use SelectableLinearLayout and SelectableTextView instead of LinearLayout and TextView , and change the foregroundSelector Drawable if the default doesn\u2019t suit your needs.","title":"Usage"},{"location":"2/views-selectable/#download","text":"implementation \"com.louiscad.splitties:splitties-views-selectable:2.1.1\"","title":"Download"},{"location":"2/views/","text":"Views \u00b6 Extensions function and properties on View s. Content \u00b6 This split includes extensions on view related classes. They are helpful when dealing with views programmatically. Depends on AndroidX core KTX \u00b6 Android core KTX already bundles its share of useful extensions for Views. For example, it includes View visibility extension properties like isVisible . To avoid duplication, Splitties deprecated symbols made redundant by Android core KTX, and included the dependency transitively instead. View background properties \u00b6 bg is an alias to the background property for View, but works below API 16, using setBackgroundDrawable(\u2026)`. backgroundColor allows to set the background color of a View using property syntax. ImageView properties \u00b6 imageResource allows to set the image of an ImageView from a resource id using property syntax. imageDrawable allows to get, set or clear the image of an ImageView with a Drawable? using property syntax. imageBitmap allows to set the image of an ImageView from a BitMap using property syntax. Layout direction properties \u00b6 isLtr extension property for View is true on API 16 and lower, or when the layout direction is left to right (like in English). isRtl is !isLtr . Would be true on an API 17+ device setup in Arabic or another RTL language, or when the device is forced to RTL in developer options. View padding properties \u00b6 The following extension properties allow to set the padding of a View using property syntax: padding horizontalPadding verticalPadding topPadding bottomPadding You can also use the setPaddingDp extension function that offers default parameter values. Gravity flags aliases \u00b6 Using Gravity constants on Android is a bit verbose. To alleviate this small issue, this split provides extension properties for View which start with gravity . They cover most use cases and play well with autocomplete. Example: Without Splitties : Gravity.START or Gravity.CENTER_VERTICAL With Splitties : gravityStartCenter List of supported Gravity flags: gravityCenter gravityCenterVertical gravityCenterHorizontal gravityVerticalCenter gravityHorizontalCenter gravityStart gravityTop gravityEnd gravityBottom gravityStartBottom gravityStartTop gravityEndBottom gravityEndTop gravityBottomStart (alias to gravityStartBottom) gravityTopStart (alias to gravityStartTop) gravityBottomEnd (alias to gravityEndBottom) gravityTopEnd (alias to gravityEndTop) gravityStartCenter gravityEndCenter gravityTopCenter gravityBottomCenter LayoutInflater \u00b6 LayoutInflater , Context and ViewGroup have an inflate extension function that make inflating xml easy thanks to type parameter. There\u2019s also an inflateAndAttach extension function for ViewGroup . TextView extensions \u00b6 textResource allows to set the text of a TextView from a string resource id using property syntax. textColorResource allows to set the color of the text of a TextView from a color resource id using property syntax. textAppearance allows to set the text appearance of a TextView from a text appearance style resource id using property syntax, even below API 23. lines allows to set the exact number of lines of a TextView using property syntax. centerText() sets gravity to center and center aligns the text. alignTextToStart() sets gravity to start and start aligns the text. alignTextToEnd() sets gravity to end and end aligns the text. setCompoundDrawables(\u2026) takes Drawable? parameters for start , top , end and bottom which all default to null , plus an intrinsicBounds parameter that defaults to false . setCompoundDrawables(\u2026) has an overload which takes drawable resource ids that default to 0 (no drawable) but no intrinsicBounds parameter (as it is implicitly true). clearCompoundDrawables() clears all compound drawables the TextView has. Click \u00b6 onClick { \u2026 } extension method for View avoids it shadowing if you have other lambdas, while also being more expressive than setOnClickListener { \u2026 } . onLongClick { \u2026 } is similar to onClick { \u2026 } , but also removes the need to have an extra line in the lambda to return true or false . Other \u00b6 The generateViewId() top level function is a backwards compatible and more efficient version of View.generateViewId() that was introduced in Android API 17. The assignAndGetGeneratedId() extension function for View calls generateViewId() assigns it to the view and returns new generated id. The existingOrNewId extension property for View calls assignAndGetGeneratedId() if the view has no id ( 0 / View.NO_ID ), and returns the id of the View, existing or just generated. Download \u00b6 implementation \"com.louiscad.splitties:splitties-views:2.1.1\"","title":"views"},{"location":"2/views/#views","text":"Extensions function and properties on View s.","title":"Views"},{"location":"2/views/#content","text":"This split includes extensions on view related classes. They are helpful when dealing with views programmatically.","title":"Content"},{"location":"2/views/#depends-on-androidx-core-ktx","text":"Android core KTX already bundles its share of useful extensions for Views. For example, it includes View visibility extension properties like isVisible . To avoid duplication, Splitties deprecated symbols made redundant by Android core KTX, and included the dependency transitively instead.","title":"Depends on AndroidX core KTX"},{"location":"2/views/#view-background-properties","text":"bg is an alias to the background property for View, but works below API 16, using setBackgroundDrawable(\u2026)`. backgroundColor allows to set the background color of a View using property syntax.","title":"View background properties"},{"location":"2/views/#imageview-properties","text":"imageResource allows to set the image of an ImageView from a resource id using property syntax. imageDrawable allows to get, set or clear the image of an ImageView with a Drawable? using property syntax. imageBitmap allows to set the image of an ImageView from a BitMap using property syntax.","title":"ImageView properties"},{"location":"2/views/#layout-direction-properties","text":"isLtr extension property for View is true on API 16 and lower, or when the layout direction is left to right (like in English). isRtl is !isLtr . Would be true on an API 17+ device setup in Arabic or another RTL language, or when the device is forced to RTL in developer options.","title":"Layout direction properties"},{"location":"2/views/#view-padding-properties","text":"The following extension properties allow to set the padding of a View using property syntax: padding horizontalPadding verticalPadding topPadding bottomPadding You can also use the setPaddingDp extension function that offers default parameter values.","title":"View padding properties"},{"location":"2/views/#gravity-flags-aliases","text":"Using Gravity constants on Android is a bit verbose. To alleviate this small issue, this split provides extension properties for View which start with gravity . They cover most use cases and play well with autocomplete. Example: Without Splitties : Gravity.START or Gravity.CENTER_VERTICAL With Splitties : gravityStartCenter List of supported Gravity flags: gravityCenter gravityCenterVertical gravityCenterHorizontal gravityVerticalCenter gravityHorizontalCenter gravityStart gravityTop gravityEnd gravityBottom gravityStartBottom gravityStartTop gravityEndBottom gravityEndTop gravityBottomStart (alias to gravityStartBottom) gravityTopStart (alias to gravityStartTop) gravityBottomEnd (alias to gravityEndBottom) gravityTopEnd (alias to gravityEndTop) gravityStartCenter gravityEndCenter gravityTopCenter gravityBottomCenter","title":"Gravity flags aliases"},{"location":"2/views/#layoutinflater","text":"LayoutInflater , Context and ViewGroup have an inflate extension function that make inflating xml easy thanks to type parameter. There\u2019s also an inflateAndAttach extension function for ViewGroup .","title":"LayoutInflater"},{"location":"2/views/#textview-extensions","text":"textResource allows to set the text of a TextView from a string resource id using property syntax. textColorResource allows to set the color of the text of a TextView from a color resource id using property syntax. textAppearance allows to set the text appearance of a TextView from a text appearance style resource id using property syntax, even below API 23. lines allows to set the exact number of lines of a TextView using property syntax. centerText() sets gravity to center and center aligns the text. alignTextToStart() sets gravity to start and start aligns the text. alignTextToEnd() sets gravity to end and end aligns the text. setCompoundDrawables(\u2026) takes Drawable? parameters for start , top , end and bottom which all default to null , plus an intrinsicBounds parameter that defaults to false . setCompoundDrawables(\u2026) has an overload which takes drawable resource ids that default to 0 (no drawable) but no intrinsicBounds parameter (as it is implicitly true). clearCompoundDrawables() clears all compound drawables the TextView has.","title":"TextView extensions"},{"location":"2/views/#click","text":"onClick { \u2026 } extension method for View avoids it shadowing if you have other lambdas, while also being more expressive than setOnClickListener { \u2026 } . onLongClick { \u2026 } is similar to onClick { \u2026 } , but also removes the need to have an extra line in the lambda to return true or false .","title":"Click"},{"location":"2/views/#other","text":"The generateViewId() top level function is a backwards compatible and more efficient version of View.generateViewId() that was introduced in Android API 17. The assignAndGetGeneratedId() extension function for View calls generateViewId() assigns it to the view and returns new generated id. The existingOrNewId extension property for View calls assignAndGetGeneratedId() if the view has no id ( 0 / View.NO_ID ), and returns the id of the View, existing or just generated.","title":"Other"},{"location":"2/views/#download","text":"implementation \"com.louiscad.splitties:splitties-views:2.1.1\"","title":"Download"},{"location":"3/activities/","text":"Activities \u00b6 Start activities with minimal boilerplate. Supported platforms: Android . Content \u00b6 Starting Activities \u00b6 The start extension function for Context takes advantage of reified type parameters to allow you to write such code: start<AboutActivity>() . There\u2019s an optional lambda where the Intent is the receiver so you can edit it (e.g. adding flags) before the activity is started with it. The startActivity extension function for Context is designed for implicit intents. It expects the Intent action as first parameter, and takes an optional lambda to edit the intent further, like start . Download \u00b6 implementation ( \"com.louiscad.splitties:splitties-activities:3.0.0-beta01\" )","title":"activities"},{"location":"3/activities/#activities","text":"Start activities with minimal boilerplate. Supported platforms: Android .","title":"Activities"},{"location":"3/activities/#content","text":"","title":"Content"},{"location":"3/activities/#starting-activities","text":"The start extension function for Context takes advantage of reified type parameters to allow you to write such code: start<AboutActivity>() . There\u2019s an optional lambda where the Intent is the receiver so you can edit it (e.g. adding flags) before the activity is started with it. The startActivity extension function for Context is designed for implicit intents. It expects the Intent action as first parameter, and takes an optional lambda to edit the intent further, like start .","title":"Starting Activities"},{"location":"3/activities/#download","text":"implementation ( \"com.louiscad.splitties:splitties-activities:3.0.0-beta01\" )","title":"Download"},{"location":"3/alertdialog-appcompat-coroutines/","text":"Alert Dialog AppCompat Coroutines \u00b6 showAndAwait extension functions for AppCompat AlertDialog. Supported platforms: Android . Example \u00b6 import splitties.alertdialog.appcompat.alertDialog import splitties.alertdialog.appcompat.messageResource import splitties.alertdialog.appcompat.coroutines.showAndAwait import splitties.resources.txt suspend fun shouldWeReallyDeleteFromTrash (): Boolean = alertDialog ( message = txt ( R . string . dialog_msg_confirm_delete_from_trash ) ). showAndAwait ( okValue = true , cancelValue = false , dismissValue = false ) Download \u00b6 implementation ( \"com.louiscad.splitties:splitties-alertdialog-appcompat-coroutines:3.0.0-beta01\" )","title":"alertdialog-appcompat-coroutines"},{"location":"3/alertdialog-appcompat-coroutines/#alert-dialog-appcompat-coroutines","text":"showAndAwait extension functions for AppCompat AlertDialog. Supported platforms: Android .","title":"Alert Dialog AppCompat Coroutines"},{"location":"3/alertdialog-appcompat-coroutines/#example","text":"import splitties.alertdialog.appcompat.alertDialog import splitties.alertdialog.appcompat.messageResource import splitties.alertdialog.appcompat.coroutines.showAndAwait import splitties.resources.txt suspend fun shouldWeReallyDeleteFromTrash (): Boolean = alertDialog ( message = txt ( R . string . dialog_msg_confirm_delete_from_trash ) ). showAndAwait ( okValue = true , cancelValue = false , dismissValue = false )","title":"Example"},{"location":"3/alertdialog-appcompat-coroutines/#download","text":"implementation ( \"com.louiscad.splitties:splitties-alertdialog-appcompat-coroutines:3.0.0-beta01\" )","title":"Download"},{"location":"3/alertdialog-appcompat/","text":"Alert Dialog AppCompat \u00b6 Create simple alert dialogs with simple code Supported platforms: Android . You may also need the Material version and the coroutines extensions . Example \u00b6 import splitties.alertdialog.appcompat.alertDialog import splitties.alertdialog.appcompat.cancelButton import splitties.alertdialog.appcompat.messageResource import splitties.alertdialog.appcompat.okButton import splitties.alertdialog.appcompat.onShow import splitties.alertdialog.appcompat.positiveButton class YourActivity : AppCompatActivity { //... private fun doIrreversibleStuffOrCancel () { alertDialog { messageResource = R . string . dialog_msg_confirm_irreversible_stuff okButton { irreversibleStuff () } cancelButton () }. onShow { positiveButton . textColorResource = R . color . red_500 }. show () } } Download \u00b6 implementation ( \"com.louiscad.splitties:splitties-alertdialog-appcompat:3.0.0-beta01\" )","title":"alertdialog-appcompat"},{"location":"3/alertdialog-appcompat/#alert-dialog-appcompat","text":"Create simple alert dialogs with simple code Supported platforms: Android . You may also need the Material version and the coroutines extensions .","title":"Alert Dialog AppCompat"},{"location":"3/alertdialog-appcompat/#example","text":"import splitties.alertdialog.appcompat.alertDialog import splitties.alertdialog.appcompat.cancelButton import splitties.alertdialog.appcompat.messageResource import splitties.alertdialog.appcompat.okButton import splitties.alertdialog.appcompat.onShow import splitties.alertdialog.appcompat.positiveButton class YourActivity : AppCompatActivity { //... private fun doIrreversibleStuffOrCancel () { alertDialog { messageResource = R . string . dialog_msg_confirm_irreversible_stuff okButton { irreversibleStuff () } cancelButton () }. onShow { positiveButton . textColorResource = R . color . red_500 }. show () } }","title":"Example"},{"location":"3/alertdialog-appcompat/#download","text":"implementation ( \"com.louiscad.splitties:splitties-alertdialog-appcompat:3.0.0-beta01\" )","title":"Download"},{"location":"3/alertdialog-material/","text":"Alert Dialog Material \u00b6 Create simple alert dialogs in material design with simple code Supported platforms: Android . Example \u00b6 import splitties.alertdialog.material.materialAlertDialog import splitties.alertdialog.appcompat.cancelButton import splitties.alertdialog.appcompat.messageResource import splitties.alertdialog.appcompat.okButton import splitties.alertdialog.appcompat.onShow import splitties.alertdialog.appcompat.positiveButton class YourActivity : AppCompatActivity { //... private fun doIrreversibleStuffOrCancel () { materialAlertDialog { messageResource = R . string . dialog_msg_confirm_irreversible_stuff okButton { irreversibleStuff () } cancelButton () }. onShow { positiveButton . textColorResource = R . color . red_500 }. show () } } Download \u00b6 implementation ( \"com.louiscad.splitties:splitties-alertdialog-material:3.0.0-beta01\" )","title":"alertdialog-material"},{"location":"3/alertdialog-material/#alert-dialog-material","text":"Create simple alert dialogs in material design with simple code Supported platforms: Android .","title":"Alert Dialog Material"},{"location":"3/alertdialog-material/#example","text":"import splitties.alertdialog.material.materialAlertDialog import splitties.alertdialog.appcompat.cancelButton import splitties.alertdialog.appcompat.messageResource import splitties.alertdialog.appcompat.okButton import splitties.alertdialog.appcompat.onShow import splitties.alertdialog.appcompat.positiveButton class YourActivity : AppCompatActivity { //... private fun doIrreversibleStuffOrCancel () { materialAlertDialog { messageResource = R . string . dialog_msg_confirm_irreversible_stuff okButton { irreversibleStuff () } cancelButton () }. onShow { positiveButton . textColorResource = R . color . red_500 }. show () } }","title":"Example"},{"location":"3/alertdialog-material/#download","text":"implementation ( \"com.louiscad.splitties:splitties-alertdialog-material:3.0.0-beta01\" )","title":"Download"},{"location":"3/alertdialog/","text":"Alert Dialog \u00b6 Create simple alert dialogs with simple code Supported platforms: Android . You may be looking for the Material version or the AppCompat version . Example \u00b6 import splitties.alertdialog.alertDialog import splitties.alertdialog.cancelButton import splitties.alertdialog.messageResource import splitties.alertdialog.okButton import splitties.alertdialog.onShow import splitties.alertdialog.positiveButton class YourActivity : AppCompatActivity { //... private fun doIrreversibleStuffOrCancel () { alertDialog { messageResource = R . string . dialog_msg_confirm_irreversible_stuff okButton { irreversibleStuff () } cancelButton () }. onShow { positiveButton . textColorResource = R . color . red_500 }. show () } } Download \u00b6 implementation ( \"com.louiscad.splitties:splitties-alertdialog:3.0.0-beta01\" )","title":"alertdialog"},{"location":"3/alertdialog/#alert-dialog","text":"Create simple alert dialogs with simple code Supported platforms: Android . You may be looking for the Material version or the AppCompat version .","title":"Alert Dialog"},{"location":"3/alertdialog/#example","text":"import splitties.alertdialog.alertDialog import splitties.alertdialog.cancelButton import splitties.alertdialog.messageResource import splitties.alertdialog.okButton import splitties.alertdialog.onShow import splitties.alertdialog.positiveButton class YourActivity : AppCompatActivity { //... private fun doIrreversibleStuffOrCancel () { alertDialog { messageResource = R . string . dialog_msg_confirm_irreversible_stuff okButton { irreversibleStuff () } cancelButton () }. onShow { positiveButton . textColorResource = R . color . red_500 }. show () } }","title":"Example"},{"location":"3/alertdialog/#download","text":"implementation ( \"com.louiscad.splitties:splitties-alertdialog:3.0.0-beta01\" )","title":"Download"},{"location":"3/appctx/","text":"App Context \u00b6 Always have your application Context at hand with appCtx . Supported platforms: Android . This split provides two read-only properties: appCtx that returns your Application Context directBootCtx for your direct boot aware components where storage is involved, if any. It also brings these 2 extensions functions on Context for advanced usages: - injectAsAppCtx() - canLeakMemory() You can use appCtx and directBootCtx anywhere in your app (without risking leaking a short-lived context such as an Activity or a Service). This makes writing code that needs a Context for non Activity specific purposes more convenient. Important: use the right context! \u00b6 You may not want to use the Application Context in some cases. Context for storage \u00b6 If you need a Context to access storage from a library (for SharedPreferences, a database or other files), you should allow passing a specific Context that could default as appCtx , so it is possible for target apps to use a special Context like directBootCtx . Configuration dependent or themed Context \u00b6 Devices on which your app/library runs may (will) change configuration during the app\u2019s process lifecycle, such as screen density, language or orientation. Please, do not use appCtx or directBootCtx if you rely on a \u201cscoped\u201d Context to access themed resources from an Activity, or configuration dependent values/resources. Note that in some cases, configuration dependent context usage may be ok if your component handles onConfigurationChanged() properly. More generally, if you wonder if using Application Context is ok, test your app against configuration changes that may affect it and check it reacts correctly. How it works \u00b6 This library takes advantage of Content Providers to automatically initialize appCtx for you before even your Application \u2018s onCreate() is called! This library also takes advantage of manifest placeholders (with the default ${applicationId} ) and gradle manifest merging to avoid two apps using this library clashing with same authority Content Providers. This is the same trick used by Firebase to auto-initialize the library. You can read more on this here . Advanced use cases \u00b6 Multi-process apps and libraries \u00b6 While most apps run on single-process, on the default one, some need to run some components in different processes. If your app needs to access appCtx or directBootCtx directly, or indirectly in a component that has it\u2019s android:process tag in AndroidManifest.xml set to :the_name_of_your_private_process or the_fully_qualified_name_of_your_shared_process , you have 3 solutions: 1. Do nothing and let appCtx init itself with reflection on first access 2. Call injectAsAppCtx() in the onCreate() method of your custom Application subclass. 3. Subclass AppCtxInitProvider and declare it correctly in your AndroidManifest.xml for each non default process. This option may be the best one if you\u2019re making a library that has its own process as no further configuration will be required on the app side. See instructions below: How to declare an AppCtxInitProvider correctly (for multi-process usage) \u00b6 Subclass AppCtxInitProvider Register your subclass as a provider in your AndroidManifest.xml file. Specify it\u2019s android:process attribute to the name of your app\u2019s non default process. (beware of typos) Set android:exported to false. Set android:authorities to something other than ${applicationId}.appctxinitprovider . The suggested naming convention is ${applicationId}.appctxinitprovider.the_name_of_your_process so the content provider authority doesn\u2019t clash with another one from your app, or from a third-party app. If your component is Direct Boot aware, add android:directBootAware=\"true\" . If you use appCtx or directBootCtx in another Content Provider, make sure to specify android:initOrder to a higher value than the one of the other Content Provider which use the ctx properties. The result should look like this: <provider android:name= \".SecondProcessInitProvider\" android:authorities= \"${applicationId}.appctxinitprovider.second_process\" android:exported= \"false\" android:initOrder= \"900\" android:process= \":second_process\" /> import AppCtxInitProvider class SecondProcessInitProvider : AppCtxInitProvider () Download \u00b6 implementation ( \"com.louiscad.splitties:splitties-appctx:3.0.0-beta01\" )","title":"appctx"},{"location":"3/appctx/#app-context","text":"Always have your application Context at hand with appCtx . Supported platforms: Android . This split provides two read-only properties: appCtx that returns your Application Context directBootCtx for your direct boot aware components where storage is involved, if any. It also brings these 2 extensions functions on Context for advanced usages: - injectAsAppCtx() - canLeakMemory() You can use appCtx and directBootCtx anywhere in your app (without risking leaking a short-lived context such as an Activity or a Service). This makes writing code that needs a Context for non Activity specific purposes more convenient.","title":"App Context"},{"location":"3/appctx/#important-use-the-right-context","text":"You may not want to use the Application Context in some cases.","title":"Important: use the right context!"},{"location":"3/appctx/#context-for-storage","text":"If you need a Context to access storage from a library (for SharedPreferences, a database or other files), you should allow passing a specific Context that could default as appCtx , so it is possible for target apps to use a special Context like directBootCtx .","title":"Context for storage"},{"location":"3/appctx/#configuration-dependent-or-themed-context","text":"Devices on which your app/library runs may (will) change configuration during the app\u2019s process lifecycle, such as screen density, language or orientation. Please, do not use appCtx or directBootCtx if you rely on a \u201cscoped\u201d Context to access themed resources from an Activity, or configuration dependent values/resources. Note that in some cases, configuration dependent context usage may be ok if your component handles onConfigurationChanged() properly. More generally, if you wonder if using Application Context is ok, test your app against configuration changes that may affect it and check it reacts correctly.","title":"Configuration dependent or themed Context"},{"location":"3/appctx/#how-it-works","text":"This library takes advantage of Content Providers to automatically initialize appCtx for you before even your Application \u2018s onCreate() is called! This library also takes advantage of manifest placeholders (with the default ${applicationId} ) and gradle manifest merging to avoid two apps using this library clashing with same authority Content Providers. This is the same trick used by Firebase to auto-initialize the library. You can read more on this here .","title":"How it works"},{"location":"3/appctx/#advanced-use-cases","text":"","title":"Advanced use cases"},{"location":"3/appctx/#multi-process-apps-and-libraries","text":"While most apps run on single-process, on the default one, some need to run some components in different processes. If your app needs to access appCtx or directBootCtx directly, or indirectly in a component that has it\u2019s android:process tag in AndroidManifest.xml set to :the_name_of_your_private_process or the_fully_qualified_name_of_your_shared_process , you have 3 solutions: 1. Do nothing and let appCtx init itself with reflection on first access 2. Call injectAsAppCtx() in the onCreate() method of your custom Application subclass. 3. Subclass AppCtxInitProvider and declare it correctly in your AndroidManifest.xml for each non default process. This option may be the best one if you\u2019re making a library that has its own process as no further configuration will be required on the app side. See instructions below:","title":"Multi-process apps and libraries"},{"location":"3/appctx/#how-to-declare-an-appctxinitprovider-correctly-for-multi-process-usage","text":"Subclass AppCtxInitProvider Register your subclass as a provider in your AndroidManifest.xml file. Specify it\u2019s android:process attribute to the name of your app\u2019s non default process. (beware of typos) Set android:exported to false. Set android:authorities to something other than ${applicationId}.appctxinitprovider . The suggested naming convention is ${applicationId}.appctxinitprovider.the_name_of_your_process so the content provider authority doesn\u2019t clash with another one from your app, or from a third-party app. If your component is Direct Boot aware, add android:directBootAware=\"true\" . If you use appCtx or directBootCtx in another Content Provider, make sure to specify android:initOrder to a higher value than the one of the other Content Provider which use the ctx properties. The result should look like this: <provider android:name= \".SecondProcessInitProvider\" android:authorities= \"${applicationId}.appctxinitprovider.second_process\" android:exported= \"false\" android:initOrder= \"900\" android:process= \":second_process\" /> import AppCtxInitProvider class SecondProcessInitProvider : AppCtxInitProvider ()","title":"How to declare an AppCtxInitProvider correctly (for multi-process usage)"},{"location":"3/appctx/#download","text":"implementation ( \"com.louiscad.splitties:splitties-appctx:3.0.0-beta01\" )","title":"Download"},{"location":"3/arch-lifecycle/","text":"Arch Lifecycle \u00b6 Extensions to get ViewModel s, use LiveData and observe Lifecycle s. Supported platforms: Android . This makes using Android Architecture Components nicer in Kotlin. Content \u00b6 LifecycleObserver \u00b6 This is a LifecycleEventObserver sub-interface that has lifecycle state change methods (like onResume(\u2026) or onPause(\u2026) ) with default implementations, so you override only the ones you need. ViewModel providers \u00b6 AndroidX Activity KTX and Fragment KTX provide convenient delegates to get a ViewModel subclass instance, but they lack a facility when you need to pass arguments to a ViewModel . Splitties brings a version that takes a lambda, allowing you to run any logic before instantiating the ViewModel, including accessing the created Activity or Fragment . class YourActivity : AppCompatActivity () { private val viewModel : SomeViewModel by viewModels () // From androidx.activity KTX private val anotherViewModel by viewModels < AnotherViewModel >() // From androidx.activity KTX private val yourViewModel by viewModels { // From Splitties YourViewModel ( someParams ) } } class SomeFragment : Fragment () { private val viewModel : SomeViewModel by viewModels () // From androidx.activity KTX private val anotherViewModel : AnotherViewModel by activityViewModels () // From androidx.activity KTX private val yourViewModel by viewModels { // From Splitties YourViewModel ( someParams ) } } LiveData observing and map extension \u00b6 observe and observeNotNull extension functions on LifecycleOwner \u00b6 These extensions make observing a LiveData null-safe (despite LiveData not being null-safe itself), giving you the choice of whether you want to deal with nulls or ignore them. class YourActivity : AppCompatActivity () { private val viewModel by activityScope < YourViewModel >() override fun onCreate ( savedInstanceState : Bundle ?) { observe ( viewModel . yourLiveData ) { data : YourData ? -> updateUi ( data ) } observeNotNull ( viewModel . anotherLiveData ) { doSomething ( it . someProperty ) doSomethingElse ( it ) } } } map extension function on LiveData \u00b6 class YourViewModel : ViewModel () { val yourLiveData : LiveData < YourData > = createYourLiveData () val anotherLiveData = yourLiveData . map { it ?. someProperty } } Note that the map lambda runs on UI thread, so very light operations like getting a property is right, but long/blocking operations are not (would result in lags or ANRs). Download \u00b6 implementation ( \"com.louiscad.splitties:splitties-arch-lifecycle:3.0.0-beta01\" )","title":"arch-lifecycle"},{"location":"3/arch-lifecycle/#arch-lifecycle","text":"Extensions to get ViewModel s, use LiveData and observe Lifecycle s. Supported platforms: Android . This makes using Android Architecture Components nicer in Kotlin.","title":"Arch Lifecycle"},{"location":"3/arch-lifecycle/#content","text":"","title":"Content"},{"location":"3/arch-lifecycle/#lifecycleobserver","text":"This is a LifecycleEventObserver sub-interface that has lifecycle state change methods (like onResume(\u2026) or onPause(\u2026) ) with default implementations, so you override only the ones you need.","title":"LifecycleObserver"},{"location":"3/arch-lifecycle/#viewmodel-providers","text":"AndroidX Activity KTX and Fragment KTX provide convenient delegates to get a ViewModel subclass instance, but they lack a facility when you need to pass arguments to a ViewModel . Splitties brings a version that takes a lambda, allowing you to run any logic before instantiating the ViewModel, including accessing the created Activity or Fragment . class YourActivity : AppCompatActivity () { private val viewModel : SomeViewModel by viewModels () // From androidx.activity KTX private val anotherViewModel by viewModels < AnotherViewModel >() // From androidx.activity KTX private val yourViewModel by viewModels { // From Splitties YourViewModel ( someParams ) } } class SomeFragment : Fragment () { private val viewModel : SomeViewModel by viewModels () // From androidx.activity KTX private val anotherViewModel : AnotherViewModel by activityViewModels () // From androidx.activity KTX private val yourViewModel by viewModels { // From Splitties YourViewModel ( someParams ) } }","title":"ViewModel providers"},{"location":"3/arch-lifecycle/#livedata-observing-and-map-extension","text":"","title":"LiveData observing and map extension"},{"location":"3/arch-lifecycle/#observe-and-observenotnull-extension-functions-on-lifecycleowner","text":"These extensions make observing a LiveData null-safe (despite LiveData not being null-safe itself), giving you the choice of whether you want to deal with nulls or ignore them. class YourActivity : AppCompatActivity () { private val viewModel by activityScope < YourViewModel >() override fun onCreate ( savedInstanceState : Bundle ?) { observe ( viewModel . yourLiveData ) { data : YourData ? -> updateUi ( data ) } observeNotNull ( viewModel . anotherLiveData ) { doSomething ( it . someProperty ) doSomethingElse ( it ) } } }","title":"observe and observeNotNull extension functions on LifecycleOwner"},{"location":"3/arch-lifecycle/#map-extension-function-on-livedata","text":"class YourViewModel : ViewModel () { val yourLiveData : LiveData < YourData > = createYourLiveData () val anotherLiveData = yourLiveData . map { it ?. someProperty } } Note that the map lambda runs on UI thread, so very light operations like getting a property is right, but long/blocking operations are not (would result in lags or ANRs).","title":"map extension function on LiveData"},{"location":"3/arch-lifecycle/#download","text":"implementation ( \"com.louiscad.splitties:splitties-arch-lifecycle:3.0.0-beta01\" )","title":"Download"},{"location":"3/arch-room/","text":"Arch Room \u00b6 Room helpers to instantiate your DB and perform transactions in Kotlin. Supported platforms: Android . Content \u00b6 Room Database instantiation \u00b6 The roomDb(\u2026) function has a reified type parameter used to call Room.databaseBuilder with the proper arguments. name is the only required parameter. You can specify a Context as first parameter if you don\u2019t want to use the application context, if you want to use a different context (e.g. to use directBootCtx in a direct boot aware app component). The last parameter is a lambda with the db builder as receiver where you can things like migrations. Room Database transactions \u00b6 transaction { \u2026 } is the inline version of runInTransaction , with your database as receiver. inTransaction { \u2026 } does the same as transaction { \u2026 } but returns the value of the last expression of the lambda. Inlining brings a slight performance improvement at runtime and reduces the number of classes, making the apk smaller. Download \u00b6 implementation ( \"com.louiscad.splitties:splitties-arch-room:3.0.0-beta01\" )","title":"arch-room"},{"location":"3/arch-room/#arch-room","text":"Room helpers to instantiate your DB and perform transactions in Kotlin. Supported platforms: Android .","title":"Arch Room"},{"location":"3/arch-room/#content","text":"","title":"Content"},{"location":"3/arch-room/#room-database-instantiation","text":"The roomDb(\u2026) function has a reified type parameter used to call Room.databaseBuilder with the proper arguments. name is the only required parameter. You can specify a Context as first parameter if you don\u2019t want to use the application context, if you want to use a different context (e.g. to use directBootCtx in a direct boot aware app component). The last parameter is a lambda with the db builder as receiver where you can things like migrations.","title":"Room Database instantiation"},{"location":"3/arch-room/#room-database-transactions","text":"transaction { \u2026 } is the inline version of runInTransaction , with your database as receiver. inTransaction { \u2026 } does the same as transaction { \u2026 } but returns the value of the last expression of the lambda. Inlining brings a slight performance improvement at runtime and reduces the number of classes, making the apk smaller.","title":"Room Database transactions"},{"location":"3/arch-room/#download","text":"implementation ( \"com.louiscad.splitties:splitties-arch-room:3.0.0-beta01\" )","title":"Download"},{"location":"3/bitflags/","text":"Bit Flags \u00b6 hasFlag , withFlag and minusFlag extensions on Long , Int , Short , Byte , and their unsigned counterparts. Supported platforms: Linux (x64), MingW (x64) , macOS (x64), iOS (arm32, arm64 & x64), JS , JVM (including Android). These extensions make dealing with bit flags easier. These small inline extensions can be proven handy since bit flags are found in multiple places over the Android API, in low level stuff when you have to deal with raw bytes, and maybe in your own codebase too. Download \u00b6 implementation ( \"com.louiscad.splitties:splitties-bitflags:3.0.0-beta01\" )","title":"bitflags"},{"location":"3/bitflags/#bit-flags","text":"hasFlag , withFlag and minusFlag extensions on Long , Int , Short , Byte , and their unsigned counterparts. Supported platforms: Linux (x64), MingW (x64) , macOS (x64), iOS (arm32, arm64 & x64), JS , JVM (including Android). These extensions make dealing with bit flags easier. These small inline extensions can be proven handy since bit flags are found in multiple places over the Android API, in low level stuff when you have to deal with raw bytes, and maybe in your own codebase too.","title":"Bit Flags"},{"location":"3/bitflags/#download","text":"implementation ( \"com.louiscad.splitties:splitties-bitflags:3.0.0-beta01\" )","title":"Download"},{"location":"3/bundle/","text":"Bundle \u00b6 BundleSpec to use Bundle with property syntax for Intent extras and more. Supported platforms: Android . Non-exhaustive list of use cases \u00b6 Intent extras of Activities, BroadcastReceivers, Services, etc. Instance state of Activities, Fragments and Views. Can be used for Activity extras, but also in Service extras, BroadcastReceiver and other parts where an Intent or a Bundle is used. Usage \u00b6 For Activity extras \u00b6 Let\u2019s say you have an Activity subclass named YourActivity . In YourActivity , add a nested object named ExtrasSpec . Make it extend BundleSpec . For each required Intent extra you need, in ExtrasSpec , add a var property with explicit non null type, delegated by bundle() . For each optional Intent extra you need, still in ExtrasSpec , add a var property with either and explicit nullable type, delegated by bundleOrNull() , or with a non null type, delegated by bundleOrDefault(\u2026) or by bundleOrElse { \u2026 } . When setting up the Intent to start your Activity , call putExtras(YourActivity.ExtrasSpec) { \u2026 } on it, setting values on the ExtrasSpec properties in the lambda. From YourActivity , call withExtras(ExtrasSpec) { \u2026 } to get the extras as properties from the lambda (the result of the call is the result of the lambda). Other usages \u00b6 Only Activity has a withExtras(\u2026) { \u2026 } extension, but you can use with(\u2026) { \u2026 } extension on any Bundle and any Intent extras . The putExtras(\u2026) { \u2026 } extension works on any Intent , Activity or not. See the examples below. Important details \u00b6 See the implementation of the put(\u2026) extension on Bundle to check all the supported types (it is likely to suit your needs). You may only access the delegated properties of a BundleSpec subclass inside the withExtras(\u2026) { \u2026 } lambda or inside the someBundle.with(\u2026) { \u2026 } lambda. If you violate this rule, an IllegalStateException will be thrown. The implementation has been optimized for efficiency. The delegates under bundle() and bundleOrNull() are singletons and are shared for all properties app-wide. The versions that accept a key or a default value can\u2019t be singletons, but since you\u2019re likely using them in object backed specs, they are instantiated only once per property, having a minimal memory impact (especially when compared to the cost of data serialization in Bundles). Examples \u00b6 Extras in an Activity \u00b6 class DemoActivity : AppCompatActivity () { object ExtrasSpec : BundleSpec () { var userName : String by bundle () // Required extra var showGreetingToast by bundleOrDefault ( false ) // Optional extra, defaults to false var optionalExtra : String ? by bundleOrNull () // Optional extra } override fun onCreate ( savedInstanceState : Bundle ?) { super . onCreate ( savedInstanceState ) withExtras ( ExtrasSpec ) { // Populates ExtrasSpec with actual extras if ( showGreetingToast ) toast ( android . R . string . ok ) optionalExtras ?. forEach { Timber . i ( \"Character from optional extra: $it\" ) } } restOfYourCode () } } class StartDemoActivity : AppCompatActivity () { private fun someFunction ( name : String , isUserPolite : Boolean = false ) { startActivity ( Intent ( this , DemoActivity :: class . java ). apply { putExtras ( DemoActivity . ExtrasSpec ) { userName = name showGreetingToast = isUserPolite } }) } } Extras in a BroadcastReceiver \u00b6 class AirplaneModeReceiver : BroadcastReceiver () { object ExtrasSpec : BundleSpec () { var isAirplaneModeOn : Boolean by bundle ( \"state\" ) } override fun onReceive ( context : Context , intent : Intent ) { if ( intent . action != Intent . ACTION_AIRPLANE_MODE_CHANGED ) return val isAirplaneModeOn = intent . extras . with ( ExtrasSpec ) { isAirplaneModeOn } handleAirplaneMode ( isAirplaneModeOn ) } } Instance State in an Activity \u00b6 class DemoActivity : AppCompatActivity () { private object InstanceStateSpec : BundleSpec () { var startTime : Long by bundle () } private var startTimestamp = 0L override fun onCreate ( savedInstanceState : Bundle ?) { super . onCreate ( savedInstanceState ) startTimestamp = savedInstanceState ?. with ( InstanceStateSpec ) { startTime } ?: System . currentTimeMillis () restOfYourCode () } override fun onSaveInstanceState ( outState : Bundle ) { outState . with ( InstanceStateSpec ) { startTime = startTimestamp } super . onSaveInstanceState ( outState ) } } Download \u00b6 implementation ( \"com.louiscad.splitties:splitties-bundle:3.0.0-beta01\" )","title":"bundle"},{"location":"3/bundle/#bundle","text":"BundleSpec to use Bundle with property syntax for Intent extras and more. Supported platforms: Android .","title":"Bundle"},{"location":"3/bundle/#non-exhaustive-list-of-use-cases","text":"Intent extras of Activities, BroadcastReceivers, Services, etc. Instance state of Activities, Fragments and Views. Can be used for Activity extras, but also in Service extras, BroadcastReceiver and other parts where an Intent or a Bundle is used.","title":"Non-exhaustive list of use cases"},{"location":"3/bundle/#usage","text":"","title":"Usage"},{"location":"3/bundle/#for-activity-extras","text":"Let\u2019s say you have an Activity subclass named YourActivity . In YourActivity , add a nested object named ExtrasSpec . Make it extend BundleSpec . For each required Intent extra you need, in ExtrasSpec , add a var property with explicit non null type, delegated by bundle() . For each optional Intent extra you need, still in ExtrasSpec , add a var property with either and explicit nullable type, delegated by bundleOrNull() , or with a non null type, delegated by bundleOrDefault(\u2026) or by bundleOrElse { \u2026 } . When setting up the Intent to start your Activity , call putExtras(YourActivity.ExtrasSpec) { \u2026 } on it, setting values on the ExtrasSpec properties in the lambda. From YourActivity , call withExtras(ExtrasSpec) { \u2026 } to get the extras as properties from the lambda (the result of the call is the result of the lambda).","title":"For Activity extras"},{"location":"3/bundle/#other-usages","text":"Only Activity has a withExtras(\u2026) { \u2026 } extension, but you can use with(\u2026) { \u2026 } extension on any Bundle and any Intent extras . The putExtras(\u2026) { \u2026 } extension works on any Intent , Activity or not. See the examples below.","title":"Other usages"},{"location":"3/bundle/#important-details","text":"See the implementation of the put(\u2026) extension on Bundle to check all the supported types (it is likely to suit your needs). You may only access the delegated properties of a BundleSpec subclass inside the withExtras(\u2026) { \u2026 } lambda or inside the someBundle.with(\u2026) { \u2026 } lambda. If you violate this rule, an IllegalStateException will be thrown. The implementation has been optimized for efficiency. The delegates under bundle() and bundleOrNull() are singletons and are shared for all properties app-wide. The versions that accept a key or a default value can\u2019t be singletons, but since you\u2019re likely using them in object backed specs, they are instantiated only once per property, having a minimal memory impact (especially when compared to the cost of data serialization in Bundles).","title":"Important details"},{"location":"3/bundle/#examples","text":"","title":"Examples"},{"location":"3/bundle/#extras-in-an-activity","text":"class DemoActivity : AppCompatActivity () { object ExtrasSpec : BundleSpec () { var userName : String by bundle () // Required extra var showGreetingToast by bundleOrDefault ( false ) // Optional extra, defaults to false var optionalExtra : String ? by bundleOrNull () // Optional extra } override fun onCreate ( savedInstanceState : Bundle ?) { super . onCreate ( savedInstanceState ) withExtras ( ExtrasSpec ) { // Populates ExtrasSpec with actual extras if ( showGreetingToast ) toast ( android . R . string . ok ) optionalExtras ?. forEach { Timber . i ( \"Character from optional extra: $it\" ) } } restOfYourCode () } } class StartDemoActivity : AppCompatActivity () { private fun someFunction ( name : String , isUserPolite : Boolean = false ) { startActivity ( Intent ( this , DemoActivity :: class . java ). apply { putExtras ( DemoActivity . ExtrasSpec ) { userName = name showGreetingToast = isUserPolite } }) } }","title":"Extras in an Activity"},{"location":"3/bundle/#extras-in-a-broadcastreceiver","text":"class AirplaneModeReceiver : BroadcastReceiver () { object ExtrasSpec : BundleSpec () { var isAirplaneModeOn : Boolean by bundle ( \"state\" ) } override fun onReceive ( context : Context , intent : Intent ) { if ( intent . action != Intent . ACTION_AIRPLANE_MODE_CHANGED ) return val isAirplaneModeOn = intent . extras . with ( ExtrasSpec ) { isAirplaneModeOn } handleAirplaneMode ( isAirplaneModeOn ) } }","title":"Extras in a BroadcastReceiver"},{"location":"3/bundle/#instance-state-in-an-activity","text":"class DemoActivity : AppCompatActivity () { private object InstanceStateSpec : BundleSpec () { var startTime : Long by bundle () } private var startTimestamp = 0L override fun onCreate ( savedInstanceState : Bundle ?) { super . onCreate ( savedInstanceState ) startTimestamp = savedInstanceState ?. with ( InstanceStateSpec ) { startTime } ?: System . currentTimeMillis () restOfYourCode () } override fun onSaveInstanceState ( outState : Bundle ) { outState . with ( InstanceStateSpec ) { startTime = startTimestamp } super . onSaveInstanceState ( outState ) } }","title":"Instance State in an Activity"},{"location":"3/bundle/#download","text":"implementation ( \"com.louiscad.splitties:splitties-bundle:3.0.0-beta01\" )","title":"Download"},{"location":"3/checkedlazy/","text":"Checked Lazy \u00b6 mainThreadLazy that checks property access on main thread, and checkedLazy to make your own variant. Supported platforms: Android . This library provides a checkedLazy() method that returns a Lazy delegate, as well as mainThreadLazy() . checkedLazy() takes as first parameter a function where you can implement an access check. The second parameter is the lazy initializer, as in Kotlin stdlib lazy . mainThreadLazy { \u2026 } is a shorthand for checkedLazy(::checkMainThread) { \u2026 } . It\u2019s there because main thread checking is a common use case on Android due to its synchronized nature and its omnipresence. Example \u00b6 val noMainThreadChecker = noAccessOn ( mainThread ) class YourClass { val greeting : String by mainThreadLazy { \"Hello Splitties!\" } val expensiveObject by checkedLazy ( noMainThreadChecker ) { doHeavyInstantiation () } } Download \u00b6 implementation ( \"com.louiscad.splitties:splitties-checkedlazy:3.0.0-beta01\" )","title":"checkedlazy"},{"location":"3/checkedlazy/#checked-lazy","text":"mainThreadLazy that checks property access on main thread, and checkedLazy to make your own variant. Supported platforms: Android . This library provides a checkedLazy() method that returns a Lazy delegate, as well as mainThreadLazy() . checkedLazy() takes as first parameter a function where you can implement an access check. The second parameter is the lazy initializer, as in Kotlin stdlib lazy . mainThreadLazy { \u2026 } is a shorthand for checkedLazy(::checkMainThread) { \u2026 } . It\u2019s there because main thread checking is a common use case on Android due to its synchronized nature and its omnipresence.","title":"Checked Lazy"},{"location":"3/checkedlazy/#example","text":"val noMainThreadChecker = noAccessOn ( mainThread ) class YourClass { val greeting : String by mainThreadLazy { \"Hello Splitties!\" } val expensiveObject by checkedLazy ( noMainThreadChecker ) { doHeavyInstantiation () } }","title":"Example"},{"location":"3/checkedlazy/#download","text":"implementation ( \"com.louiscad.splitties:splitties-checkedlazy:3.0.0-beta01\" )","title":"Download"},{"location":"3/collections/","text":"Collections \u00b6 forEach for List s without Iterator allocation. Supported platforms: Linux (x64), MingW (x64) , macOS (x64), iOS (arm32, arm64 & x64), JS , JVM (including Android). Content \u00b6 The forEachByIndex and forEachWithIndex extension functions for List allows you to iterate on a List without allocating an Iterator . This is useful when you need to iterate on a List in performance critical conditions (e.g. code executed/called from an onDraw method, or code run on the UI thread more generally). You also have the reverse equivalents: forEachReversedByIndex and forEachReversedWithIndex . Download \u00b6 implementation ( \"com.louiscad.splitties:splitties-collections:3.0.0-beta01\" )","title":"collections"},{"location":"3/collections/#collections","text":"forEach for List s without Iterator allocation. Supported platforms: Linux (x64), MingW (x64) , macOS (x64), iOS (arm32, arm64 & x64), JS , JVM (including Android).","title":"Collections"},{"location":"3/collections/#content","text":"The forEachByIndex and forEachWithIndex extension functions for List allows you to iterate on a List without allocating an Iterator . This is useful when you need to iterate on a List in performance critical conditions (e.g. code executed/called from an onDraw method, or code run on the UI thread more generally). You also have the reverse equivalents: forEachReversedByIndex and forEachReversedWithIndex .","title":"Content"},{"location":"3/collections/#download","text":"implementation ( \"com.louiscad.splitties:splitties-collections:3.0.0-beta01\" )","title":"Download"},{"location":"3/coroutines/","text":"Coroutines \u00b6 General purpose extensions to kotlinx.coroutines. Supported platforms: Linux (x64), MingW (x64) , macOS (x64), iOS (arm32, arm64 & x64), JS , JVM (including Android). Offering a value to a SendChannel (including inside callbackFlow ) safely \u00b6 Calling the offer function in SendChannel as it can crash your program if the channel is closed, as can be seen in this issue: https://github.com/Kotlin/kotlinx.coroutines/issues/974 . To be safe from this pitfall, Splitties provides an extension named offerCatching(\u2026) that returns false if offer throws, making you safe in the edge cases where a call is made just after the channel gets closed, as can happen when using callbackFlow { \u2026 } in multi-threaded environments. Cancellable infinite loops \u00b6 The repeatWhileActive { \u2026 } top level function is like a while (true) { \u2026 } loop, except that: - it evaluates to Nothing , allowing you to use it in any lambda, regardless of its return type. - it will check for cancellation before each execution of the passed lambda, protecting from an infinite loop if the code in the lambda doesn\u2019t check for cancellation but eventually ends running. It also has an overload that takes a Boolean parameter named ignoreInnerCancellations . This one is made for the cases where you\u2019re throwing a CancellationException to signal the cancellation of this loop run/iteration, but want to continue looping again. Can be useful if you are using withTimeout { \u2026 } or want to easily handle user requested cancellation. It will still check that the scope has not been cancelled before each iteration, so it\u2019s perfectly safe to use among code that must be cancellable. Example: \u00b6 suspend fun doStuffUntilCancelled ( ui : SomeUi , someObject : SomeType ): Nothing { repeatWhileActive { val command = ui . awaitSomeUserAction () someObject . doSomething ( command . whatever ) ui . awaitAnotherUserAction () val result = someObject . doSomethingElse () ui . showOutcome ( result ) } } Racing coroutines \u00b6 Number of racers fixed at compile time \u00b6 The raceOf(\u2026) function takes a variable number of coroutines, that also have a CoroutineScope as a receiver. The first coroutine to finish (includes that any child coroutines that might have been launched are completed or cancelled too) will cancel the others, and its value will be returned by raceOf . Note that calling raceOf with no racers is forbidden, and any attempt to do so will throw an IllegalArgumentException . There\u2019s a deprecated overload of raceOf() taking no parameters to prevent you from making this mistake. For variable number of racing coroutines, use race + launchRacer documented below. Simple example (unit test): \u00b6 suspend fun testCoroutinesRacing () { val result = raceOf ({ delay ( 3 ) \"slow\" }, { delay ( 0 ) \"fast\" }) assertEquals ( expected = \"fast\" , actual = result ) } UI code example \u00b6 suspend fun awaitUserChoice ( ui : SomeUi , choices : List < Stuff >): Stuff ? = raceOf ({ ui . awaitSomeUserAction ( choices ) }, { ui . awaitDismissal () null }, { launch { doSideStuff () } ui . showSomethingInRealtimeUntilCancelled () // Returns Nothing, will run, but never \"win\". }) Dynamic racers and late racers \u00b6 The raceOf(\u2026) function might not suit your use case if the racing coroutines need to be launched based on some conditions, that might also take some time to be evaluated. These more advanced use-cases are satisfied by the race { \u2026 } function, where you can call launchRacer { \u2026 } in its lambda. If no racing coroutines are ever launched, the race { \u2026 } function will suspend until it is cancelled. Example \u00b6 suspend fun awaitSomeActionTrigger ( config : SomeConfig , deviceCapabilities : HardwareSupportInfo , defaultInput : SomeInput , awaitSpecialInput : suspend () -> Unit ) { race { launchRacer { defaultInput . awaitSomeAction () } if ( deviceCapabilities . supportsSpecialInput ) { launchRacer { awaitSpecialInput () } delay ( config . delayBeforeHintMillis ) // The race lambda can suspend showHintForSpecialInput () } } } Await cancellation \u00b6 In code that embraces coroutines capabilities like being able to run some code on cancellation (for example with a finally block encompassing suspending code), it can be handy to suspend a coroutine until it is cancelled, for example to delay the hiding of a part of a UI, or stop an ongoing side operation that is not needed after cancellation. So Splitties provides a function named awaitCancellation() that returns Nothing so you can use it in any suspending code when needed. UI code example with try / finally \u00b6 suspend fun showStuffUntilCancelled ( data : Stuff ): Nothing { try { someSubView . text = data . title anotherSubView . text = data . description someView . isVisible = true awaitCancellation () // Suspends so the view stays visible } finally { someView . isVisible = false // Called on cancellation, cannot forget to hide the view! } } Same version using visibleInScope from Views Coroutines : suspend fun showStuffUntilCancelled ( data : Stuff ): Nothing { someSubView . text = data . title anotherSubView . text = data . description someView . visibleInScope { awaitCancellation () // Suspends so the view stays visible } } Suspending version of lazy \u00b6 These 3 functions provide a SuspendLazy instance: CoroutineScope.suspendLazy { \u2026 } suspendBlockingLazy { \u2026 } (uses Dispatchers.Default by default) suspendBlockingLazyIO { \u2026 } (JVM-only for now, uses Dispatchers.IO ) They can be used almost like Kotlin\u2019s lazy , but you need parentheses to get the value. Note that if an Exception or any Throwable is thrown in their initializing lambda, the SuspendLazy instance will not be recoverable, so if retry logic is needed, it must include instantiating a new SuspendLazy . If you want it to allow retries on the same instance, please open an issue and tell about your use case. Example: Initializing a database only once \u00b6 For an app-wide remote database: val db : SomeDatabase = GlobalScope . suspendLazy { createDatabase (). also { it . connect () } // Both functions suspend } fun doStuff ( someData : SomeData ) { db (). runSomeTransaction ( someData ) } For an application-wide local database (e.g. in an Android or desktop JVM app): val db : AppDatabase = suspendBlockingLazyIO { buildDatabase () } fun doStuff ( someData : SomeData ) { db (). runSomeTransaction ( someData ) } Passing a SuspendLazy type can be handy: suspend fun doStuff ( getDb : SuspendLazy < AppDatabase >, someData : SomeData ) { val db = getDb () db . runSomeTransaction ( someData ) } Example: Offloading heavy object instantiation or expensive computation \u00b6 Objects that need a significant amount of memory (example bitmap/images, large arrays/lists, or large/deep data structures such as possibly non trivial trees) will block the current thread while being instantiated, waiting for the CPU to find enough free memory (RAM), which might include moving lots of stuff to have the contiguous space that can be required. To avoid blocking the user interface and altering the perceived performance of the application, you need to not run such code on the main/UI thread, but offload it to another thread such as one from Dispatchers.Default . The suspendBlockingLazy { \u2026 } makes it very easy to do it right: val expensiveThing = suspendBlockingLazy { DoHeavyInstantiation () } fun doStuff ( ui : SomeUi ) { // Can run on main/UI thread. val thing = expensiveThing () // Will suspend until DoHeavyInstantiation() is done. ui . displaySomeDataNicely ( thing ) } Download \u00b6 implementation ( \"com.louiscad.splitties:splitties-coroutines:3.0.0-beta01\" )","title":"coroutines"},{"location":"3/coroutines/#coroutines","text":"General purpose extensions to kotlinx.coroutines. Supported platforms: Linux (x64), MingW (x64) , macOS (x64), iOS (arm32, arm64 & x64), JS , JVM (including Android).","title":"Coroutines"},{"location":"3/coroutines/#offering-a-value-to-a-sendchannel-including-inside-callbackflow-safely","text":"Calling the offer function in SendChannel as it can crash your program if the channel is closed, as can be seen in this issue: https://github.com/Kotlin/kotlinx.coroutines/issues/974 . To be safe from this pitfall, Splitties provides an extension named offerCatching(\u2026) that returns false if offer throws, making you safe in the edge cases where a call is made just after the channel gets closed, as can happen when using callbackFlow { \u2026 } in multi-threaded environments.","title":"Offering a value to a SendChannel (including inside callbackFlow) safely"},{"location":"3/coroutines/#cancellable-infinite-loops","text":"The repeatWhileActive { \u2026 } top level function is like a while (true) { \u2026 } loop, except that: - it evaluates to Nothing , allowing you to use it in any lambda, regardless of its return type. - it will check for cancellation before each execution of the passed lambda, protecting from an infinite loop if the code in the lambda doesn\u2019t check for cancellation but eventually ends running. It also has an overload that takes a Boolean parameter named ignoreInnerCancellations . This one is made for the cases where you\u2019re throwing a CancellationException to signal the cancellation of this loop run/iteration, but want to continue looping again. Can be useful if you are using withTimeout { \u2026 } or want to easily handle user requested cancellation. It will still check that the scope has not been cancelled before each iteration, so it\u2019s perfectly safe to use among code that must be cancellable.","title":"Cancellable infinite loops"},{"location":"3/coroutines/#example","text":"suspend fun doStuffUntilCancelled ( ui : SomeUi , someObject : SomeType ): Nothing { repeatWhileActive { val command = ui . awaitSomeUserAction () someObject . doSomething ( command . whatever ) ui . awaitAnotherUserAction () val result = someObject . doSomethingElse () ui . showOutcome ( result ) } }","title":"Example:"},{"location":"3/coroutines/#racing-coroutines","text":"","title":"Racing coroutines"},{"location":"3/coroutines/#number-of-racers-fixed-at-compile-time","text":"The raceOf(\u2026) function takes a variable number of coroutines, that also have a CoroutineScope as a receiver. The first coroutine to finish (includes that any child coroutines that might have been launched are completed or cancelled too) will cancel the others, and its value will be returned by raceOf . Note that calling raceOf with no racers is forbidden, and any attempt to do so will throw an IllegalArgumentException . There\u2019s a deprecated overload of raceOf() taking no parameters to prevent you from making this mistake. For variable number of racing coroutines, use race + launchRacer documented below.","title":"Number of racers fixed at compile time"},{"location":"3/coroutines/#simple-example-unit-test","text":"suspend fun testCoroutinesRacing () { val result = raceOf ({ delay ( 3 ) \"slow\" }, { delay ( 0 ) \"fast\" }) assertEquals ( expected = \"fast\" , actual = result ) }","title":"Simple example (unit test):"},{"location":"3/coroutines/#ui-code-example","text":"suspend fun awaitUserChoice ( ui : SomeUi , choices : List < Stuff >): Stuff ? = raceOf ({ ui . awaitSomeUserAction ( choices ) }, { ui . awaitDismissal () null }, { launch { doSideStuff () } ui . showSomethingInRealtimeUntilCancelled () // Returns Nothing, will run, but never \"win\". })","title":"UI code example"},{"location":"3/coroutines/#dynamic-racers-and-late-racers","text":"The raceOf(\u2026) function might not suit your use case if the racing coroutines need to be launched based on some conditions, that might also take some time to be evaluated. These more advanced use-cases are satisfied by the race { \u2026 } function, where you can call launchRacer { \u2026 } in its lambda. If no racing coroutines are ever launched, the race { \u2026 } function will suspend until it is cancelled.","title":"Dynamic racers and late racers"},{"location":"3/coroutines/#example_1","text":"suspend fun awaitSomeActionTrigger ( config : SomeConfig , deviceCapabilities : HardwareSupportInfo , defaultInput : SomeInput , awaitSpecialInput : suspend () -> Unit ) { race { launchRacer { defaultInput . awaitSomeAction () } if ( deviceCapabilities . supportsSpecialInput ) { launchRacer { awaitSpecialInput () } delay ( config . delayBeforeHintMillis ) // The race lambda can suspend showHintForSpecialInput () } } }","title":"Example"},{"location":"3/coroutines/#await-cancellation","text":"In code that embraces coroutines capabilities like being able to run some code on cancellation (for example with a finally block encompassing suspending code), it can be handy to suspend a coroutine until it is cancelled, for example to delay the hiding of a part of a UI, or stop an ongoing side operation that is not needed after cancellation. So Splitties provides a function named awaitCancellation() that returns Nothing so you can use it in any suspending code when needed.","title":"Await cancellation"},{"location":"3/coroutines/#ui-code-example-with-tryfinally","text":"suspend fun showStuffUntilCancelled ( data : Stuff ): Nothing { try { someSubView . text = data . title anotherSubView . text = data . description someView . isVisible = true awaitCancellation () // Suspends so the view stays visible } finally { someView . isVisible = false // Called on cancellation, cannot forget to hide the view! } } Same version using visibleInScope from Views Coroutines : suspend fun showStuffUntilCancelled ( data : Stuff ): Nothing { someSubView . text = data . title anotherSubView . text = data . description someView . visibleInScope { awaitCancellation () // Suspends so the view stays visible } }","title":"UI code example with try/finally"},{"location":"3/coroutines/#suspending-version-of-lazy","text":"These 3 functions provide a SuspendLazy instance: CoroutineScope.suspendLazy { \u2026 } suspendBlockingLazy { \u2026 } (uses Dispatchers.Default by default) suspendBlockingLazyIO { \u2026 } (JVM-only for now, uses Dispatchers.IO ) They can be used almost like Kotlin\u2019s lazy , but you need parentheses to get the value. Note that if an Exception or any Throwable is thrown in their initializing lambda, the SuspendLazy instance will not be recoverable, so if retry logic is needed, it must include instantiating a new SuspendLazy . If you want it to allow retries on the same instance, please open an issue and tell about your use case.","title":"Suspending version of lazy"},{"location":"3/coroutines/#example-initializing-a-database-only-once","text":"For an app-wide remote database: val db : SomeDatabase = GlobalScope . suspendLazy { createDatabase (). also { it . connect () } // Both functions suspend } fun doStuff ( someData : SomeData ) { db (). runSomeTransaction ( someData ) } For an application-wide local database (e.g. in an Android or desktop JVM app): val db : AppDatabase = suspendBlockingLazyIO { buildDatabase () } fun doStuff ( someData : SomeData ) { db (). runSomeTransaction ( someData ) } Passing a SuspendLazy type can be handy: suspend fun doStuff ( getDb : SuspendLazy < AppDatabase >, someData : SomeData ) { val db = getDb () db . runSomeTransaction ( someData ) }","title":"Example: Initializing a database only once"},{"location":"3/coroutines/#example-offloading-heavy-object-instantiation-or-expensive-computation","text":"Objects that need a significant amount of memory (example bitmap/images, large arrays/lists, or large/deep data structures such as possibly non trivial trees) will block the current thread while being instantiated, waiting for the CPU to find enough free memory (RAM), which might include moving lots of stuff to have the contiguous space that can be required. To avoid blocking the user interface and altering the perceived performance of the application, you need to not run such code on the main/UI thread, but offload it to another thread such as one from Dispatchers.Default . The suspendBlockingLazy { \u2026 } makes it very easy to do it right: val expensiveThing = suspendBlockingLazy { DoHeavyInstantiation () } fun doStuff ( ui : SomeUi ) { // Can run on main/UI thread. val thing = expensiveThing () // Will suspend until DoHeavyInstantiation() is done. ui . displaySomeDataNicely ( thing ) }","title":"Example: Offloading heavy object instantiation or expensive computation"},{"location":"3/coroutines/#download","text":"implementation ( \"com.louiscad.splitties:splitties-coroutines:3.0.0-beta01\" )","title":"Download"},{"location":"3/dimensions/","text":"Dimensions \u00b6 Android dp extensions for View and Context . Particularly handy when using Views DSL . Supported platforms: Android . The dp and dip extensions functions for View and Context are exactly the same, use the naming you prefer. They convert a value in Android\u2019s dp to pixels for use in code. The overload taking an Int returns an Int , the one taking a Float returns a Float . Examples \u00b6 val minTapTargetSize = dip ( 48 ) val circleDiameter = dp ( 48f ) Download \u00b6 implementation ( \"com.louiscad.splitties:splitties-dimensions:3.0.0-beta01\" )","title":"dimensions"},{"location":"3/dimensions/#dimensions","text":"Android dp extensions for View and Context . Particularly handy when using Views DSL . Supported platforms: Android . The dp and dip extensions functions for View and Context are exactly the same, use the naming you prefer. They convert a value in Android\u2019s dp to pixels for use in code. The overload taking an Int returns an Int , the one taking a Float returns a Float .","title":"Dimensions"},{"location":"3/dimensions/#examples","text":"val minTapTargetSize = dip ( 48 ) val circleDiameter = dp ( 48f )","title":"Examples"},{"location":"3/dimensions/#download","text":"implementation ( \"com.louiscad.splitties:splitties-dimensions:3.0.0-beta01\" )","title":"Download"},{"location":"3/exceptions/","text":"Exceptions \u00b6 unexpectedValue(\u2026) , unsupportedAction(\u2026) and similar functions that return Nothing . Supported platforms: Android . Here\u2019s the list of these functions: * unexpectedValue(\u2026) (puts the value in the IllegalStateException message) * illegalArg(\u2026) (shortcut to throw IllegalArgumentException(\u2026) ) * unsupported(\u2026) (shortcut to throw UnsupportedOperationException(\u2026) ) * unsupportedAction(\u2026) (designed for unsupported Intent actions) Download \u00b6 implementation ( \"com.louiscad.splitties:splitties-exceptions:3.0.0-beta01\" )","title":"exceptions"},{"location":"3/exceptions/#exceptions","text":"unexpectedValue(\u2026) , unsupportedAction(\u2026) and similar functions that return Nothing . Supported platforms: Android . Here\u2019s the list of these functions: * unexpectedValue(\u2026) (puts the value in the IllegalStateException message) * illegalArg(\u2026) (shortcut to throw IllegalArgumentException(\u2026) ) * unsupported(\u2026) (shortcut to throw UnsupportedOperationException(\u2026) ) * unsupportedAction(\u2026) (designed for unsupported Intent actions)","title":"Exceptions"},{"location":"3/exceptions/#download","text":"implementation ( \"com.louiscad.splitties:splitties-exceptions:3.0.0-beta01\" )","title":"Download"},{"location":"3/fragmentargs/","text":"Fragment Args \u00b6 Fragment arguments without ceremony thanks to delegated properties. Supported platforms: Android . Example \u00b6 class YourFragment : Fragment () { var someRequiredId : Int by arg () var optionalArg : String ? by argOrNull () var nonNullOptionalArg : String by argOrDefault ( \"\" ) var anotherNonNullOptionalArg : String by argOrElse { \"splitties rock!\" . capitalize () } private fun yourMethod () = yourCode () } fun createYourFragment ( someId : Int ): Fragment = YourFragment (). apply { someRequiredId = someId } Download \u00b6 implementation ( \"com.louiscad.splitties:splitties-fragmentargs:3.0.0-beta01\" )","title":"fragmentargs"},{"location":"3/fragmentargs/#fragment-args","text":"Fragment arguments without ceremony thanks to delegated properties. Supported platforms: Android .","title":"Fragment Args"},{"location":"3/fragmentargs/#example","text":"class YourFragment : Fragment () { var someRequiredId : Int by arg () var optionalArg : String ? by argOrNull () var nonNullOptionalArg : String by argOrDefault ( \"\" ) var anotherNonNullOptionalArg : String by argOrElse { \"splitties rock!\" . capitalize () } private fun yourMethod () = yourCode () } fun createYourFragment ( someId : Int ): Fragment = YourFragment (). apply { someRequiredId = someId }","title":"Example"},{"location":"3/fragmentargs/#download","text":"implementation ( \"com.louiscad.splitties:splitties-fragmentargs:3.0.0-beta01\" )","title":"Download"},{"location":"3/fragments/","text":"Fragments \u00b6 Start activities from fragments and do transactions with minimal boilerplate. Supported platforms: Android . Content \u00b6 Starting Activities \u00b6 The start extension function for Context takes advantage of reified type parameters to allow you to write such code: start<AboutActivity>() . There\u2019s an optional lambda where the Intent is the receiver so you can edit it (e.g. adding flags) before the activity is started with it. The startActivity extension function for Context is designed for implicit intents. It expects the Intent action as first parameter, and takes a lambda to edit the intent further, like start . Fragment transactions \u00b6 The fragmentTransaction extension function for FragmentActivity allows to make a fragment transaction without having to write beginTransaction and the commit call repeatedly. It has two optional parameters: * now , that defaults to true so you can get the Fragment immediately after by default. * allowStateLoss that defaults to false . And the lambda is the required body of your transaction where you deal with your Fragments (e.g. adding, replacing\u2026). The addToBackStack() extension function for FragmentTransaction calls addToBackStack(null) . It effectively makes the name parameter optional. Download \u00b6 implementation ( \"com.louiscad.splitties:splitties-fragments:3.0.0-beta01\" )","title":"fragments"},{"location":"3/fragments/#fragments","text":"Start activities from fragments and do transactions with minimal boilerplate. Supported platforms: Android .","title":"Fragments"},{"location":"3/fragments/#content","text":"","title":"Content"},{"location":"3/fragments/#starting-activities","text":"The start extension function for Context takes advantage of reified type parameters to allow you to write such code: start<AboutActivity>() . There\u2019s an optional lambda where the Intent is the receiver so you can edit it (e.g. adding flags) before the activity is started with it. The startActivity extension function for Context is designed for implicit intents. It expects the Intent action as first parameter, and takes a lambda to edit the intent further, like start .","title":"Starting Activities"},{"location":"3/fragments/#fragment-transactions","text":"The fragmentTransaction extension function for FragmentActivity allows to make a fragment transaction without having to write beginTransaction and the commit call repeatedly. It has two optional parameters: * now , that defaults to true so you can get the Fragment immediately after by default. * allowStateLoss that defaults to false . And the lambda is the required body of your transaction where you deal with your Fragments (e.g. adding, replacing\u2026). The addToBackStack() extension function for FragmentTransaction calls addToBackStack(null) . It effectively makes the name parameter optional.","title":"Fragment transactions"},{"location":"3/fragments/#download","text":"implementation ( \"com.louiscad.splitties:splitties-fragments:3.0.0-beta01\" )","title":"Download"},{"location":"3/initprovider/","text":"Init Provider \u00b6 Base class for ContentProvider s used for automatic initialization purposes. Supported platforms: Android . See the Stetho Init and App Context implementations to see how it\u2019s meant to be used. Download \u00b6 implementation ( \"com.louiscad.splitties:splitties-initprovider:3.0.0-beta01\" )","title":"initprovider"},{"location":"3/initprovider/#init-provider","text":"Base class for ContentProvider s used for automatic initialization purposes. Supported platforms: Android . See the Stetho Init and App Context implementations to see how it\u2019s meant to be used.","title":"Init Provider"},{"location":"3/initprovider/#download","text":"implementation ( \"com.louiscad.splitties:splitties-initprovider:3.0.0-beta01\" )","title":"Download"},{"location":"3/intents/","text":"Intents \u00b6 Transform companion object s into powerful typesafe intent specs, and create PendingIntent s the clean and easy way. Supported platforms: Android . Table of contents \u00b6 Using companion object s as typesafe and key-safe intent specs The problem about intents in Android The solution IntentSpec interfaces IntentSpec implementations providers Using an IntentSpec IntentSpec example Creating PendingIntent s the clean and easy way Download Using companion object s as typesafe and key-safe intent specs \u00b6 The problem about intents in Android \u00b6 An Android component that can receive an Intent (like an Activity or a BroacastReceiver ) can expect an action, or extras. In case of an action, the string must match exactly in order to work properly. In case of an extra, the type must also match. This makes it not typesafe at all. You need to write some documentation to explain which constants to use, with which types, and you need to be sure to read the doc afterwards, to ensure you do it right. There should be a better way. The solution \u00b6 This split provides a few interfaces that your companion object s can implement using delegation so they become an intent specification, that you can use to build and Intent , start an Activity , start a Service or send a broadcast in a type safe way. IntentSpec interfaces \u00b6 The IntentSpec interface has two properties: * klass which is the class of the component * extrasSpec which is a BundleSpec (defined in the Bundle split). The ActivityIntentSpec , BroadcastReceiverIntentSpec and ServiceIntentSpec interfaces all extend the IntentSpec interface, but add a bound to the type parameter of the class. You should use them when defining the intent spec of an Activity , BroadcastReceiver or Service . IntentSpec implementations providers \u00b6 A few methods provide implementation of the interfaces mentioned above: * activitySpec * activityWithoutExtrasSpec where ExtrasSpec is Nothing * receiverSpec * receiverWithoutExtrasSpec where ExtrasSpec is Nothing * serviceSpec * serviceWithoutExtrasSpec where ExtrasSpec is Nothing They are designed to be used with by . Examples: * companion object : ActivityIntentSpec<ProductDetailsActivity, ExtrasSpec> by activitySpec(ExtrasSpec) * companion object : BroadcastReceiverIntentSpec<NotifDismissReceiver, ExtrasSpec> by receiverSpec(ExtrasSpec) Using an IntentSpec \u00b6 The intent method is an extension for IntentSpec . It takes a lambda where the receiver is the Intent . The first parameter is the companion object itself so you can access any constant or method defined in it easily. The second parameter of the lambda is optional, it is the extrasSpec. The start method is an extension for Context and for Fragment that takes the target ActivityIntentSpec as its first parameter. It then calls the intent extension function mentioned above, and the optional expected lambda has the same parameters as for intent . Finally, it calls startActivity with the created Intent . The sendBroadcast method is an extension for Context that takes the target BroadcastReceiverIntentSpec as its first parameter. It then calls the intent extension function mentioned above, and the optional expected lambda has the same parameters as for intent . Finally, it calls sendBroadcast with the created Intent . IntentSpec example \u00b6 Let\u2019s take the example shown in the Bundle README, adding an IntentSpec to it. Notice the new companion object and how we start the DemoActivity with the proper extras from the StartDemoActivity now. class DemoActivity : AppCompatActivity () { companion object : ActivityIntentSpec < DemoActivity , ExtrasSpec > by activitySpec ( ExtrasSpec ) { const val someText = \"Splitties is great!\" } object ExtrasSpec : BundleSpec () { var showGreetingToast : Boolean by bundle () // Required extra var optionalExtra : String ? by bundleOrNull () // Optional extra } override fun onCreate ( savedInstanceState : Bundle ?) { super . onCreate ( savedInstanceState ) withExtras ( ExtrasSpec ) { // Populates ExtrasSpec with actual extras if ( showGreetingToast ) toast ( android . R . string . ok ) optionalExtras ?. let { longToast ( it ) } } restOfYourCode () } } class StartDemoActivity : AppCompatActivity () { private fun someFunction ( isUserPolite : Boolean = false ) { start ( DemoActivity ) { intentSpec , extrasSpec -> // Magic happens here! extrasSpec . showGreetingToast = isUserPolite extrasSpec . optionalExtra = intentSpec . someText } } } Creating PendingIntent s the clean and easy way \u00b6 It\u2019s fair to say that the PendingIntent Android API is not designed for Kotlin, and for a reason, it has been there since API level 1, the first Android version. As a result, code using this API is not always the most readable part of a Kotlin codebase. This split provides several extension functions for Intent that return a PendingIntent : * toPendingActivity() * toPendingService() * toPendingForegroundService() , which also works before API 26 * toPendingBroadcast() and an extension for Array<Intent> : toPendingActivities() . All these functions have two optional parameters that default to zero: reqCode and flags . The toPendingActivity() and toPendingActivities() functions also have an options: Bundle? parameter that defaults to null (and is ignored below API 16). Download \u00b6 implementation ( \"com.louiscad.splitties:splitties-intents:3.0.0-beta01\" )","title":"intents"},{"location":"3/intents/#intents","text":"Transform companion object s into powerful typesafe intent specs, and create PendingIntent s the clean and easy way. Supported platforms: Android .","title":"Intents"},{"location":"3/intents/#table-of-contents","text":"Using companion object s as typesafe and key-safe intent specs The problem about intents in Android The solution IntentSpec interfaces IntentSpec implementations providers Using an IntentSpec IntentSpec example Creating PendingIntent s the clean and easy way Download","title":"Table of contents"},{"location":"3/intents/#using-companion-objects-as-typesafe-and-key-safe-intent-specs","text":"","title":"Using companion objects as typesafe and key-safe intent specs"},{"location":"3/intents/#the-problem-about-intents-in-android","text":"An Android component that can receive an Intent (like an Activity or a BroacastReceiver ) can expect an action, or extras. In case of an action, the string must match exactly in order to work properly. In case of an extra, the type must also match. This makes it not typesafe at all. You need to write some documentation to explain which constants to use, with which types, and you need to be sure to read the doc afterwards, to ensure you do it right. There should be a better way.","title":"The problem about intents in Android"},{"location":"3/intents/#the-solution","text":"This split provides a few interfaces that your companion object s can implement using delegation so they become an intent specification, that you can use to build and Intent , start an Activity , start a Service or send a broadcast in a type safe way.","title":"The solution"},{"location":"3/intents/#intentspec-interfaces","text":"The IntentSpec interface has two properties: * klass which is the class of the component * extrasSpec which is a BundleSpec (defined in the Bundle split). The ActivityIntentSpec , BroadcastReceiverIntentSpec and ServiceIntentSpec interfaces all extend the IntentSpec interface, but add a bound to the type parameter of the class. You should use them when defining the intent spec of an Activity , BroadcastReceiver or Service .","title":"IntentSpec interfaces"},{"location":"3/intents/#intentspec-implementations-providers","text":"A few methods provide implementation of the interfaces mentioned above: * activitySpec * activityWithoutExtrasSpec where ExtrasSpec is Nothing * receiverSpec * receiverWithoutExtrasSpec where ExtrasSpec is Nothing * serviceSpec * serviceWithoutExtrasSpec where ExtrasSpec is Nothing They are designed to be used with by . Examples: * companion object : ActivityIntentSpec<ProductDetailsActivity, ExtrasSpec> by activitySpec(ExtrasSpec) * companion object : BroadcastReceiverIntentSpec<NotifDismissReceiver, ExtrasSpec> by receiverSpec(ExtrasSpec)","title":"IntentSpec implementations providers"},{"location":"3/intents/#using-an-intentspec","text":"The intent method is an extension for IntentSpec . It takes a lambda where the receiver is the Intent . The first parameter is the companion object itself so you can access any constant or method defined in it easily. The second parameter of the lambda is optional, it is the extrasSpec. The start method is an extension for Context and for Fragment that takes the target ActivityIntentSpec as its first parameter. It then calls the intent extension function mentioned above, and the optional expected lambda has the same parameters as for intent . Finally, it calls startActivity with the created Intent . The sendBroadcast method is an extension for Context that takes the target BroadcastReceiverIntentSpec as its first parameter. It then calls the intent extension function mentioned above, and the optional expected lambda has the same parameters as for intent . Finally, it calls sendBroadcast with the created Intent .","title":"Using an IntentSpec"},{"location":"3/intents/#intentspec-example","text":"Let\u2019s take the example shown in the Bundle README, adding an IntentSpec to it. Notice the new companion object and how we start the DemoActivity with the proper extras from the StartDemoActivity now. class DemoActivity : AppCompatActivity () { companion object : ActivityIntentSpec < DemoActivity , ExtrasSpec > by activitySpec ( ExtrasSpec ) { const val someText = \"Splitties is great!\" } object ExtrasSpec : BundleSpec () { var showGreetingToast : Boolean by bundle () // Required extra var optionalExtra : String ? by bundleOrNull () // Optional extra } override fun onCreate ( savedInstanceState : Bundle ?) { super . onCreate ( savedInstanceState ) withExtras ( ExtrasSpec ) { // Populates ExtrasSpec with actual extras if ( showGreetingToast ) toast ( android . R . string . ok ) optionalExtras ?. let { longToast ( it ) } } restOfYourCode () } } class StartDemoActivity : AppCompatActivity () { private fun someFunction ( isUserPolite : Boolean = false ) { start ( DemoActivity ) { intentSpec , extrasSpec -> // Magic happens here! extrasSpec . showGreetingToast = isUserPolite extrasSpec . optionalExtra = intentSpec . someText } } }","title":"IntentSpec example"},{"location":"3/intents/#creating-pendingintents-the-clean-and-easy-way","text":"It\u2019s fair to say that the PendingIntent Android API is not designed for Kotlin, and for a reason, it has been there since API level 1, the first Android version. As a result, code using this API is not always the most readable part of a Kotlin codebase. This split provides several extension functions for Intent that return a PendingIntent : * toPendingActivity() * toPendingService() * toPendingForegroundService() , which also works before API 26 * toPendingBroadcast() and an extension for Array<Intent> : toPendingActivities() . All these functions have two optional parameters that default to zero: reqCode and flags . The toPendingActivity() and toPendingActivities() functions also have an options: Bundle? parameter that defaults to null (and is ignored below API 16).","title":"Creating PendingIntents the clean and easy way"},{"location":"3/intents/#download","text":"implementation ( \"com.louiscad.splitties:splitties-intents:3.0.0-beta01\" )","title":"Download"},{"location":"3/lifecycle-coroutines/","text":"Lifecycle Coroutines \u00b6 Coroutines integration with Lifecycle s. Supported platforms: Android . Note: This split exposes its dependency on AndroidX Lifecycle runtime KTX , which notably brings lifecycleScope for LifecycleOwner ( Activity , Fragment , LifecycleService \u2026) and coroutineScope for Lifecycle . See the documentation of Android Lifecycle here . Extension functions: Name Description Lifecycle.awaitResumed A suspending function that returns/resumes as soon as the state of the Lifecycle is resumed. Lifecycle.awaitStarted A suspending function that returns/resumes as soon as the state of the Lifecycle is at least started. Lifecycle.awaitCreated A suspending function that returns/resumes as soon as the state of the Lifecycle is at least created. Lifecycle.awaitState A suspending function that returns/resumes as soon as the state of the Lifecycle is at least the passed state. Lifecycle.isStartedFlow Returns a Flow whose value is true while the lifecycle is started. An experimental overload takes a timeout. Lifecycle.isResumedFlow Returns a Flow whose value is true while the lifecycle is resumed. An experimental overload takes a timeout. Lifecycle.stateFlow Returns a Flow whose value reflects the current Lifecycle.STATE . Lifecycle.createJob A job that is active while the state is at least the passed one. Lifecycle.createScope A scope that dispatches on Android Main thread and is active while the state is at least the passed one. Example \u00b6 class MainActivity : AppCompatActivity () { override fun onCreate ( savedInstanceState : Bundle ?) { super . onCreate ( savedInstanceState ) lifecycleScope . launch { someSuspendFunction () lifecycle . awaitResumed () showSomethingWithAnimation () } isStartedFlow ( 5. seconds ). transformLatest { isStarted -> if ( isStarted ) { emitAll ( someDataUpdates ()) } }. onEach { dataSnapshot -> ui . updateLatestData ( dataSnapshot ) }. launchIn ( lifecycleScope ) lifecycleScope . launch { isResumedFlow (). collectLatest { isResumed -> if ( isResumed ) { stats . usageTracker . countTimeSpentUntilCancelled () } } } } override fun onStart () { super . onStart () val startedScope = lifecycle . createScope ( activeWhile = Lifecycle . State . STARTED ) startedScope . launch { aCancellableSuspendFunction () yetAnotherCancellableSuspendFunction () } startedScope . aMethodThatWillLaunchSomeCoroutines () } } Download \u00b6 implementation ( \"com.louiscad.splitties:splitties-lifecycle-coroutines:3.0.0-beta01\" )","title":"lifecycle-coroutines"},{"location":"3/lifecycle-coroutines/#lifecycle-coroutines","text":"Coroutines integration with Lifecycle s. Supported platforms: Android . Note: This split exposes its dependency on AndroidX Lifecycle runtime KTX , which notably brings lifecycleScope for LifecycleOwner ( Activity , Fragment , LifecycleService \u2026) and coroutineScope for Lifecycle . See the documentation of Android Lifecycle here . Extension functions: Name Description Lifecycle.awaitResumed A suspending function that returns/resumes as soon as the state of the Lifecycle is resumed. Lifecycle.awaitStarted A suspending function that returns/resumes as soon as the state of the Lifecycle is at least started. Lifecycle.awaitCreated A suspending function that returns/resumes as soon as the state of the Lifecycle is at least created. Lifecycle.awaitState A suspending function that returns/resumes as soon as the state of the Lifecycle is at least the passed state. Lifecycle.isStartedFlow Returns a Flow whose value is true while the lifecycle is started. An experimental overload takes a timeout. Lifecycle.isResumedFlow Returns a Flow whose value is true while the lifecycle is resumed. An experimental overload takes a timeout. Lifecycle.stateFlow Returns a Flow whose value reflects the current Lifecycle.STATE . Lifecycle.createJob A job that is active while the state is at least the passed one. Lifecycle.createScope A scope that dispatches on Android Main thread and is active while the state is at least the passed one.","title":"Lifecycle Coroutines"},{"location":"3/lifecycle-coroutines/#example","text":"class MainActivity : AppCompatActivity () { override fun onCreate ( savedInstanceState : Bundle ?) { super . onCreate ( savedInstanceState ) lifecycleScope . launch { someSuspendFunction () lifecycle . awaitResumed () showSomethingWithAnimation () } isStartedFlow ( 5. seconds ). transformLatest { isStarted -> if ( isStarted ) { emitAll ( someDataUpdates ()) } }. onEach { dataSnapshot -> ui . updateLatestData ( dataSnapshot ) }. launchIn ( lifecycleScope ) lifecycleScope . launch { isResumedFlow (). collectLatest { isResumed -> if ( isResumed ) { stats . usageTracker . countTimeSpentUntilCancelled () } } } } override fun onStart () { super . onStart () val startedScope = lifecycle . createScope ( activeWhile = Lifecycle . State . STARTED ) startedScope . launch { aCancellableSuspendFunction () yetAnotherCancellableSuspendFunction () } startedScope . aMethodThatWillLaunchSomeCoroutines () } }","title":"Example"},{"location":"3/lifecycle-coroutines/#download","text":"implementation ( \"com.louiscad.splitties:splitties-lifecycle-coroutines:3.0.0-beta01\" )","title":"Download"},{"location":"3/mainhandler/","text":"Main Handler \u00b6 Top-level mainHandler property to stop allocating multiple Handler s for main Looper . Supported platforms: Android . If the sentence above is not clear enough or if you need more explanations, please open an issue. Note that mainHandler is async, which means there\u2019s no vSync delays. If you need a sync Handler , you can simply use mainHandlerAsync , also provided in this split. Download \u00b6 implementation ( \"com.louiscad.splitties:splitties-mainhandler:3.0.0-beta01\" )","title":"mainhandler"},{"location":"3/mainhandler/#main-handler","text":"Top-level mainHandler property to stop allocating multiple Handler s for main Looper . Supported platforms: Android . If the sentence above is not clear enough or if you need more explanations, please open an issue. Note that mainHandler is async, which means there\u2019s no vSync delays. If you need a sync Handler , you can simply use mainHandlerAsync , also provided in this split.","title":"Main Handler"},{"location":"3/mainhandler/#download","text":"implementation ( \"com.louiscad.splitties:splitties-mainhandler:3.0.0-beta01\" )","title":"Download"},{"location":"3/mainthread/","text":"Main Thread \u00b6 Properties and precondition checkers related to Android, iOS and macOS main thread. Supported platforms: macOS (x64), iOS (arm32, arm64 & x64), Android , JS . Content \u00b6 This split provides several properties related to main Thread and 2 precondition checkers. Here\u2019s the list: mainLooper : Shortcut to Looper.getMainLooper()!! with caching (Android only). mainThread : Shortcut to Looper.getMainLooper()!!.thread with caching (Android only). isMainThread : Boolean property that is true if the current Thread is the main Thread (always true in JS). checkMainThread() : Throws an IllegalStateException if not run on the main Thread. checkNotMainThread() : Throws an IllegalStateException if run on the main Thread (always throws in JS). Download \u00b6 implementation ( \"com.louiscad.splitties:splitties-mainthread:3.0.0-beta01\" )","title":"mainthread"},{"location":"3/mainthread/#main-thread","text":"Properties and precondition checkers related to Android, iOS and macOS main thread. Supported platforms: macOS (x64), iOS (arm32, arm64 & x64), Android , JS .","title":"Main Thread"},{"location":"3/mainthread/#content","text":"This split provides several properties related to main Thread and 2 precondition checkers. Here\u2019s the list: mainLooper : Shortcut to Looper.getMainLooper()!! with caching (Android only). mainThread : Shortcut to Looper.getMainLooper()!!.thread with caching (Android only). isMainThread : Boolean property that is true if the current Thread is the main Thread (always true in JS). checkMainThread() : Throws an IllegalStateException if not run on the main Thread. checkNotMainThread() : Throws an IllegalStateException if run on the main Thread (always throws in JS).","title":"Content"},{"location":"3/mainthread/#download","text":"implementation ( \"com.louiscad.splitties:splitties-mainthread:3.0.0-beta01\" )","title":"Download"},{"location":"3/material-colors/","text":"Material Colors \u00b6 2014 Material Design color palettes as color resources. Supported platforms: Android . Content \u00b6 This split contains color resources for all the colors referenced in the Material Design guidelines before 2018 change (which added a material palette generator). Examples: \u00b6 Red 500: R.color.red_500 / @color/red_500 Cyan accent 400: R.color.cyan_a400 / @color/cyan_a400 Download \u00b6 implementation ( \"com.louiscad.splitties:splitties-material-colors:3.0.0-beta01\" )","title":"material-colors"},{"location":"3/material-colors/#material-colors","text":"2014 Material Design color palettes as color resources. Supported platforms: Android .","title":"Material Colors"},{"location":"3/material-colors/#content","text":"This split contains color resources for all the colors referenced in the Material Design guidelines before 2018 change (which added a material palette generator).","title":"Content"},{"location":"3/material-colors/#examples","text":"Red 500: R.color.red_500 / @color/red_500 Cyan accent 400: R.color.cyan_a400 / @color/cyan_a400","title":"Examples:"},{"location":"3/material-colors/#download","text":"implementation ( \"com.louiscad.splitties:splitties-material-colors:3.0.0-beta01\" )","title":"Download"},{"location":"3/material-lists/","text":"Material Lists \u00b6 List item Views implementing Material Design guidelines (perfect for usage in a RecyclerView ). Supported platforms: Android . This split provides Android View s that are the implementation for most of the lists components and the lists controls from Material Design guidelines. Here\u2019s the list of the list item View implementations currently included in this module: * IconOneLineListItem * IconTwoLinesListItem * IconTwoLinesSwitchListItem * IconTwoLinesCheckBoxListItem * SwitchTwoLinesIconListItem Feel free to open an issue if you need the implementation of a list item that is not in this library yet, or feel one can be improved. If so, pull requests are welcome as long as the code style is kept intact (you can debate about it in an issue if you feel there\u2019s room for improvement). See an example in the sample module . Download \u00b6 implementation ( \"com.louiscad.splitties:splitties-material-lists:3.0.0-beta01\" )","title":"material-lists"},{"location":"3/material-lists/#material-lists","text":"List item Views implementing Material Design guidelines (perfect for usage in a RecyclerView ). Supported platforms: Android . This split provides Android View s that are the implementation for most of the lists components and the lists controls from Material Design guidelines. Here\u2019s the list of the list item View implementations currently included in this module: * IconOneLineListItem * IconTwoLinesListItem * IconTwoLinesSwitchListItem * IconTwoLinesCheckBoxListItem * SwitchTwoLinesIconListItem Feel free to open an issue if you need the implementation of a list item that is not in this library yet, or feel one can be improved. If so, pull requests are welcome as long as the code style is kept intact (you can debate about it in an issue if you feel there\u2019s room for improvement). See an example in the sample module .","title":"Material Lists"},{"location":"3/material-lists/#download","text":"implementation ( \"com.louiscad.splitties:splitties-material-lists:3.0.0-beta01\" )","title":"Download"},{"location":"3/permissions/","text":"Permissions \u00b6 Request runtime permissions without polluting your codebase. Supported platforms: Android . The most straightforward way to request runtime permissions on Android is not\u2026 straightforward, and that\u2019s why there are so many libraries that attempt to make it easier. If you don\u2019t use any library, you end up breaking control flow with all permissions request results coming in a method you must override from your Activity or Fragment as a couple of two arrays. That means a lot of code to write, and a lot of ways to mess up. Splitties Permissions leverages suspending functions, and DialogFragment s under the hood, to make requesting a permission and handling all the result cases a single function call . Included functions \u00b6 Top-level functions: Name Description hasPermission Returns true if the passed runtime permission is granted to the current app. requestPermission Requests the passed permission if needed and returns the result. ensurePermission Requests the passed permission, taking the user to app details in settings if needed and returns only once granted. ensureAllPermissions Requests the passed permissions, taking the user to app details in settings if needed and returns only once all are granted. Extension functions: Name Description Fragment.requestPermission Requests the passed permission if needed and returns the result. FragmentActivity.requestPermission Requests the passed permission if needed and returns the result. Fragment.ensurePermission Requests the passed permission, taking the user to app details in settings if needed and returns only once granted. Fragment.ensureAllPermissions Requests the passed permissions, taking the user to app details in settings if needed and returns only once all are granted. FragmentActivity.ensurePermission Requests the passed permission, taking the user to app details in settings if needed and returns only once granted. FragmentActivity.ensureAllPermissions Requests the passed permissions, taking the user to app details in settings if needed and returns only once all are granted. Usage \u00b6 The requestPermission is straightforward to use, you just have to write a when expression for its result, but it doesn\u2019t help you handling the 2 following cases: - You need to ask again after showing the rationale - You need to take the user to your app details in the settings because they checked the do not ask again checkbox. That\u2019s where the ensurePermission comes handy. It takes several parameters to handle showing the rationale, and will automatically open the settings pointing to your app details if the user checked the do not ask again checkbox. You can see how to easily implement a higher-level overload that suits the UX you want to provide for permissions requests with that example , and you can see how it is used in PermissionsExampleActivity . Download \u00b6 implementation ( \"com.louiscad.splitties:splitties-permissions:3.0.0-beta01\" )","title":"permissions"},{"location":"3/permissions/#permissions","text":"Request runtime permissions without polluting your codebase. Supported platforms: Android . The most straightforward way to request runtime permissions on Android is not\u2026 straightforward, and that\u2019s why there are so many libraries that attempt to make it easier. If you don\u2019t use any library, you end up breaking control flow with all permissions request results coming in a method you must override from your Activity or Fragment as a couple of two arrays. That means a lot of code to write, and a lot of ways to mess up. Splitties Permissions leverages suspending functions, and DialogFragment s under the hood, to make requesting a permission and handling all the result cases a single function call .","title":"Permissions"},{"location":"3/permissions/#included-functions","text":"Top-level functions: Name Description hasPermission Returns true if the passed runtime permission is granted to the current app. requestPermission Requests the passed permission if needed and returns the result. ensurePermission Requests the passed permission, taking the user to app details in settings if needed and returns only once granted. ensureAllPermissions Requests the passed permissions, taking the user to app details in settings if needed and returns only once all are granted. Extension functions: Name Description Fragment.requestPermission Requests the passed permission if needed and returns the result. FragmentActivity.requestPermission Requests the passed permission if needed and returns the result. Fragment.ensurePermission Requests the passed permission, taking the user to app details in settings if needed and returns only once granted. Fragment.ensureAllPermissions Requests the passed permissions, taking the user to app details in settings if needed and returns only once all are granted. FragmentActivity.ensurePermission Requests the passed permission, taking the user to app details in settings if needed and returns only once granted. FragmentActivity.ensureAllPermissions Requests the passed permissions, taking the user to app details in settings if needed and returns only once all are granted.","title":"Included functions"},{"location":"3/permissions/#usage","text":"The requestPermission is straightforward to use, you just have to write a when expression for its result, but it doesn\u2019t help you handling the 2 following cases: - You need to ask again after showing the rationale - You need to take the user to your app details in the settings because they checked the do not ask again checkbox. That\u2019s where the ensurePermission comes handy. It takes several parameters to handle showing the rationale, and will automatically open the settings pointing to your app details if the user checked the do not ask again checkbox. You can see how to easily implement a higher-level overload that suits the UX you want to provide for permissions requests with that example , and you can see how it is used in PermissionsExampleActivity .","title":"Usage"},{"location":"3/permissions/#download","text":"implementation ( \"com.louiscad.splitties:splitties-permissions:3.0.0-beta01\" )","title":"Download"},{"location":"3/preferences/","text":"Preferences \u00b6 Property syntax for Android\u2019s SharedPreferences or iOS/macOS NSUserDefaults . Supported platforms: macOS (x64), iOS (arm32, arm64 & x64), Android . This library uses Kotlin\u2019s property delegation to make using SharedPreferences as easy as accessing a property on an object, and provides an NSUserDefaults backed implementation for macOS and iOS. On Android, it relies on the appCtx module of this library to allow usage in object , and can support storage on device encrypted storage for devices supporting Direct Boot. See the source code for more information. Table of contents \u00b6 Defining the preferences properties in an object Why object and not class ? Loading the preferences without blocking the main thread Download Defining the preferences properties in an object \u00b6 Define your preferences in an object that extends splitties.preferences.Preferences , like in the example below: import splitties.preferences.Preferences object GamePreferences : Preferences ( \"gameState\" ) { var magicNumber by intPref ( 0 ) // The property name is used as the key. var currentLevel by IntPref ( \"currentLevel\" , 1 ) var bossesFought by IntPref ( \"bossBattleVictories\" , 0 ) var lastTimePlayed by LongPref ( \"lastSessionTime\" , 0L ) private val pseudoField = StringPref ( \"playerPseudo\" , \"Player 1\" ) var currentPseudo : String by pseudoField val pseudoUpdates : Flow < String > = pseudoField . valueFlow () var favoriteCharacter by stringOrNullPref () } Then just use the properties: fun setResponseOfTheUltimateQuestionOfLifeTheUniverseAndEverything () { GamePreferences . magicNumber = 42 } fun doSomeMagic () { toast ( \"Magic: ${GamePreferences.magicNumber}!\" ) } fun resetProgress () { GamePreferences . edit { // Batch edit currentLevel = 1 bossesFought = 0 } } The supported types are: * Boolean * Int * Float * Long * String * String? * Set<String> * Set<String>? For default SharedPreferences , make an object that extends DefaultPreferences instead of Preferences . Note that for better encapsulation, you might want to keep the mutable delegated properties private in some cases, and expose functions and flows instead. Why object and not class ? \u00b6 Unless you use coroutines (read more about this in next section just below), a class instead of an object is not recommended because it would mean you can instantiate it multiple times, while the underlying preferences xml file is cached for the rest of your app\u2019s process lifetime once loaded, so in a class you\u2019d be allocating the delegates more times than needed, leading to an additional, unneeded, small pressure on the garbage collector. However, you may make an abstract subclass of Preferences for specific use cases where adding logic to base Preferences or sharing some properties may be desirable. (If you do, please open an issue to tell us about this use case. It may become an example shown here.) Loading the preferences without blocking the main thread \u00b6 Note that this feature is currently only supported on Android. Feel free to open an issue if you want it on other platforms. The object approach described above has several advantages, one of the most significant being ease of use anywhere in your app, but that also means you can easily access it from the main thread, and the first time you access the object, the underlying xml file where the preferences are stored is loaded, which may block the main thread for longer that you would want, possibly dropping a few frames. With coroutines, it\u2019s easy to offload something on another thread, and this split embraces this capability. Let\u2019s see a modified version of the GamePreferences described above, before passing in review each change. import splitties.preferences.SuspendPrefsAccessor import splitties.preferences.Preferences class GamePreferences private constructor () : Preferences ( \"gameState\" ) { companion object : SuspendPrefsAccessor < GamePreferences >( :: GamePreferences ) var magicNumber by intPref ( 0 ) // The property name is used as the key. var currentLevel by IntPref ( \"currentLevel\" , 1 ) var bossesFought by IntPref ( \"bossBattleVictories\" , 0 ) var lastTimePlayed by LongPref ( \"lastSessionTime\" , 0L ) var pseudo by StringPref ( \"playerPseudo\" , \"Player 1\" ) var favoriteCharacter by stringOrNullPref () } Here are all the changes: 1. We moved from object to class . 2. We added a private constructor() . 3. We added a companion object that extends the SuspendPrefsAccessor abstract class and calls its constructor with a reference to the constructor. With this change, we can no longer access the GamePreferences singleton directly from anywhere\u2026 unless we are in a coroutine! From any suspend function, you just have to call GamePreferences() like you were calling a constructor, but in reality, it is a function call that suspends while loading the preferences for the first time in process life in Dispatchers.IO . If the preferences have already been loaded, it immediately returns the now instantiated singleton. If you have non suspending functions that would need to access the preferences, you have two options: pass your Preferences subclass as a parameter, or make it a suspend function. Download \u00b6 implementation ( \"com.louiscad.splitties:splitties-preferences:3.0.0-beta01\" )","title":"preferences"},{"location":"3/preferences/#preferences","text":"Property syntax for Android\u2019s SharedPreferences or iOS/macOS NSUserDefaults . Supported platforms: macOS (x64), iOS (arm32, arm64 & x64), Android . This library uses Kotlin\u2019s property delegation to make using SharedPreferences as easy as accessing a property on an object, and provides an NSUserDefaults backed implementation for macOS and iOS. On Android, it relies on the appCtx module of this library to allow usage in object , and can support storage on device encrypted storage for devices supporting Direct Boot. See the source code for more information.","title":"Preferences"},{"location":"3/preferences/#table-of-contents","text":"Defining the preferences properties in an object Why object and not class ? Loading the preferences without blocking the main thread Download","title":"Table of contents"},{"location":"3/preferences/#defining-the-preferences-properties-in-an-object","text":"Define your preferences in an object that extends splitties.preferences.Preferences , like in the example below: import splitties.preferences.Preferences object GamePreferences : Preferences ( \"gameState\" ) { var magicNumber by intPref ( 0 ) // The property name is used as the key. var currentLevel by IntPref ( \"currentLevel\" , 1 ) var bossesFought by IntPref ( \"bossBattleVictories\" , 0 ) var lastTimePlayed by LongPref ( \"lastSessionTime\" , 0L ) private val pseudoField = StringPref ( \"playerPseudo\" , \"Player 1\" ) var currentPseudo : String by pseudoField val pseudoUpdates : Flow < String > = pseudoField . valueFlow () var favoriteCharacter by stringOrNullPref () } Then just use the properties: fun setResponseOfTheUltimateQuestionOfLifeTheUniverseAndEverything () { GamePreferences . magicNumber = 42 } fun doSomeMagic () { toast ( \"Magic: ${GamePreferences.magicNumber}!\" ) } fun resetProgress () { GamePreferences . edit { // Batch edit currentLevel = 1 bossesFought = 0 } } The supported types are: * Boolean * Int * Float * Long * String * String? * Set<String> * Set<String>? For default SharedPreferences , make an object that extends DefaultPreferences instead of Preferences . Note that for better encapsulation, you might want to keep the mutable delegated properties private in some cases, and expose functions and flows instead.","title":"Defining the preferences properties in an object"},{"location":"3/preferences/#why-object-and-not-class","text":"Unless you use coroutines (read more about this in next section just below), a class instead of an object is not recommended because it would mean you can instantiate it multiple times, while the underlying preferences xml file is cached for the rest of your app\u2019s process lifetime once loaded, so in a class you\u2019d be allocating the delegates more times than needed, leading to an additional, unneeded, small pressure on the garbage collector. However, you may make an abstract subclass of Preferences for specific use cases where adding logic to base Preferences or sharing some properties may be desirable. (If you do, please open an issue to tell us about this use case. It may become an example shown here.)","title":"Why object and not class?"},{"location":"3/preferences/#loading-the-preferences-without-blocking-the-main-thread","text":"Note that this feature is currently only supported on Android. Feel free to open an issue if you want it on other platforms. The object approach described above has several advantages, one of the most significant being ease of use anywhere in your app, but that also means you can easily access it from the main thread, and the first time you access the object, the underlying xml file where the preferences are stored is loaded, which may block the main thread for longer that you would want, possibly dropping a few frames. With coroutines, it\u2019s easy to offload something on another thread, and this split embraces this capability. Let\u2019s see a modified version of the GamePreferences described above, before passing in review each change. import splitties.preferences.SuspendPrefsAccessor import splitties.preferences.Preferences class GamePreferences private constructor () : Preferences ( \"gameState\" ) { companion object : SuspendPrefsAccessor < GamePreferences >( :: GamePreferences ) var magicNumber by intPref ( 0 ) // The property name is used as the key. var currentLevel by IntPref ( \"currentLevel\" , 1 ) var bossesFought by IntPref ( \"bossBattleVictories\" , 0 ) var lastTimePlayed by LongPref ( \"lastSessionTime\" , 0L ) var pseudo by StringPref ( \"playerPseudo\" , \"Player 1\" ) var favoriteCharacter by stringOrNullPref () } Here are all the changes: 1. We moved from object to class . 2. We added a private constructor() . 3. We added a companion object that extends the SuspendPrefsAccessor abstract class and calls its constructor with a reference to the constructor. With this change, we can no longer access the GamePreferences singleton directly from anywhere\u2026 unless we are in a coroutine! From any suspend function, you just have to call GamePreferences() like you were calling a constructor, but in reality, it is a function call that suspends while loading the preferences for the first time in process life in Dispatchers.IO . If the preferences have already been loaded, it immediately returns the now instantiated singleton. If you have non suspending functions that would need to access the preferences, you have two options: pass your Preferences subclass as a parameter, or make it a suspend function.","title":"Loading the preferences without blocking the main thread"},{"location":"3/preferences/#download","text":"implementation ( \"com.louiscad.splitties:splitties-preferences:3.0.0-beta01\" )","title":"Download"},{"location":"3/resources/","text":"Resources \u00b6 Extensions to get resources like strings, colors or drawables easily, with support for themed attributes. Supported platforms: Android . Content \u00b6 All the extensions of this module are currently available on Context , Fragment and View types. Each one also has an app prefixed version (e.g. appColor(\u2026) ) that is available everywhere but only returns the resources using the application Context, which means they will not use the theme of the current Activity. Colors \u00b6 color(\u2026) takes a color resource id and returns a color Int colorSL(\u2026) takes a color resource id and returns a ColorStateList styledColor(\u2026) takes a color theme attribute and returns a Int styledColorSL(\u2026) takes a color theme attribute and returns a ColorStateList Example \u00b6 val brandPrimaryColor = color ( R . color . brand_primary ) val accentColor = styledColor ( R . attr . colorAccent ) Dimensions \u00b6 dimen(\u2026) takes a dimension resource id and returns its Float value dimenPxSize(\u2026) takes a dimension resource id and returns its rounded Int value dimenPxOffset(\u2026) takes a dimension resource id and returns its truncated Int value Like for colors , there are styled prefixed versions that take a theme attribute. Drawables \u00b6 drawable(\u2026) takes a drawable resource id and returns a Drawable? styledDrawable(\u2026) takes a drawable theme attribute and returns a Drawable? Primitives \u00b6 bool(\u2026) takes a boolean resource id and returns its Boolean value int(\u2026) takes an integer resource id and returns its Int value intArray(\u2026) takes an integer array resource id and returns an IntArray There are styledBool and styledInt that take a theme attribute. Text \u00b6 txt(\u2026) takes a string resource id and returns a CharSequence str(\u2026) takes a string resource id and returns a String . There\u2019s also optional format arguments. qtyTxt(\u2026) (for plurals) returns a CharSequence qtyStr(\u2026) (for plurals) returns a String . There\u2019s also optional format arguments. txtArray(\u2026) takes an array resource id and returns an Array<out CharSequence> strArray(\u2026) takes an array resource id and returns an Array<String> styledTxt(\u2026) takes a string theme attribute and returns a CharSequence? styledStr(\u2026) takes a string theme attribute and returns a String? There\u2019s also optional format arguments. styledTxtArray(\u2026) takes an array theme attribute and returns an Array<out CharSequence>? Any resource type \u00b6 The resolveThemeAttribute extension function for Context takes a resource id of type R.attr and returns its corresponding resource id as resolved from the current theme in the Context . Download \u00b6 implementation ( \"com.louiscad.splitties:splitties-resources:3.0.0-beta01\" )","title":"resources"},{"location":"3/resources/#resources","text":"Extensions to get resources like strings, colors or drawables easily, with support for themed attributes. Supported platforms: Android .","title":"Resources"},{"location":"3/resources/#content","text":"All the extensions of this module are currently available on Context , Fragment and View types. Each one also has an app prefixed version (e.g. appColor(\u2026) ) that is available everywhere but only returns the resources using the application Context, which means they will not use the theme of the current Activity.","title":"Content"},{"location":"3/resources/#colors","text":"color(\u2026) takes a color resource id and returns a color Int colorSL(\u2026) takes a color resource id and returns a ColorStateList styledColor(\u2026) takes a color theme attribute and returns a Int styledColorSL(\u2026) takes a color theme attribute and returns a ColorStateList","title":"Colors"},{"location":"3/resources/#example","text":"val brandPrimaryColor = color ( R . color . brand_primary ) val accentColor = styledColor ( R . attr . colorAccent )","title":"Example"},{"location":"3/resources/#dimensions","text":"dimen(\u2026) takes a dimension resource id and returns its Float value dimenPxSize(\u2026) takes a dimension resource id and returns its rounded Int value dimenPxOffset(\u2026) takes a dimension resource id and returns its truncated Int value Like for colors , there are styled prefixed versions that take a theme attribute.","title":"Dimensions"},{"location":"3/resources/#drawables","text":"drawable(\u2026) takes a drawable resource id and returns a Drawable? styledDrawable(\u2026) takes a drawable theme attribute and returns a Drawable?","title":"Drawables"},{"location":"3/resources/#primitives","text":"bool(\u2026) takes a boolean resource id and returns its Boolean value int(\u2026) takes an integer resource id and returns its Int value intArray(\u2026) takes an integer array resource id and returns an IntArray There are styledBool and styledInt that take a theme attribute.","title":"Primitives"},{"location":"3/resources/#text","text":"txt(\u2026) takes a string resource id and returns a CharSequence str(\u2026) takes a string resource id and returns a String . There\u2019s also optional format arguments. qtyTxt(\u2026) (for plurals) returns a CharSequence qtyStr(\u2026) (for plurals) returns a String . There\u2019s also optional format arguments. txtArray(\u2026) takes an array resource id and returns an Array<out CharSequence> strArray(\u2026) takes an array resource id and returns an Array<String> styledTxt(\u2026) takes a string theme attribute and returns a CharSequence? styledStr(\u2026) takes a string theme attribute and returns a String? There\u2019s also optional format arguments. styledTxtArray(\u2026) takes an array theme attribute and returns an Array<out CharSequence>?","title":"Text"},{"location":"3/resources/#any-resource-type","text":"The resolveThemeAttribute extension function for Context takes a resource id of type R.attr and returns its corresponding resource id as resolved from the current theme in the Context .","title":"Any resource type"},{"location":"3/resources/#download","text":"implementation ( \"com.louiscad.splitties:splitties-resources:3.0.0-beta01\" )","title":"Download"},{"location":"3/sample-android-app/","text":"Splitties Sample \u00b6","title":"sample-android-app"},{"location":"3/sample-android-app/#splitties-sample","text":"","title":"Splitties Sample"},{"location":"3/snackbar/","text":"Snackbar \u00b6 Grab a snack without ceremony with snack(\u2026) and longSnack(\u2026) Supported platforms: Android . This split provides extensions to show a Snackbar , boilerplate free. It also has a small extension functions based DSL to add an action and execute action on dismiss. Usage \u00b6 On a CoordinatorLayout or any other View , call snack(\u2026) , longSnack(\u2026) (if you\u2019re really hungry, for example), or snackForever(\u2026) for an indefinite duration, with a string resource id, or a CharSequence . You can add optional braces to access the Snackbar instance before it is shown, so you can add an action (using action(\u2026) { \u2026 } ) and add callback for dismissal (using onDismiss(\u2026) ). Note that snackbar(\u2026) , longSnack(\u2026) and snackForever(\u2026) return the created Snackbar instance. That means you can as well add onDismiss(\u2026) on the result of the call instead of inside the optional inline lambda. Download \u00b6 implementation ( \"com.louiscad.splitties:splitties-snackbar:3.0.0-beta01\" )","title":"snackbar"},{"location":"3/snackbar/#snackbar","text":"Grab a snack without ceremony with snack(\u2026) and longSnack(\u2026) Supported platforms: Android . This split provides extensions to show a Snackbar , boilerplate free. It also has a small extension functions based DSL to add an action and execute action on dismiss.","title":"Snackbar"},{"location":"3/snackbar/#usage","text":"On a CoordinatorLayout or any other View , call snack(\u2026) , longSnack(\u2026) (if you\u2019re really hungry, for example), or snackForever(\u2026) for an indefinite duration, with a string resource id, or a CharSequence . You can add optional braces to access the Snackbar instance before it is shown, so you can add an action (using action(\u2026) { \u2026 } ) and add callback for dismissal (using onDismiss(\u2026) ). Note that snackbar(\u2026) , longSnack(\u2026) and snackForever(\u2026) return the created Snackbar instance. That means you can as well add onDismiss(\u2026) on the result of the call instead of inside the optional inline lambda.","title":"Usage"},{"location":"3/snackbar/#download","text":"implementation ( \"com.louiscad.splitties:splitties-snackbar:3.0.0-beta01\" )","title":"Download"},{"location":"3/stetho-init/","text":"Stetho Init \u00b6 Have Stetho for your debug builds, without writing any code! Supported platforms: Android . This library uses an InitProvider (like appCtx , and similarly to Firebase) to initialize Stetho automatically. You just have to include the dependency on your debug build and voil\u00e0! Usage \u00b6 Add the dependency to your debug build like in the example below: debugImplementation ( \"com.louiscad.splitties:splitties-stetho-init:3.0.0-beta01\" ) Assuming your Android device is visible from adb on your computer, you can now navigate to chrome://inspect to see your updated debug app in Chrome Dev Tools, no further configuration required. Download \u00b6 debugImplementation ( \"com.louiscad.splitties:splitties-stetho-init:3.0.0-beta01\" )","title":"stetho-init"},{"location":"3/stetho-init/#stetho-init","text":"Have Stetho for your debug builds, without writing any code! Supported platforms: Android . This library uses an InitProvider (like appCtx , and similarly to Firebase) to initialize Stetho automatically. You just have to include the dependency on your debug build and voil\u00e0!","title":"Stetho Init"},{"location":"3/stetho-init/#usage","text":"Add the dependency to your debug build like in the example below: debugImplementation ( \"com.louiscad.splitties:splitties-stetho-init:3.0.0-beta01\" ) Assuming your Android device is visible from adb on your computer, you can now navigate to chrome://inspect to see your updated debug app in Chrome Dev Tools, no further configuration required.","title":"Usage"},{"location":"3/stetho-init/#download","text":"debugImplementation ( \"com.louiscad.splitties:splitties-stetho-init:3.0.0-beta01\" )","title":"Download"},{"location":"3/systemservices/","text":"System Services \u00b6 No more context.getSystemService(NAME_OF_SERVICE) as NameOfManager . Supported platforms: Android . This library contains all the Android System Services as of API 29. It allows accessing them with a simple property. Most System Services use the application Context and are available anywhere in the code of your app, but some that can vary depending on the Context (like LayoutInflater or WindowManager ) are extensions on Context , View or AccessibilityService . Example \u00b6 Before: fun performSomeVibration ( vibe : VibrationEffect ) { val vibrator = context . getSystemService ( VIBRATOR_SERVICE ) as Vibrator vibrator . vibrate ( vibe ) } After: fun performSomeVibration ( vibe : VibrationEffect ) { vibrator . vibrate ( vibe ) } Download \u00b6 implementation ( \"com.louiscad.splitties:splitties-systemservices:3.0.0-beta01\" )","title":"systemservices"},{"location":"3/systemservices/#system-services","text":"No more context.getSystemService(NAME_OF_SERVICE) as NameOfManager . Supported platforms: Android . This library contains all the Android System Services as of API 29. It allows accessing them with a simple property. Most System Services use the application Context and are available anywhere in the code of your app, but some that can vary depending on the Context (like LayoutInflater or WindowManager ) are extensions on Context , View or AccessibilityService .","title":"System Services"},{"location":"3/systemservices/#example","text":"Before: fun performSomeVibration ( vibe : VibrationEffect ) { val vibrator = context . getSystemService ( VIBRATOR_SERVICE ) as Vibrator vibrator . vibrate ( vibe ) } After: fun performSomeVibration ( vibe : VibrationEffect ) { vibrator . vibrate ( vibe ) }","title":"Example"},{"location":"3/systemservices/#download","text":"implementation ( \"com.louiscad.splitties:splitties-systemservices:3.0.0-beta01\" )","title":"Download"},{"location":"3/toast/","text":"Toast \u00b6 Show a toast by just calling toast(yourText) , and dodge API 25 BadTokenException . Supported platforms: Android . To create and show a Toast , just call toast(\u2026) (for breakfast) or longToast(\u2026) (for breakslow) with either a string resource id or a CharSequence . Download \u00b6 implementation ( \"com.louiscad.splitties:splitties-toast:3.0.0-beta01\" )","title":"toast"},{"location":"3/toast/#toast","text":"Show a toast by just calling toast(yourText) , and dodge API 25 BadTokenException . Supported platforms: Android . To create and show a Toast , just call toast(\u2026) (for breakfast) or longToast(\u2026) (for breakslow) with either a string resource id or a CharSequence .","title":"Toast"},{"location":"3/toast/#download","text":"implementation ( \"com.louiscad.splitties:splitties-toast:3.0.0-beta01\" )","title":"Download"},{"location":"3/typesaferecyclerview/","text":"Typesafe RecyclerView \u00b6 Typesafe ViewHolder and ItemViewHolder for easy basic usage of RecyclerView . Supported platforms: Android . This modules consists of two ViewHolder subclasses that make it typesafe, and easier to use for the common use case which is to bind a ViewHolder to a POJO (plain-old Java Object ) or a POKA (plain-old Kotlin Any ). See the sample to understand how it works. Usage \u00b6 When using ViewHolder , use the one from Splitties to get the typesafe one. See it in action in the sample: DemoAdapter . Download \u00b6 implementation ( \"com.louiscad.splitties:splitties-typesaferecyclerview:3.0.0-beta01\" )","title":"typesaferecyclerview"},{"location":"3/typesaferecyclerview/#typesafe-recyclerview","text":"Typesafe ViewHolder and ItemViewHolder for easy basic usage of RecyclerView . Supported platforms: Android . This modules consists of two ViewHolder subclasses that make it typesafe, and easier to use for the common use case which is to bind a ViewHolder to a POJO (plain-old Java Object ) or a POKA (plain-old Kotlin Any ). See the sample to understand how it works.","title":"Typesafe RecyclerView"},{"location":"3/typesaferecyclerview/#usage","text":"When using ViewHolder , use the one from Splitties to get the typesafe one. See it in action in the sample: DemoAdapter .","title":"Usage"},{"location":"3/typesaferecyclerview/#download","text":"implementation ( \"com.louiscad.splitties:splitties-typesaferecyclerview:3.0.0-beta01\" )","title":"Download"},{"location":"3/views-appcompat/","text":"Views AppCompat \u00b6 AppCompat extension of Views Supported platforms: Android . Content \u00b6 Tooltip helpers \u00b6 tooltipTxt allows to set a tooltip text on any View using property syntax even on pre-O devices (using AndroidX\u2019s TooltipCompat in these cases). The contentDescAsTooltip() extension function for View takes the content description of your view (used for accessibility) and sets it as the tooltip text so users can long press or hover on the view and see what it is. ImageView tinting \u00b6 The imgTintList and imgTintMode extension properties for ImageView are the same as imageTintList and imageTintMode \u2026 except they work before API 21 because they delegate to AndroidX\u2019s ImageViewCompat . ActionBar extensions \u00b6 The configActionBar { \u2026 } extension function for AppCompatActivity allows to easily setup the supportActionBar . If it is null, the passed lambda is ignored, and an AssertionError is logged. The showTitle , showHome , homeAsUp , useLogo and showCustomView boolean extension properties are meant to be used on an Actionbar (usually inside the configActionBar { \u2026 } lambda). They are more readable than the setDisplayHomeAsUpEnabled and alike methods. Config changes handling Toolbar \u00b6 AppCompat Toolbar from AndroidX has different dimensions and text sizes for portrait and landscape modes, but they are not updated when the configuration changes. splitties.views.appcompat.Toolbar extends it and updates it when configuration changes so you can avoid restarting your Activity when the device rotates, goes into multi-window mode or undergoes any other window size related config change if the rest of your content handles this without needing to be recreated. Download \u00b6 implementation ( \"com.louiscad.splitties:splitties-views-appcompat:3.0.0-beta01\" )","title":"views-appcompat"},{"location":"3/views-appcompat/#views-appcompat","text":"AppCompat extension of Views Supported platforms: Android .","title":"Views AppCompat"},{"location":"3/views-appcompat/#content","text":"","title":"Content"},{"location":"3/views-appcompat/#tooltip-helpers","text":"tooltipTxt allows to set a tooltip text on any View using property syntax even on pre-O devices (using AndroidX\u2019s TooltipCompat in these cases). The contentDescAsTooltip() extension function for View takes the content description of your view (used for accessibility) and sets it as the tooltip text so users can long press or hover on the view and see what it is.","title":"Tooltip helpers"},{"location":"3/views-appcompat/#imageview-tinting","text":"The imgTintList and imgTintMode extension properties for ImageView are the same as imageTintList and imageTintMode \u2026 except they work before API 21 because they delegate to AndroidX\u2019s ImageViewCompat .","title":"ImageView tinting"},{"location":"3/views-appcompat/#actionbar-extensions","text":"The configActionBar { \u2026 } extension function for AppCompatActivity allows to easily setup the supportActionBar . If it is null, the passed lambda is ignored, and an AssertionError is logged. The showTitle , showHome , homeAsUp , useLogo and showCustomView boolean extension properties are meant to be used on an Actionbar (usually inside the configActionBar { \u2026 } lambda). They are more readable than the setDisplayHomeAsUpEnabled and alike methods.","title":"ActionBar extensions"},{"location":"3/views-appcompat/#config-changes-handling-toolbar","text":"AppCompat Toolbar from AndroidX has different dimensions and text sizes for portrait and landscape modes, but they are not updated when the configuration changes. splitties.views.appcompat.Toolbar extends it and updates it when configuration changes so you can avoid restarting your Activity when the device rotates, goes into multi-window mode or undergoes any other window size related config change if the rest of your content handles this without needing to be recreated.","title":"Config changes handling Toolbar"},{"location":"3/views-appcompat/#download","text":"implementation ( \"com.louiscad.splitties:splitties-views-appcompat:3.0.0-beta01\" )","title":"Download"},{"location":"3/views-cardview/","text":"Views CardView \u00b6 CardView extension of Views Supported platforms: Android . Content \u00b6 contentPadding allows to set the padding of the content of a CardView using property syntax. This is all this split provides at the moment. Download \u00b6 implementation ( \"com.louiscad.splitties:splitties-views-cardview:3.0.0-beta01\" )","title":"views-cardview"},{"location":"3/views-cardview/#views-cardview","text":"CardView extension of Views Supported platforms: Android .","title":"Views CardView"},{"location":"3/views-cardview/#content","text":"contentPadding allows to set the padding of the content of a CardView using property syntax. This is all this split provides at the moment.","title":"Content"},{"location":"3/views-cardview/#download","text":"implementation ( \"com.louiscad.splitties:splitties-views-cardview:3.0.0-beta01\" )","title":"Download"},{"location":"3/views-coroutines-material/","text":"Views Coroutines Material \u00b6 Material Components + Kotlin coroutines. Supported platforms: Android . Extension functions: Name Description FloatingActionButton.showAndAwaitOneClickThenHide Calls show() , suspends until the FAB is clicked and finally calls hide() . Cancellable. Download \u00b6 implementation ( \"com.louiscad.splitties:splitties-views-coroutines-material:3.0.0-beta01\" )","title":"views-coroutines-material"},{"location":"3/views-coroutines-material/#views-coroutines-material","text":"Material Components + Kotlin coroutines. Supported platforms: Android . Extension functions: Name Description FloatingActionButton.showAndAwaitOneClickThenHide Calls show() , suspends until the FAB is clicked and finally calls hide() . Cancellable.","title":"Views Coroutines Material"},{"location":"3/views-coroutines-material/#download","text":"implementation ( \"com.louiscad.splitties:splitties-views-coroutines-material:3.0.0-beta01\" )","title":"Download"},{"location":"3/views-coroutines/","text":"Views Coroutines \u00b6 Android Views + Kotlin coroutines. Supported platforms: Android . Extension functions: Name Description View.awaitOneClick Suspends until the view is clicked. Cancellable. View.awaitOneLongClick Suspends until the view is long clicked. Cancellable. View.visibleUntilClicked Makes the view visible until it is clicked and the passed lambda is executed. Cancellable. View.visibleUntilLongClicked Makes the view visible until it is long clicked and the passed lambda is executed. Cancellable. View.visibleInScope Makes the view visible while the passed lambda is executing. View.goneInScope Makes the view gone while the passed lambda is executing. View.invisibleInScope Makes the view invisible while the passed lambda is executing. Download \u00b6 implementation ( \"com.louiscad.splitties:splitties-views-coroutines:3.0.0-beta01\" )","title":"views-coroutines"},{"location":"3/views-coroutines/#views-coroutines","text":"Android Views + Kotlin coroutines. Supported platforms: Android . Extension functions: Name Description View.awaitOneClick Suspends until the view is clicked. Cancellable. View.awaitOneLongClick Suspends until the view is long clicked. Cancellable. View.visibleUntilClicked Makes the view visible until it is clicked and the passed lambda is executed. Cancellable. View.visibleUntilLongClicked Makes the view visible until it is long clicked and the passed lambda is executed. Cancellable. View.visibleInScope Makes the view visible while the passed lambda is executing. View.goneInScope Makes the view gone while the passed lambda is executing. View.invisibleInScope Makes the view invisible while the passed lambda is executing.","title":"Views Coroutines"},{"location":"3/views-coroutines/#download","text":"implementation ( \"com.louiscad.splitties:splitties-views-coroutines:3.0.0-beta01\" )","title":"Download"},{"location":"3/views-dsl-appcompat/","text":"Views DSL AppCompat \u00b6 AppCompat extension of Views DSL Supported platforms: Android . How AppCompat works with xml \u00b6 When using an AppCompat theme, the LayoutInflater replaces the platform widgets like TextView and Button found in your xml layouts by a compatibility version (i.e. AppCompatButton , AppCompatTextView , etc.). If you\u2019re curious to see how it works, look for the method createView in the AppCompatViewInflater class from the androidx.appcompat.app package. How AppCompat works with Splitties Views DSL \u00b6 Since the LayoutInflater only works on xml, if you use view(::TextView) with Views DSL, you get a TextView instance, not an AppCompatTextView instance. This means it will not have AppCompat features and styling (e.g. auto size for TextView ). However, if you use textView() it will automatically delegate to this split if in the dependencies, returning an AppCompatTextView instance. This works for all AppCompat widgets. If you want to use a style defined in appcompat (like Widget_AppCompat_Button_Colored ), just cache locally an AppCompatStyles instance and use its properties and functions. Supported widgets \u00b6 All AppCompat widgets are supported. Here\u2019s the full list: * TextView * ImageView * Button * EditText * Spinner * ImageButton * CheckBox * RadioButton * CheckedTextView * AutoCompleteTextView * MultiAutoCompleteTextView * RatingBar * SeekBar Just call the related method that is the camelCase version of the PascalCase constructor. For example, you can call seekBar(\u2026) { \u2026 } and you\u2019ll receive an AppCompatSeekBar instance. Note that automatically doesn\u2019t mean magically. In fact, no reflection is involved (contrary to xml inflation). You can also see the source of the function that maps to AppCompat widgets versions , and the InitProvider that makes it zero initialization on your side . There\u2019s also support for Toolbar with the toolbar function, and SwitchCompat with the switch function. Note that the returned Toolbar handles config changes. Multi-process apps \u00b6 If your app needs to use AppCompat themed widgets in the non default process, you\u2019ll need to manually setup ViewFactory so it uses AppCompat. Here\u2019s how you need to it: Copy paste this InitProvider into a package of an android library/app module of your project, then declare it in the AndroidManifest.xml of the module exactly like it is done here . To do so, copy paste it, then fix the package of the class under the android:name xml attribute of the provider tag, then specify the android:process value to the one of your non default process. Be sure to test it to make sure you have set it up properly. Download \u00b6 implementation ( \"com.louiscad.splitties:splitties-views-dsl-appcompat:3.0.0-beta01\" )","title":"views-dsl-appcompat"},{"location":"3/views-dsl-appcompat/#views-dsl-appcompat","text":"AppCompat extension of Views DSL Supported platforms: Android .","title":"Views DSL AppCompat"},{"location":"3/views-dsl-appcompat/#how-appcompat-works-with-xml","text":"When using an AppCompat theme, the LayoutInflater replaces the platform widgets like TextView and Button found in your xml layouts by a compatibility version (i.e. AppCompatButton , AppCompatTextView , etc.). If you\u2019re curious to see how it works, look for the method createView in the AppCompatViewInflater class from the androidx.appcompat.app package.","title":"How AppCompat works with xml"},{"location":"3/views-dsl-appcompat/#how-appcompat-works-with-splitties-views-dsl","text":"Since the LayoutInflater only works on xml, if you use view(::TextView) with Views DSL, you get a TextView instance, not an AppCompatTextView instance. This means it will not have AppCompat features and styling (e.g. auto size for TextView ). However, if you use textView() it will automatically delegate to this split if in the dependencies, returning an AppCompatTextView instance. This works for all AppCompat widgets. If you want to use a style defined in appcompat (like Widget_AppCompat_Button_Colored ), just cache locally an AppCompatStyles instance and use its properties and functions.","title":"How AppCompat works with Splitties Views DSL"},{"location":"3/views-dsl-appcompat/#supported-widgets","text":"All AppCompat widgets are supported. Here\u2019s the full list: * TextView * ImageView * Button * EditText * Spinner * ImageButton * CheckBox * RadioButton * CheckedTextView * AutoCompleteTextView * MultiAutoCompleteTextView * RatingBar * SeekBar Just call the related method that is the camelCase version of the PascalCase constructor. For example, you can call seekBar(\u2026) { \u2026 } and you\u2019ll receive an AppCompatSeekBar instance. Note that automatically doesn\u2019t mean magically. In fact, no reflection is involved (contrary to xml inflation). You can also see the source of the function that maps to AppCompat widgets versions , and the InitProvider that makes it zero initialization on your side . There\u2019s also support for Toolbar with the toolbar function, and SwitchCompat with the switch function. Note that the returned Toolbar handles config changes.","title":"Supported widgets"},{"location":"3/views-dsl-appcompat/#multi-process-apps","text":"If your app needs to use AppCompat themed widgets in the non default process, you\u2019ll need to manually setup ViewFactory so it uses AppCompat. Here\u2019s how you need to it: Copy paste this InitProvider into a package of an android library/app module of your project, then declare it in the AndroidManifest.xml of the module exactly like it is done here . To do so, copy paste it, then fix the package of the class under the android:name xml attribute of the provider tag, then specify the android:process value to the one of your non default process. Be sure to test it to make sure you have set it up properly.","title":"Multi-process apps"},{"location":"3/views-dsl-appcompat/#download","text":"implementation ( \"com.louiscad.splitties:splitties-views-dsl-appcompat:3.0.0-beta01\" )","title":"Download"},{"location":"3/views-dsl-constraintlayout/","text":"Views DSL ConstraintLayout \u00b6 ConstraintLayout extension of Views DSL . Supported platforms: Android . Table of contents \u00b6 ConstraintLayout tailored lParams extension ConstraintLayout.LayoutParams extensions for safe and readable usage Download ConstraintLayout tailored lParams extension \u00b6 The lParams() extension function on ConstraintLayout looks to be similar to the similarly named extensions on LinearLayout and FrameLayout , but there are two key differences: * Since ConstraintLayout children are meant to have constraints, their default width and height are matchConstraints , not wrapContent . That means that you\u2019ll often have to specify height = wrapContent for things like TextView s and Button s. * In xml, match_parent is not supported for ConstraintLayout and can decrease performance (the alternative being adding 0dp + 2 parent relative constraints). This is not the case here as matchParent is rewritten as matchConstraints with the appropriate parent relative constraints . The result is a more readable UI code, without performance compromises. ConstraintLayout.LayoutParams extensions for safe and readable usage \u00b6 With this split also comes a set of extension functions to use in lParams(\u2026) { \u2026 } . Almost all of them have optional margin and goneMargin parameters. Center relatively to parent: * centerHorizontally(\u2026) * centerVertically(\u2026) * centerInParent(\u2026) Parent relative constraints: * topOfParent(\u2026) * bottomOfParent(\u2026) * startOfParent(\u2026) * endOfParent(\u2026) * leftOfParent(\u2026) * rightOfParent(\u2026) Center relatively to another View : * alignVerticallyOn(\u2026) * alignHorizontallyOn(\u2026) * centerOn(\u2026) View relative constraints: * above(\u2026) (alias to bottomToTopOf(\u2026) ) * below(\u2026) (alias to topToBottomOf(\u2026) ) * before(\u2026) (alias to endToStartOf(\u2026) ) * after(\u2026) (alias to startToEndOf(\u2026) ) * topToTopOf(\u2026) * topToBottomOf(\u2026) * bottomToTopOf(\u2026) * bottomToBottomOf(\u2026) * baselineToBaselineOf(\u2026) * startToStartOf(\u2026) * startToEndOf(\u2026) * endToStartOf(\u2026) * endToEndOf(\u2026) * leftToLeftOf(\u2026) * leftToRightOf(\u2026) * rightToRightOf(\u2026) * rightToLeftOf(\u2026) Chains: * horizontalChain(\u2026) { \u2026 } and its companion horizontalMargin extension for List<View> . * verticalChain(\u2026) { \u2026 } and its companion verticalMargin extension for List<View> . Barriers: * barrier(\u2026) which takes a BarrierType (inline class) and a list or vararg of View s. * startBarrier(\u2026) , leftBarrier(\u2026) , topBarrier(\u2026) , endBarrier(\u2026) , rightBarrier(\u2026) and bottomBarrier(\u2026) Guidelines: * verticalGuideline(\u2026) and horizontalGuideline(\u2026) which take a begin offset (pixels), an end offset, or a ratio (between 0 and 1). Groups: * group(\u2026) which takes the views to group. These methods come with a great bonus feature: If a View involved in a constraint has no valid id , then a generated one is automatically assigned to it! These generated ids can\u2019t clash with aapt/xml ids, so it\u2019s safe to put xml defined ids on some views that need to have their state saved (e.g. a RecyclerView , an EditText or a CheckBox ) in the same layout. Note that View ids are crucial to ConstraintLayout machinery. Download \u00b6 implementation ( \"com.louiscad.splitties:splitties-views-dsl-constraintlayout:3.0.0-beta01\" )","title":"views-dsl-constraintlayout"},{"location":"3/views-dsl-constraintlayout/#views-dsl-constraintlayout","text":"ConstraintLayout extension of Views DSL . Supported platforms: Android .","title":"Views DSL ConstraintLayout"},{"location":"3/views-dsl-constraintlayout/#table-of-contents","text":"ConstraintLayout tailored lParams extension ConstraintLayout.LayoutParams extensions for safe and readable usage Download","title":"Table of contents"},{"location":"3/views-dsl-constraintlayout/#constraintlayout-tailored-lparams-extension","text":"The lParams() extension function on ConstraintLayout looks to be similar to the similarly named extensions on LinearLayout and FrameLayout , but there are two key differences: * Since ConstraintLayout children are meant to have constraints, their default width and height are matchConstraints , not wrapContent . That means that you\u2019ll often have to specify height = wrapContent for things like TextView s and Button s. * In xml, match_parent is not supported for ConstraintLayout and can decrease performance (the alternative being adding 0dp + 2 parent relative constraints). This is not the case here as matchParent is rewritten as matchConstraints with the appropriate parent relative constraints . The result is a more readable UI code, without performance compromises.","title":"ConstraintLayout tailored lParams extension"},{"location":"3/views-dsl-constraintlayout/#constraintlayoutlayoutparams-extensions-for-safe-and-readable-usage","text":"With this split also comes a set of extension functions to use in lParams(\u2026) { \u2026 } . Almost all of them have optional margin and goneMargin parameters. Center relatively to parent: * centerHorizontally(\u2026) * centerVertically(\u2026) * centerInParent(\u2026) Parent relative constraints: * topOfParent(\u2026) * bottomOfParent(\u2026) * startOfParent(\u2026) * endOfParent(\u2026) * leftOfParent(\u2026) * rightOfParent(\u2026) Center relatively to another View : * alignVerticallyOn(\u2026) * alignHorizontallyOn(\u2026) * centerOn(\u2026) View relative constraints: * above(\u2026) (alias to bottomToTopOf(\u2026) ) * below(\u2026) (alias to topToBottomOf(\u2026) ) * before(\u2026) (alias to endToStartOf(\u2026) ) * after(\u2026) (alias to startToEndOf(\u2026) ) * topToTopOf(\u2026) * topToBottomOf(\u2026) * bottomToTopOf(\u2026) * bottomToBottomOf(\u2026) * baselineToBaselineOf(\u2026) * startToStartOf(\u2026) * startToEndOf(\u2026) * endToStartOf(\u2026) * endToEndOf(\u2026) * leftToLeftOf(\u2026) * leftToRightOf(\u2026) * rightToRightOf(\u2026) * rightToLeftOf(\u2026) Chains: * horizontalChain(\u2026) { \u2026 } and its companion horizontalMargin extension for List<View> . * verticalChain(\u2026) { \u2026 } and its companion verticalMargin extension for List<View> . Barriers: * barrier(\u2026) which takes a BarrierType (inline class) and a list or vararg of View s. * startBarrier(\u2026) , leftBarrier(\u2026) , topBarrier(\u2026) , endBarrier(\u2026) , rightBarrier(\u2026) and bottomBarrier(\u2026) Guidelines: * verticalGuideline(\u2026) and horizontalGuideline(\u2026) which take a begin offset (pixels), an end offset, or a ratio (between 0 and 1). Groups: * group(\u2026) which takes the views to group. These methods come with a great bonus feature: If a View involved in a constraint has no valid id , then a generated one is automatically assigned to it! These generated ids can\u2019t clash with aapt/xml ids, so it\u2019s safe to put xml defined ids on some views that need to have their state saved (e.g. a RecyclerView , an EditText or a CheckBox ) in the same layout. Note that View ids are crucial to ConstraintLayout machinery.","title":"ConstraintLayout.LayoutParams extensions for safe and readable usage"},{"location":"3/views-dsl-constraintlayout/#download","text":"implementation ( \"com.louiscad.splitties:splitties-views-dsl-constraintlayout:3.0.0-beta01\" )","title":"Download"},{"location":"3/views-dsl-coordinatorlayout/","text":"Views DSL CoordinatorLayout \u00b6 CoordinatorLayout extension of Views DSL . Supported platforms: Android . Table of contents \u00b6 Functions to instantiate a CoordinatorLayout CoordinatorLayout extensions defaultLParams appBarLParams CoordinatorLayout.LayoutParams extensions anchorTo Functions to instantiate a CoordinatorLayout \u00b6 Instead of using view(::CoordinatorLayout, \u2026) { \u2026 } , you can use coordinatorLayout(\u2026) { \u2026 } . CoordinatorLayout extensions \u00b6 defaultLParams \u00b6 This extension has default width and height set to wrapContent and an optional gravity parameter. appBarLParams \u00b6 Has a matchParent width. Use it when adding an AppBarLayout or a similar View that takes the app bar role. CoordinatorLayout.LayoutParams extensions \u00b6 anchorTo \u00b6 Anchors the passed View with the specified gravity, setting a generated id if it had none. Download \u00b6 implementation ( \"com.louiscad.splitties:splitties-views-dsl-coordinatorlayout:3.0.0-beta01\" )","title":"views-dsl-coordinatorlayout"},{"location":"3/views-dsl-coordinatorlayout/#views-dsl-coordinatorlayout","text":"CoordinatorLayout extension of Views DSL . Supported platforms: Android .","title":"Views DSL CoordinatorLayout"},{"location":"3/views-dsl-coordinatorlayout/#table-of-contents","text":"Functions to instantiate a CoordinatorLayout CoordinatorLayout extensions defaultLParams appBarLParams CoordinatorLayout.LayoutParams extensions anchorTo","title":"Table of contents"},{"location":"3/views-dsl-coordinatorlayout/#functions-to-instantiate-a-coordinatorlayout","text":"Instead of using view(::CoordinatorLayout, \u2026) { \u2026 } , you can use coordinatorLayout(\u2026) { \u2026 } .","title":"Functions to instantiate a CoordinatorLayout"},{"location":"3/views-dsl-coordinatorlayout/#coordinatorlayout-extensions","text":"","title":"CoordinatorLayout extensions"},{"location":"3/views-dsl-coordinatorlayout/#defaultlparams","text":"This extension has default width and height set to wrapContent and an optional gravity parameter.","title":"defaultLParams"},{"location":"3/views-dsl-coordinatorlayout/#appbarlparams","text":"Has a matchParent width. Use it when adding an AppBarLayout or a similar View that takes the app bar role.","title":"appBarLParams"},{"location":"3/views-dsl-coordinatorlayout/#coordinatorlayoutlayoutparams-extensions","text":"","title":"CoordinatorLayout.LayoutParams extensions"},{"location":"3/views-dsl-coordinatorlayout/#anchorto","text":"Anchors the passed View with the specified gravity, setting a generated id if it had none.","title":"anchorTo"},{"location":"3/views-dsl-coordinatorlayout/#download","text":"implementation ( \"com.louiscad.splitties:splitties-views-dsl-coordinatorlayout:3.0.0-beta01\" )","title":"Download"},{"location":"3/views-dsl-ide-preview/","text":"Views DSL IDE preview [DEPRECATED] \u00b6 Preview UIs made with Splitties Views DSL. This split has been deprecated and is now included directly into the debug variant of the Views DSL split. The package name has been left unchanged. Dependency (for reference) \u00b6 debugImplementation ( \"com.louiscad.splitties:splitties-views-dsl-ide-preview:3.0.0-beta01\" )","title":"views-dsl-ide-preview"},{"location":"3/views-dsl-ide-preview/#views-dsl-ide-preview-deprecated","text":"Preview UIs made with Splitties Views DSL. This split has been deprecated and is now included directly into the debug variant of the Views DSL split. The package name has been left unchanged.","title":"Views DSL IDE preview [DEPRECATED]"},{"location":"3/views-dsl-ide-preview/#dependency-for-reference","text":"debugImplementation ( \"com.louiscad.splitties:splitties-views-dsl-ide-preview:3.0.0-beta01\" )","title":"Dependency (for reference)"},{"location":"3/views-dsl-material/","text":"Views DSL Material \u00b6 Material Components extension of Views DSL Supported platforms: Android . Table of contents \u00b6 Functions to instantiate Views and ViewGroups from Material Components Multi-process apps Use Material Components xml styles in a typesafe way Extensions on ViewGroups from Material Components AppBarLayout extensions defaultLParams Values for scrollFlags CollapsingToolbarLayout extensions defaultLParams actionBarLParams Values for collapseMode CoordinatorLayout extensions More in Views DSL CoordinatorLayout contentScrollingWithAppBarLParams() Bottom sheet behavior extensions bottomSheetBehavior Bottom sheet state extensions TextInputLayout helper Download Functions to instantiate Views and ViewGroups from Material Components \u00b6 Instead of using view(::AppBarLayout) { \u2026 } and similar, you can use appBarLayout(\u2026) { \u2026 } . All widgets from Material Components are supported. To see the list, check the implementations for Views and ViewGroups . Note that there two bonuses in this split: * When calling appBarLayout(\u2026) { \u2026 } , you get an implementation that fixes a scrolling bug from Material Components where first click is ignored. * When calling collapsingToolbarLayout(\u2026) { \u2026 } , you get an implementation that handles config changes. Multi-process apps \u00b6 If your app needs to use AppCompat themed widgets in a non default process, you\u2019ll need to manually setup ViewFactory so it uses AppCompat. Here\u2019s how you need to it: Copy paste this InitProvider into a package of an android library/app module of your project, then declare it in the AndroidManifest.xml of the module exactly like it is done here . To do so, copy paste it, then fix the package of the class under the android:name xml attribute of the provider tag, then specify the android:process value to the one of your non default process. Be sure to test it to make sure you have set it up properly. Use Material Components xml styles in a typesafe way \u00b6 Since Material Components styles are not included by default inside the theme, you need to load them first. This is simply done with the following code: private val materialStyles = MaterialComponentsStyles ( ctx ) You can then use styles using the MaterialComponentsStyles instance. Here\u2019s an example: val bePoliteBtn = materialStyles . button . outlined { textResource = R . string . be_polite } Styles are supported for BottomAppBar , BottomNavigationView , MaterialButton , Chip , TabLayout and TextInputLayout . Extensions on ViewGroups from Material Components \u00b6 AppBarLayout extensions \u00b6 defaultLParams \u00b6 This extension function has a default width of matchParent and a default height of wrapContent so you don\u2019t have to specify them in most of the cases. It also has a scrollFlags parameter which defaults to ENTER_ALWAYS , same as when inflated from an xml layout. Use it when you add a View to an AppBarLayout . Values for scrollFlags \u00b6 SCROLL , EXIT_UNTIL_COLLAPSED , ENTER_ALWAYS , ENTER_ALWAYS_COLLAPSED and SNAP are extension properties on AppBarLayout that are meant to be used as flags (using or if you use multiple ones) with the scrollFlags parameter of the defaultLParams function mentioned above. They are provided for your convenience so they appear in autocomplete when relevant. CollapsingToolbarLayout extensions \u00b6 defaultLParams \u00b6 As for AppBarLayout , this extension function has a default width of matchParent and a default height of wrapContent so you don\u2019t have to specify them in most of the cases. It also has two optional parameters: - collapseMode , which defaults to COLLAPSE_MODE_OFF - parallaxMultiplier , which defaults to 0.5f (default value as of 27.1.1) Use it when you add a View to a CollapsingToolbarLayout . actionBarLParams \u00b6 Similar to defaultLParams , but the height is R.attr.actionBarSize instead of wrapContent . Use it when adding a Toolbar . Values for collapseMode \u00b6 PIN and PARALLAX are extension properties on CollapsingToolbarLayout that are meant to be used for the collapseMode parameter of the defaultLParams and actionBarLParams functions mentioned above. They are provided for your convenience so they appear in autocomplete when relevant. CoordinatorLayout extensions \u00b6 More in Views DSL CoordinatorLayout \u00b6 This split has a transitive dependency on Views DSL CoordinatorLayout which includes coordinatorLayout instantiating function, as well as layout params functions like defaultLParams , appBarLParams , and anchorTo . contentScrollingWithAppBarLParams() \u00b6 If your CoordinatorLayout has an AppbarLayout and scrolling content (e.g. a RecyclerView ), use this method to add the scrolling content View. It sets an AppBarLayout.ScrollingViewBehavior under the hood. This function accepts an optional config lambda. Bottom sheet behavior extensions \u00b6 bottomSheetBehavior \u00b6 This extension function on Ui that takes an optional initialization lambda creates a BottomSheetBehavior to use on CoordinatorLayout.LayoutParams . Bottom sheet state extensions \u00b6 This split also includes extensions on BottomSheetBehavior : * hidden and expanded : read-write extension properties. * hide() and expand() : extension functions. They make playing with your bottom sheets programmatically a breeze. See their KDoc to see their exact behavior. TextInputLayout helper \u00b6 The addInput extension function on TextInputLayout takes a required id used for the TextInputEditText that it creates and adds to the layout. The id is required so the content of the user input is saved in instance state even if the host Activity is killed by the system. Download \u00b6 implementation ( \"com.louiscad.splitties:splitties-views-dsl-material:3.0.0-beta01\" )","title":"views-dsl-material"},{"location":"3/views-dsl-material/#views-dsl-material","text":"Material Components extension of Views DSL Supported platforms: Android .","title":"Views DSL Material"},{"location":"3/views-dsl-material/#table-of-contents","text":"Functions to instantiate Views and ViewGroups from Material Components Multi-process apps Use Material Components xml styles in a typesafe way Extensions on ViewGroups from Material Components AppBarLayout extensions defaultLParams Values for scrollFlags CollapsingToolbarLayout extensions defaultLParams actionBarLParams Values for collapseMode CoordinatorLayout extensions More in Views DSL CoordinatorLayout contentScrollingWithAppBarLParams() Bottom sheet behavior extensions bottomSheetBehavior Bottom sheet state extensions TextInputLayout helper Download","title":"Table of contents"},{"location":"3/views-dsl-material/#functions-to-instantiate-views-and-viewgroups-from-material-components","text":"Instead of using view(::AppBarLayout) { \u2026 } and similar, you can use appBarLayout(\u2026) { \u2026 } . All widgets from Material Components are supported. To see the list, check the implementations for Views and ViewGroups . Note that there two bonuses in this split: * When calling appBarLayout(\u2026) { \u2026 } , you get an implementation that fixes a scrolling bug from Material Components where first click is ignored. * When calling collapsingToolbarLayout(\u2026) { \u2026 } , you get an implementation that handles config changes.","title":"Functions to instantiate Views and ViewGroups from Material Components"},{"location":"3/views-dsl-material/#multi-process-apps","text":"If your app needs to use AppCompat themed widgets in a non default process, you\u2019ll need to manually setup ViewFactory so it uses AppCompat. Here\u2019s how you need to it: Copy paste this InitProvider into a package of an android library/app module of your project, then declare it in the AndroidManifest.xml of the module exactly like it is done here . To do so, copy paste it, then fix the package of the class under the android:name xml attribute of the provider tag, then specify the android:process value to the one of your non default process. Be sure to test it to make sure you have set it up properly.","title":"Multi-process apps"},{"location":"3/views-dsl-material/#use-material-components-xml-styles-in-a-typesafe-way","text":"Since Material Components styles are not included by default inside the theme, you need to load them first. This is simply done with the following code: private val materialStyles = MaterialComponentsStyles ( ctx ) You can then use styles using the MaterialComponentsStyles instance. Here\u2019s an example: val bePoliteBtn = materialStyles . button . outlined { textResource = R . string . be_polite } Styles are supported for BottomAppBar , BottomNavigationView , MaterialButton , Chip , TabLayout and TextInputLayout .","title":"Use Material Components xml styles in a typesafe way"},{"location":"3/views-dsl-material/#extensions-on-viewgroups-from-material-components","text":"","title":"Extensions on ViewGroups from Material Components"},{"location":"3/views-dsl-material/#appbarlayout-extensions","text":"","title":"AppBarLayout extensions"},{"location":"3/views-dsl-material/#defaultlparams","text":"This extension function has a default width of matchParent and a default height of wrapContent so you don\u2019t have to specify them in most of the cases. It also has a scrollFlags parameter which defaults to ENTER_ALWAYS , same as when inflated from an xml layout. Use it when you add a View to an AppBarLayout .","title":"defaultLParams"},{"location":"3/views-dsl-material/#values-for-scrollflags","text":"SCROLL , EXIT_UNTIL_COLLAPSED , ENTER_ALWAYS , ENTER_ALWAYS_COLLAPSED and SNAP are extension properties on AppBarLayout that are meant to be used as flags (using or if you use multiple ones) with the scrollFlags parameter of the defaultLParams function mentioned above. They are provided for your convenience so they appear in autocomplete when relevant.","title":"Values for scrollFlags"},{"location":"3/views-dsl-material/#collapsingtoolbarlayout-extensions","text":"","title":"CollapsingToolbarLayout extensions"},{"location":"3/views-dsl-material/#defaultlparams_1","text":"As for AppBarLayout , this extension function has a default width of matchParent and a default height of wrapContent so you don\u2019t have to specify them in most of the cases. It also has two optional parameters: - collapseMode , which defaults to COLLAPSE_MODE_OFF - parallaxMultiplier , which defaults to 0.5f (default value as of 27.1.1) Use it when you add a View to a CollapsingToolbarLayout .","title":"defaultLParams"},{"location":"3/views-dsl-material/#actionbarlparams","text":"Similar to defaultLParams , but the height is R.attr.actionBarSize instead of wrapContent . Use it when adding a Toolbar .","title":"actionBarLParams"},{"location":"3/views-dsl-material/#values-for-collapsemode","text":"PIN and PARALLAX are extension properties on CollapsingToolbarLayout that are meant to be used for the collapseMode parameter of the defaultLParams and actionBarLParams functions mentioned above. They are provided for your convenience so they appear in autocomplete when relevant.","title":"Values for collapseMode"},{"location":"3/views-dsl-material/#coordinatorlayout-extensions","text":"","title":"CoordinatorLayout extensions"},{"location":"3/views-dsl-material/#more-in-views-dsl-coordinatorlayout","text":"This split has a transitive dependency on Views DSL CoordinatorLayout which includes coordinatorLayout instantiating function, as well as layout params functions like defaultLParams , appBarLParams , and anchorTo .","title":"More in Views DSL CoordinatorLayout"},{"location":"3/views-dsl-material/#contentscrollingwithappbarlparams","text":"If your CoordinatorLayout has an AppbarLayout and scrolling content (e.g. a RecyclerView ), use this method to add the scrolling content View. It sets an AppBarLayout.ScrollingViewBehavior under the hood. This function accepts an optional config lambda.","title":"contentScrollingWithAppBarLParams()"},{"location":"3/views-dsl-material/#bottom-sheet-behavior-extensions","text":"","title":"Bottom sheet behavior extensions"},{"location":"3/views-dsl-material/#bottomsheetbehavior","text":"This extension function on Ui that takes an optional initialization lambda creates a BottomSheetBehavior to use on CoordinatorLayout.LayoutParams .","title":"bottomSheetBehavior"},{"location":"3/views-dsl-material/#bottom-sheet-state-extensions","text":"This split also includes extensions on BottomSheetBehavior : * hidden and expanded : read-write extension properties. * hide() and expand() : extension functions. They make playing with your bottom sheets programmatically a breeze. See their KDoc to see their exact behavior.","title":"Bottom sheet state extensions"},{"location":"3/views-dsl-material/#textinputlayout-helper","text":"The addInput extension function on TextInputLayout takes a required id used for the TextInputEditText that it creates and adds to the layout. The id is required so the content of the user input is saved in instance state even if the host Activity is killed by the system.","title":"TextInputLayout helper"},{"location":"3/views-dsl-material/#download","text":"implementation ( \"com.louiscad.splitties:splitties-views-dsl-material:3.0.0-beta01\" )","title":"Download"},{"location":"3/views-dsl-recyclerview/","text":"Views DSL RecyclerView \u00b6 RecyclerView extension of Views DSL Supported platforms: Android . Table of contents \u00b6 RecyclerView with scrollbars Make any view scrollable RecyclerView item layout parameters Download RecyclerView with scrollbars \u00b6 To get scrollbars on a View in Android, you need to enable it in the android:scrollbars xml attribute first. Only then you can disable and re-enable them back using the isHorizontalScrollBarEnabled and isVerticalScrollBarEnabled properties. To overcome this problem, this split provides a recyclerView function . This function inflates a RecyclerView with both horizontal and vertical scrollbars enabled in xml, but the scrollbars will only ever appear if your content can scroll in that direction, so you likely just have to use it. Make any view scrollable \u00b6 Let\u2019s say you have a LinearLayout , or a TextView that is just a bit too long to fit into all screen sizes. In xml, you\u2019d likely use NestedScrollView , or good old ScrollView . Unfortunately, NestedScrollView has bugs that may cut off the content in some hard to reproduce consistently cases, and ScrollView doesn\u2019t support nested scroll as you may need in your app. On the other hand, there\u2019s RecyclerView , which has none of these issues. This split provides a wrapInRecyclerView extension function for View that returns a RecyclerView wrapping the View is has been called on. It is vertical by default, but you can set the horizontal parameter to true Also, you can (should) specify the id so scrolling position is saved into instance state and restored when needed. And you have an optional lambda to configure the RecyclerView , which can be useful for things like setting the padding and disabling clipping, setting the background, etc. Here\u2019s two small examples: val content = textView { textResource = R . string . a_very_long_string }. wrapInRecyclerView ( id = R . id . main_content ) { verticalPadding = dip ( 8 ) horizontalPadding = dip ( 16 ) clipToPadding = false } val content = textView { textResource = R . string . good_luck_scrolling_these_10_thousand_characters textSize = 48f // This size is interpreted in sp unit BTW }. wrapInRecyclerView ( horizontal = true ) RecyclerView item layout parameters \u00b6 RecyclerView.onCreateViewHolder method passes the parent ViewGroup so layout parameters are properly generated when the item view is inflated from xml. When using Views DSL in a RecyclerView , you are not inflating xml, so this parent parameter is of no use. However, you can set the item view layout parameters manually. This split provides two extension functions on RecyclerView.LayoutManager to make it easy: verticalListLayoutParams and horizontalListLayoutParams . Download \u00b6 implementation ( \"com.louiscad.splitties:splitties-views-dsl-recyclerview:3.0.0-beta01\" )","title":"views-dsl-recyclerview"},{"location":"3/views-dsl-recyclerview/#views-dsl-recyclerview","text":"RecyclerView extension of Views DSL Supported platforms: Android .","title":"Views DSL RecyclerView"},{"location":"3/views-dsl-recyclerview/#table-of-contents","text":"RecyclerView with scrollbars Make any view scrollable RecyclerView item layout parameters Download","title":"Table of contents"},{"location":"3/views-dsl-recyclerview/#recyclerview-with-scrollbars","text":"To get scrollbars on a View in Android, you need to enable it in the android:scrollbars xml attribute first. Only then you can disable and re-enable them back using the isHorizontalScrollBarEnabled and isVerticalScrollBarEnabled properties. To overcome this problem, this split provides a recyclerView function . This function inflates a RecyclerView with both horizontal and vertical scrollbars enabled in xml, but the scrollbars will only ever appear if your content can scroll in that direction, so you likely just have to use it.","title":"RecyclerView with scrollbars"},{"location":"3/views-dsl-recyclerview/#make-any-view-scrollable","text":"Let\u2019s say you have a LinearLayout , or a TextView that is just a bit too long to fit into all screen sizes. In xml, you\u2019d likely use NestedScrollView , or good old ScrollView . Unfortunately, NestedScrollView has bugs that may cut off the content in some hard to reproduce consistently cases, and ScrollView doesn\u2019t support nested scroll as you may need in your app. On the other hand, there\u2019s RecyclerView , which has none of these issues. This split provides a wrapInRecyclerView extension function for View that returns a RecyclerView wrapping the View is has been called on. It is vertical by default, but you can set the horizontal parameter to true Also, you can (should) specify the id so scrolling position is saved into instance state and restored when needed. And you have an optional lambda to configure the RecyclerView , which can be useful for things like setting the padding and disabling clipping, setting the background, etc. Here\u2019s two small examples: val content = textView { textResource = R . string . a_very_long_string }. wrapInRecyclerView ( id = R . id . main_content ) { verticalPadding = dip ( 8 ) horizontalPadding = dip ( 16 ) clipToPadding = false } val content = textView { textResource = R . string . good_luck_scrolling_these_10_thousand_characters textSize = 48f // This size is interpreted in sp unit BTW }. wrapInRecyclerView ( horizontal = true )","title":"Make any view scrollable"},{"location":"3/views-dsl-recyclerview/#recyclerview-item-layout-parameters","text":"RecyclerView.onCreateViewHolder method passes the parent ViewGroup so layout parameters are properly generated when the item view is inflated from xml. When using Views DSL in a RecyclerView , you are not inflating xml, so this parent parameter is of no use. However, you can set the item view layout parameters manually. This split provides two extension functions on RecyclerView.LayoutManager to make it easy: verticalListLayoutParams and horizontalListLayoutParams .","title":"RecyclerView item layout parameters"},{"location":"3/views-dsl-recyclerview/#download","text":"implementation ( \"com.louiscad.splitties:splitties-views-dsl-recyclerview:3.0.0-beta01\" )","title":"Download"},{"location":"3/views-dsl/","text":"Views DSL \u00b6 Create UIs with readable Kotlin code. Supported platforms: Android . There\u2019s a whole document about Views DSL vs xml layouts if you are not convinced yet. TL;DR: Kotlin code is more concise than xml, and a small library like this one is the proof of what is already possible with this great language. Splitties Views DSL has been designed to be: * Simple * Concise * Expressive * Explicit * Efficient * Reliable * Flexible That\u2019s 7 key considerations, which we believe are all necessary to make a great library. Introduction \u00b6 As said above, Splitties Views DSL has been designed to be simple . Consequently, you\u2019ll find no class in this split (API-wise, as strictly speaking, all functions and properties, even top-level ones and extensions belong to a class in the bytecode). That means you won\u2019t have to learn a whole new API to use Splitties Views DSL. You\u2019ll just have to discover the extension functions and properties as you need them to craft your Android user interfaces with Kotlin code. It turns out that you just need a few extension functions and properties to make UI-related code at least as readable as xml counterparts. Note that while putting all of your UI code directly in an Activity or a Fragment is possible with Splitties Views DSL (and can surely help for throwaway prototyping), we will be recommending a cleaner, yet simple approach (spoiler: a custom class). Before we dive into the details of the API, let\u2019s take a look at a simple example: val launchDemoBtn = button { textResource = R . string . go_to_the_demo } This example was meaningless , because no one ever publishes an app with only one button. Also, the snippet above just creates a button. If you want it into a ViewGroup , or as the content of an Activity or a Fragment , you need to do so explicitly. There are real examples in the sample . You can start by taking a look at MainUi . You can also see a simple example that uses ConstraintLayout in AboutUi . Opening the project in your IDE and navigating the sample UI code while reading this documentation may certainly help you have a hands-on experience and be comfortable more quickly writing UIs with Kotlin, a programming language that is probably already familiar to you. Table of contents \u00b6 The extensions Creating and configuring views The most generic way: view Using styles defined in xml Using Android styles Using AppCompat styles Using any other xml style The most simple and readable way: plain functions View extensions Inflating existing xml layouts Laying out the views ViewGroup.add(\u2026) , an alias to ViewGroup.addView(\u2026) ViewGroups extension functions to instantiate LayoutParams WARNING regarding lParams and defaultLParams usage Other extensions for ViewGroup The interface for user interfaces, named Ui Why this interface What it is made of Implementing the interface Using Ui implementations Simple examples Possibilities brought by the Ui interface IDE Preview IDE Preview Example Important info regarding xml based IDE Preview Interfaces parameters Known issues and their workaround Finding a suitable constructor to instantiate your UI Finding the class Modular user interface contracts Easier multi form factors support Multiplatform user interface contracts Testing Redesign A/B Testing Additional modules Download The extensions \u00b6 Splitties is primarily made of extension functions and properties, to create views with minimal code but maximum flexibility. Just calling the constructor, then calling needed methods in an apply { ... } block could be enough to use Kotlin instead of xml for your user interfaces, but Splitties Views DSL allows something more readable , more concise, and with a few features, like themes, styles, and seamless AppCompat support, without the boilerplate . Creating and configuring views \u00b6 The most generic way: view \u00b6 The view extension functions are a primitive of Splitties Views DSL. They are generic, so they allow you to instantiate a View of any type. There are 6 functions named view , because there\u2019s 2 overload types , and they are made available for 3 receiver types: Ui , View and Context . One of this overload type is an internal API (more info below). With respect to efficiency, they are all inline . That means no unnecessary allocation that would slightly decrease performance otherwise. Both overloads allow the following 3 optional parameters: * @IdRes id: Int , the id of the View. Example argument: R.id.input_name , given you declared it in xml, as done in the sample * @StyleRes theme: Int , resource of a theme overlay that will be applied to the View. Example argument: R.style.AppTheme_AppBarOverlay * initView: V.() -> Unit , a lambda that is like apply for the created View. The first overload of view takes a required first parameter that is a function taking a Context , and returning a View . Since constructors are also methods in Kotlin, you can directly use a method reference like so: view(::View) . The same goes for any other View subclass (e.g. view(::FrameLayout) ). You can also use a lambda instead: view({ FrameLayout(it) }) . In fact, that\u2019s how you should do it while autocomplete for method references is not optimal, then use the IDE quick action ( alt / \u2325 option + \u23ce enter ) to convert it to method reference. You can of course use any custom method reference that is not a reference to a constructor as long as that method takes a Context parameter and returns a View or any subclass of it. Here\u2019s a simple but typical example: val myView : MyCustomView = view ( :: MyCustomView , R . id . my_view ) { backgroundColor = Color . BLACK } The second overload of view , which is an internal API takes no required parameter, but relies on explicit (reified) type parameter to work properly. Just view<TextView>() is enough to instantiate a TextView . However, this version relies on a \u201cview factory\u201d that can automatically provide subclasses of the requested type as necessary. If you use the Views DSL AppCompat, you\u2019ll automatically receive instances of AppCompatButton with view<Button> thanks to the underlying View factory. Here\u2019s a simple example of this second overload: val submitBtn = view < Button >( R . id . btn_submit ) { // You should use `button { \u2026 }` instead though. textResource = R . string . submit } The most simple and readable way: plain functions \u00b6 Instead of using view<Button> { \u2026 } or view(::Button) { \u2026 } to create a Button instance (which uses an internal API), you can use button(\u2026) { \u2026 } . The parameters are exactly the same as the view function. Such methods exist for most View s and ViewGroup s included in Android, and there\u2019s more in the additional modules . You can see implementations for Android\u2019s Views and ViewGroups . These methods are a bit more natural to read and to write, but they are really just inline aliases, purely syntactic sugar. You can define your own if you want. Just make sure to write it first for Context and add two overloads for View and Ui that delegate to the one for Context . Also, remember to make them inline to avoid lambda allocation. Using styles defined in xml \u00b6 There are some times where you need to use an xml defined style, such as when using a style defined in AppCompat like Widget_AppCompat_Button_Colored . Splitties makes it really easy to use xml styles defined in Android, AppCompat and Material Components. It also gives you the ability to do the same for custom or third-party styles defined in xml. Using Android styles \u00b6 Let\u2019s say you want to create a horizontal ProgressBar instance. First, cache an instance of AndroidStyles : private val androidStyles = AndroidStyles ( ctx ) Then, use the function defined on the progressBar property: val progressbar = androidStyles . progressBar . horizontal () Other styles defined in the Android platform are provided in AndroidStyles . Just let auto-completion guide you. Note that you have exactly the same optional parameters as view , including the optional lambda. Using Material Components styles \u00b6 Since Material Components styles are not included by default inside the theme, you need to load them first. This is simply done with the following code: private val materialStyles = MaterialComponentsStyles ( ctx ) You can then use styles using the MaterialComponentsStyles instance. Here\u2019s an example: val bePoliteBtn = materialStyles . button . outlined { textResource = R . string . be_polite } Using AppCompat styles \u00b6 Since AppCompat styles are not included by default inside the theme, you need to load them first. This is simply done with the following code: private val appCompatStyles = AppCompatStyles ( ctx ) You can then use styles using the AppCompatStyles instance. Here\u2019s an example: val bePoliteBtn = appCompatStyles . button . colored { textResource = R . string . be_rude } Using any other xml style \u00b6 The colored , horizontal and other properties you can find in the AndroidStyles and the AppCompatStyles have the XmlStyle type. It is easy to instantiate it and support any xml style after the style is loaded into the current theme, but before we see how it\u2019s done, let\u2019s see what is this type. The XmlStyle inline class has: * A type parameter, for the target View type. * A single Int value, a theme attribute ( @AttrRes , not @StyleRes ). As you can see, its constructor doesn\u2019t expect a style resource (e.g. R.style.Widget_AppCompat_ActionButton ), but a theme attribute resource (e.g. R.attr.Widget_AppCompat_ActionButton ). This is because of a limitation in Android where you can programmatically only use xml styles that are inside a theme. That doesn\u2019t mean that you will have to pollute all the themes you\u2019re using with styles definitions though. Android allows you to combine multiple themes with the applyStyle(\u2026) method that you can call on any theme , which any Context has. That way, you can apply a theme that already includes references the xml styles you need with only one line of code. This is what the AppCompatStyles(ctx) function mentioned does under the hood. Here\u2019s a short example: ctx . theme . applyStyle ( R . style . ThirdPartyStyles , false ) val clapButton = XmlStyle < Button >( R . attr . Widget_ThirdParty_FancyButton )( ctx ) { imageResource = R . drawable . ic_clap_white_24dp } The first line makes sure the theme associated to the Context named ctx can resolve all the style attributes defined into R.style.ThirdPartyStyles , such as R.attr.Widget_ThirdParty_FancyButton . To make this work, you have to do the following: 1. Declare ThirdPartyStyles in xml (usually in a file named styles.xml ) 2. Declare the Widget_ThirdParty_FancyButton attribute (usually in a file named attrs.xml ) 3. Declare Widget_ThirdParty_FancyButton into ThirdPartyStyles and make sure it references the style target resource (named Widget_ThirdParty_FancyButton too). Using the same name for the target style and the attribute is a recommendation (for clarity), but not a requirement. After this is done, you can make a class to group related styles, as done in the Views DSL AppCompat split , so you get type inference, and a nicer syntax. View extensions \u00b6 For even more expressive UI code, Splitties Views DSL has a transitive dependency on the Views split that provides a useful set of Kotlin-friendly extension functions and properties dedicated to View s and some of their subclasses. Inflating existing xml layouts \u00b6 Splitties Views DSL works well with xml layouts too! The inflate extension functions is a variant to the view function mentioned earlier in this guide which has an additional first parameter: the layout resource id you want to inflate. Also, if the xml layout defines an id for the root view, it will be kept, unless you specified an explicit id (including View.NO_ID ). Just like view , inflate is defined for Context , View and Ui . Here\u2019s a short example: val mySecretFancyView = inflate ( R . layout . my_fancy_layout ) { isVisible = false } Laying out the views \u00b6 ViewGroup.add(\u2026) , an alias to ViewGroup.addView(\u2026) \u00b6 To add a View to a ViewGroup in code, you can use View.addView(\u2026) . However, this can become quite redundant to have View repeated over and over when it\u2019s already obvious that you are in a UI centric class that passes a parameter that is clearly a View . That\u2019s why this split has an inline alias to it named just add(\u2026) for ViewGroup . It has the extra benefit of returning the passed View , which can be handy in some situations. The ViewGroup.add(\u2026) function requires an instance of ViewGroup.LayoutParams , see how Splitties helps instantiating it with minimal, yet explicit code. The add function also has 2 overloads that take either a beforeChild or an afterChild argument, handy when the order of Views matters or when adding views dynamically. ViewGroups extension functions to instantiate LayoutParams \u00b6 Splitties provides several methods named lParams(\u2026) { \u2026 } for the 2 Android\u2019s built-in ViewGroup s: LinearLayout and FrameLayout . You can find support for additional ViewGroup s in the additional modules . These methods make it easy to instantiate LayoutParams with typesafe and readable code (unlike xml). Here\u2019s the contract that every lParams or alike function must respect: 1. The receiver is the type of the target ViewGroup subclass. 2. The function returns the LayoutParams for the target ViewGroup . 3. The first parameter is width and defaults to wrapContent , unless otherwise noted. 4. The second parameter is height and defaults to the same value as width , unless otherwise noted. 5. The width or height parameters may be missing in case they shall always have the same value for this target ViewGroup or for this function. 5. There may be additional parameters, with default values if possible. 6. The last parameter is a lambda with LayoutParams as a receiver and is executed exactly once, last (i.e. after any logic that the lParams implementation may have). 7. If the lParams function targets a ViewGroup that has a superclass that also has its own LayoutParams , and its own lParams function, it should be named defaultLParams instead to prevent any overload resolution ambiguity. A great example is AppBarLayout that is a child class of LinearLayout and has such extension functions for LayoutParams . 8. In case the function is specialized for non default use case (e.g. adding an AppBarLayout into a CoordinatorLayout ), it can have a custom name, but should always end with LParams (e.g. appBarLParams ). WARNING regarding lParams and defaultLParams usage: \u00b6 lParams and similar functions are resolved based on the type of their receiver. However, unless you prepend lParams or defaultLParams call with this. , the received is picked implicitly, and can be indirect, possibly causing the wrong lParams method to be used. Here\u2019s a short, example : You\u2019re in a FrameLayout (because you\u2019re writing a subclass of it, or because of a lambda receiver, like inside frameLayout { \u2026 } ). You call constraintLayout { \u2026 } and start adding views inside it, but when you call lParams , you may use the implementation for FrameLayout , and wonder why the ConstraintLayout.LayoutParams properties and extensions are not available. To highlight such errors, you can prepend this. to your suspicious lParams calls, and if they are in red, then you used the wrong one for the ViewGroup you\u2019re in. The IDE should quickly fix it, adding the proper import at this point. After this is done, you can then safely remove the this. prefix. To avoid this issue, you can be alert when you\u2019re typing/auto-completing lParams and defaultLParams and make sure that you\u2019re selecting the extension for the type of the ViewGroup you\u2019re in (direct parent of the child View you are adding). Other extensions for ViewGroup \u00b6 wrapContent and matchParent inline extensions properties on ViewGroup are convenience aliases to ViewGroup.LayoutParams.WRAP_CONTENT and ViewGroup.LayoutParams.MATCH_PARENT . horizontalMargin , verticalMargin and margin for convenient margins definition in layout parameters ( ViewGroup.MarginLayoutParams which is the base of nearly all LayoutParams). startMargin and endMargin which are compatible below API 17 (using LTR) and fix the inconsistent name ordering ( leftMargin , but marginStart ?). The interface for user interfaces, named Ui \u00b6 This section doesn\u2019t just writes so many words about how the Ui interface has only 2 properties . It explains why it is useful , how to use it the right way , and the possibilities it offers. FYI, the declaration of this interface looks like this: interface Ui { val ctx : Context val root : View } Why this interface \u00b6 As said above, you can put your UI code directly in an Activity or a Fragment , but the fact you can doesn\u2019t mean you should. Mixing UI code with business logic, data storage code, network calls and miscellaneous boilerplate in the same \u201cgod\u201d class will quickly make further work (like feature additions and maintenance) very hard, because you\u2019re likely not a god programmer, and even if you are, your coworkers, or successors, are likely not. Xml layouts alleviate this issue by forcing you to put most of your UI code into a separate xml file, but you often need complementary code (e.g. to handle transitions, dynamic visibility), and this is often put into a Fragment or an Activity , which makes things worse, as you now have your UI code spread over at least two places that are tightly coupled. What it is made of \u00b6 With Splitties Views DSL, there\u2019s an optional interface named Ui , whose implementations are meant to contain your UI code. It has a ctx property because in Android, a Context is needed to create a View . It has a root property because you need a View to display in the end. Since you\u2019re using Kotlin code, you can put all the UI related logic in it too, in a single place this time. Also, since Ui is an interface, you can get creative by creating sub-interfaces or sub-classes to have different implementations of the same UI, which is nice for A/B testing, user preferences (different styles that the user can pick), configuration (like screen orientation), and more. Implementing the Ui interface \u00b6 When writing a Ui implementation, override the ctx property as the first constructor parameter (e.g. class MainUi(override val ctx: Context) : Ui { ), and override the root parameter as a property with a backing field by assigning it a View (e.g. override val root = coordinatorLayout { ... } ). Then create your views (usually putting them as final properties, like root ), and add them to the ViewGroup s they belong to, so they are direct, or indirect children of root (in the likely case where you have multiple views in your UI and root is therefore a ViewGroup ). Using Ui implementations \u00b6 To use a Ui implementation from an Activity subclass, just call setContentView(ui) . To use it from any other place, just get the root property. In a Fragment subclass, that will mean returning it from onCreateView(\u2026) . You can also use any function or property you\u2019ve declared in your sub-interface or implementation. Here are two examples: * Using a public property of type Button to set it an OnClickListener in the place where the Ui is used (like an Activity or a Fragment that connects your UI to a ViewModel and any other components). * Call a method called animateGoalReached() . Simple examples \u00b6 See concrete examples in MainUi and DemoUi with their respective Activities MainActivity and DemoActivity . Possibilities brought by the Ui interface \u00b6 IDE Preview \u00b6 With the UiPreView class, you can preview your Ui implementations right from the IDE, (requires Android Studio 4.0 or newer). You can do it in code and have access to it contextually by selecting the \u201cSplit\u201d or \u201cDesign\u201d view in the top right corner of the editor, or you can do it in xml and benefit from options not yet available in View subclasses preview such as configuration switching (night mode, locale, etc). While the real app might show actual data, you\u2019ll likely want to show sample data in the IDE preview. To support this use case in the best way possible such as there\u2019s no impact on the production code, Splitties brings the isInPreview inline extension property for Ui and View . When your app is compiled in release mode, it evaluates to false as a constant value (unlike View.isInEditmode ), which means that any code path under this condition will be removed by the compiler (kotlinc), and R8 or proguard will then remove any extra code that was only used in the IDE preview. IDE Preview Example \u00b6 Below is a preview example in Kotlin that the IDE can display. //region IDE preview @Deprecated ( \"For IDE preview only\" , level = DeprecationLevel . HIDDEN ) private class MainUiImplPreview ( context : Context , attrs : AttributeSet ? = null , defStyleAttr : Int = 0 ) : UiPreView ( context = context . withTheme ( R . style . AppTheme ), attrs = attrs , defStyleAttr = defStyleAttr , createUi = { MainUiImpl ( it ) } ) //endregion It is surrounded by a \u201cregion\u201d so it can be collapsed by the IDE as you can see in the screenshot just below. Below is a preview xml layout example that the IDE can display. It assumes there\u2019s a class implementing Ui named MainUi in the main subpackage (relative to the app/library package name). Beware that for the xml approach, any refactoring changes will not be reflected in the xml file, so if you change the package or the name of your Ui implementation class, you\u2019ll have to remember to edit the xml preview too to keep it working. <splitties.views.dsl.idepreview.UiPreView xmlns:android= \"http://schemas.android.com/apk/res/android\" xmlns:app= \"http://schemas.android.com/apk/res-auto\" android:layout_width= \"match_parent\" android:layout_height= \"match_parent\" app:splitties_class_package_name_relative= \"main.MainUi\" /> Here\u2019s a screenshot of how it looks like with DemoUi from the sample after the mergeDebugJavaResource gradle task has been run: Important info regarding xml based IDE Preview \u00b6 Interfaces parameters \u00b6 In order for the xml preview to work, your Ui subclass need to have its first parameter of type Context . For the subsequent parameters (if applicable), any interface is supported, but its methods need to not be called when this view is created and drawn, or an exception will be thrown. A special support has been added for CoroutineContext and CoroutineScope , so there\u2019s no exception thrown if you use an actor or other code relying on coroutines at init or drawing time. Known issues and their workaround \u00b6 If preview doesn\u2019t work or doesn\u2019t reflect latest changes, it\u2019s likely because you didn\u2019t execute the mergeDebugJavaResource gradle task on your project (module actually). IDE preview currently only works with compiled classes and xml layouts. Running the mergeDebugJavaResource gradle task will save you time as it doesn\u2019t involve all the subsequent tasks that package a full apk. Finding a suitable constructor to instantiate your UI \u00b6 UiPreView is compatible with Ui implementations with two kind of constructors: * Constructors with a single Context parameter. * Constructors whose first parameter is a Context and other parameters are interfaces. Note that the interface methods need to not be called during preview, or an UnsupportedOperationException will be raised because UiPreView can only create stub implementations. You can use View.isInEditMode to skip code for preview if really needed. Finding the class \u00b6 When using the splitties_class_package_name_relative attribute, the UiPreView class will take the packageName returned from the Context and append a dot plus the value of the attribute to get the class name of your Ui implementation. However, you may have configured your build so your debug buildType has an applicationId suffix that is usually .debug like show in the example below: buildTypes { debug { applicationIdSuffix \".debug\" // This changes the packageName returned from a Context versionNameSuffix \"-DEBUG\" } release { // Config of your release build } } That\u2019s why by default, the UiPreView class will drop any .debug suffix found in the package name before trying to instantiate the class. If you use another suffix, or have other suffixes for other debuggable buildTypes, or use productFlavors, you\u2019re in luck! The package name suffix to drop is configurable from your resources. Just copy paste the string resource below in your project in a value resource file named something like config.xml or do_not_translate.xml , and edit it to the suffix you use: <string name= \"splitties_views_dsl_ide_preview_package_name_suffix\" translatable= \"false\" > .debug </string> This will override the default value from the library. You can also override the splitties_ui_preview_base_package_names string array resource and add all the base package names where you have implementations of the Ui interface you want to preview. You can see such an example in the sample here . This can be handy if you change the applicationId , or if you have a modularized codebase. Alternatively, you can use the splitties_class_fully_qualified_name attribute instead and specify the full class name with its package. Modular user interface contracts \u00b6 While having a dedicated class for user interface, that is agnostic from where it will be used (Activity, Fragment, IDE Preview\u2026), is a great first step to a modular user interface code, you can go further. Instead of exposing your Ui implementation directly to the Activity or Fragment, you can decide to write several interfaces that define a contract that your Activity, Fragment, ViewModel (beware of leaks), or whatever will need, and implement all of these with one or more classes. For example, let\u2019s say you are developing an email app. You write two interfaces: InboxUi and ComposeUi that both extend the Ui interface. You add to the interfaces all the functions (including any suspend fun ), properties and other symbols you may need to expose to the Activity, Fragment, ViewModel or whatever. Then you implement these two interfaces, with either one class or two, depending on whether you want to display them separately or not. Easier multi form factors support \u00b6 Modular UI contracts open the door to a great benefit: an easier way to support multiple form factors (smartphones, smartwatches, tablets, laptops, cars\u2026). In the previous example, we highlighted the fact that you could have multiple interfaces that expose the needed symbols, and then decide to implement these interfaces in one, or multiple classes. This can help you support different form factors with zero, or only a few changes in non-UI code as it is no longer relies on a specific implementation. It is planned to add such examples in the samples of this repository. If you want to have them faster, please open an issue so the examples can be discussed. Also, maybe you, or someone you know, can contribute. Multiplatform user interface contracts \u00b6 Here\u2019s an example of how you may write multiplatform user interface contracts: In Kotlin common code, you would write an interface that is platform agnostic but declares the needed symbols that all platforms can share: Continuing our email app example, you would write these two interfaces: interface InboxUiContract { // Whatever you need } interface ComposeUiContract { // Whatever you need } Then write to sub-interfaces for each platform you want to support, Android and iOS in this example: interface AndroidInboxUi : InboxUiContract , Ui interface IOSInboxUi : InboxUiContract { val root : UIView } And you may finally implement them for each platform, still supporting multiple form-factors and platform variants if needed. The two common interfaces ( InboxUiContract and ComposeUiContract ) could be replaced by abstract classes in case you need to have backing fields, final declarations or final implementations, as long as they don\u2019t reference Splitties Ui interface and no platform specific code. Testing \u00b6 Having your user interface as an interface can make it easy to mock it, and simulate user interactions for testing purposes. Redesign \u00b6 If you expect an interface for the user interface, then it becomes easy to replace an implementation by another one in case you\u2019re redesigning your app. You can also split your UI contracts (the interface s) into smaller subsets before starting a redesign if needed, this can be helpful if you want to move some UI controls to another area of the application, or just organize things differently. A/B Testing \u00b6 When you have multiple UI interface s implementations, you can then swap them at runtime for A/B testing, allowing you to test which UI works the best for what you determined. Additional modules \u00b6 There are additional splits for extended support. Views DSL\u2026 * AppCompat provides proper styling to Button , TextView , EditText and other widgets. views like coloredFlatButton . * ConstraintLayout provides support for ConstraintLayout.LayoutParams . ViewGroup s and bottom sheets. * IDE preview provides the ability to preview your user interfaces right from the IDE. * Material provides extensions for Material Components * RecyclerView provides extensions to have scrollbars and proper itemView layout parameters. Download \u00b6 implementation ( \"com.louiscad.splitties:splitties-views-dsl:3.0.0-beta01\" )","title":"views-dsl"},{"location":"3/views-dsl/#views-dsl","text":"Create UIs with readable Kotlin code. Supported platforms: Android . There\u2019s a whole document about Views DSL vs xml layouts if you are not convinced yet. TL;DR: Kotlin code is more concise than xml, and a small library like this one is the proof of what is already possible with this great language. Splitties Views DSL has been designed to be: * Simple * Concise * Expressive * Explicit * Efficient * Reliable * Flexible That\u2019s 7 key considerations, which we believe are all necessary to make a great library.","title":"Views DSL"},{"location":"3/views-dsl/#introduction","text":"As said above, Splitties Views DSL has been designed to be simple . Consequently, you\u2019ll find no class in this split (API-wise, as strictly speaking, all functions and properties, even top-level ones and extensions belong to a class in the bytecode). That means you won\u2019t have to learn a whole new API to use Splitties Views DSL. You\u2019ll just have to discover the extension functions and properties as you need them to craft your Android user interfaces with Kotlin code. It turns out that you just need a few extension functions and properties to make UI-related code at least as readable as xml counterparts. Note that while putting all of your UI code directly in an Activity or a Fragment is possible with Splitties Views DSL (and can surely help for throwaway prototyping), we will be recommending a cleaner, yet simple approach (spoiler: a custom class). Before we dive into the details of the API, let\u2019s take a look at a simple example: val launchDemoBtn = button { textResource = R . string . go_to_the_demo } This example was meaningless , because no one ever publishes an app with only one button. Also, the snippet above just creates a button. If you want it into a ViewGroup , or as the content of an Activity or a Fragment , you need to do so explicitly. There are real examples in the sample . You can start by taking a look at MainUi . You can also see a simple example that uses ConstraintLayout in AboutUi . Opening the project in your IDE and navigating the sample UI code while reading this documentation may certainly help you have a hands-on experience and be comfortable more quickly writing UIs with Kotlin, a programming language that is probably already familiar to you.","title":"Introduction"},{"location":"3/views-dsl/#table-of-contents","text":"The extensions Creating and configuring views The most generic way: view Using styles defined in xml Using Android styles Using AppCompat styles Using any other xml style The most simple and readable way: plain functions View extensions Inflating existing xml layouts Laying out the views ViewGroup.add(\u2026) , an alias to ViewGroup.addView(\u2026) ViewGroups extension functions to instantiate LayoutParams WARNING regarding lParams and defaultLParams usage Other extensions for ViewGroup The interface for user interfaces, named Ui Why this interface What it is made of Implementing the interface Using Ui implementations Simple examples Possibilities brought by the Ui interface IDE Preview IDE Preview Example Important info regarding xml based IDE Preview Interfaces parameters Known issues and their workaround Finding a suitable constructor to instantiate your UI Finding the class Modular user interface contracts Easier multi form factors support Multiplatform user interface contracts Testing Redesign A/B Testing Additional modules Download","title":"Table of contents"},{"location":"3/views-dsl/#the-extensions","text":"Splitties is primarily made of extension functions and properties, to create views with minimal code but maximum flexibility. Just calling the constructor, then calling needed methods in an apply { ... } block could be enough to use Kotlin instead of xml for your user interfaces, but Splitties Views DSL allows something more readable , more concise, and with a few features, like themes, styles, and seamless AppCompat support, without the boilerplate .","title":"The extensions"},{"location":"3/views-dsl/#creating-and-configuring-views","text":"","title":"Creating and configuring views"},{"location":"3/views-dsl/#the-most-generic-way-view","text":"The view extension functions are a primitive of Splitties Views DSL. They are generic, so they allow you to instantiate a View of any type. There are 6 functions named view , because there\u2019s 2 overload types , and they are made available for 3 receiver types: Ui , View and Context . One of this overload type is an internal API (more info below). With respect to efficiency, they are all inline . That means no unnecessary allocation that would slightly decrease performance otherwise. Both overloads allow the following 3 optional parameters: * @IdRes id: Int , the id of the View. Example argument: R.id.input_name , given you declared it in xml, as done in the sample * @StyleRes theme: Int , resource of a theme overlay that will be applied to the View. Example argument: R.style.AppTheme_AppBarOverlay * initView: V.() -> Unit , a lambda that is like apply for the created View. The first overload of view takes a required first parameter that is a function taking a Context , and returning a View . Since constructors are also methods in Kotlin, you can directly use a method reference like so: view(::View) . The same goes for any other View subclass (e.g. view(::FrameLayout) ). You can also use a lambda instead: view({ FrameLayout(it) }) . In fact, that\u2019s how you should do it while autocomplete for method references is not optimal, then use the IDE quick action ( alt / \u2325 option + \u23ce enter ) to convert it to method reference. You can of course use any custom method reference that is not a reference to a constructor as long as that method takes a Context parameter and returns a View or any subclass of it. Here\u2019s a simple but typical example: val myView : MyCustomView = view ( :: MyCustomView , R . id . my_view ) { backgroundColor = Color . BLACK } The second overload of view , which is an internal API takes no required parameter, but relies on explicit (reified) type parameter to work properly. Just view<TextView>() is enough to instantiate a TextView . However, this version relies on a \u201cview factory\u201d that can automatically provide subclasses of the requested type as necessary. If you use the Views DSL AppCompat, you\u2019ll automatically receive instances of AppCompatButton with view<Button> thanks to the underlying View factory. Here\u2019s a simple example of this second overload: val submitBtn = view < Button >( R . id . btn_submit ) { // You should use `button { \u2026 }` instead though. textResource = R . string . submit }","title":"The most generic way: view"},{"location":"3/views-dsl/#the-most-simple-and-readable-way-plain-functions","text":"Instead of using view<Button> { \u2026 } or view(::Button) { \u2026 } to create a Button instance (which uses an internal API), you can use button(\u2026) { \u2026 } . The parameters are exactly the same as the view function. Such methods exist for most View s and ViewGroup s included in Android, and there\u2019s more in the additional modules . You can see implementations for Android\u2019s Views and ViewGroups . These methods are a bit more natural to read and to write, but they are really just inline aliases, purely syntactic sugar. You can define your own if you want. Just make sure to write it first for Context and add two overloads for View and Ui that delegate to the one for Context . Also, remember to make them inline to avoid lambda allocation.","title":"The most simple and readable way: plain functions"},{"location":"3/views-dsl/#using-styles-defined-in-xml","text":"There are some times where you need to use an xml defined style, such as when using a style defined in AppCompat like Widget_AppCompat_Button_Colored . Splitties makes it really easy to use xml styles defined in Android, AppCompat and Material Components. It also gives you the ability to do the same for custom or third-party styles defined in xml.","title":"Using styles defined in xml"},{"location":"3/views-dsl/#using-android-styles","text":"Let\u2019s say you want to create a horizontal ProgressBar instance. First, cache an instance of AndroidStyles : private val androidStyles = AndroidStyles ( ctx ) Then, use the function defined on the progressBar property: val progressbar = androidStyles . progressBar . horizontal () Other styles defined in the Android platform are provided in AndroidStyles . Just let auto-completion guide you. Note that you have exactly the same optional parameters as view , including the optional lambda.","title":"Using Android styles"},{"location":"3/views-dsl/#using-material-components-styles","text":"Since Material Components styles are not included by default inside the theme, you need to load them first. This is simply done with the following code: private val materialStyles = MaterialComponentsStyles ( ctx ) You can then use styles using the MaterialComponentsStyles instance. Here\u2019s an example: val bePoliteBtn = materialStyles . button . outlined { textResource = R . string . be_polite }","title":"Using Material Components styles"},{"location":"3/views-dsl/#using-appcompat-styles","text":"Since AppCompat styles are not included by default inside the theme, you need to load them first. This is simply done with the following code: private val appCompatStyles = AppCompatStyles ( ctx ) You can then use styles using the AppCompatStyles instance. Here\u2019s an example: val bePoliteBtn = appCompatStyles . button . colored { textResource = R . string . be_rude }","title":"Using AppCompat styles"},{"location":"3/views-dsl/#using-any-other-xml-style","text":"The colored , horizontal and other properties you can find in the AndroidStyles and the AppCompatStyles have the XmlStyle type. It is easy to instantiate it and support any xml style after the style is loaded into the current theme, but before we see how it\u2019s done, let\u2019s see what is this type. The XmlStyle inline class has: * A type parameter, for the target View type. * A single Int value, a theme attribute ( @AttrRes , not @StyleRes ). As you can see, its constructor doesn\u2019t expect a style resource (e.g. R.style.Widget_AppCompat_ActionButton ), but a theme attribute resource (e.g. R.attr.Widget_AppCompat_ActionButton ). This is because of a limitation in Android where you can programmatically only use xml styles that are inside a theme. That doesn\u2019t mean that you will have to pollute all the themes you\u2019re using with styles definitions though. Android allows you to combine multiple themes with the applyStyle(\u2026) method that you can call on any theme , which any Context has. That way, you can apply a theme that already includes references the xml styles you need with only one line of code. This is what the AppCompatStyles(ctx) function mentioned does under the hood. Here\u2019s a short example: ctx . theme . applyStyle ( R . style . ThirdPartyStyles , false ) val clapButton = XmlStyle < Button >( R . attr . Widget_ThirdParty_FancyButton )( ctx ) { imageResource = R . drawable . ic_clap_white_24dp } The first line makes sure the theme associated to the Context named ctx can resolve all the style attributes defined into R.style.ThirdPartyStyles , such as R.attr.Widget_ThirdParty_FancyButton . To make this work, you have to do the following: 1. Declare ThirdPartyStyles in xml (usually in a file named styles.xml ) 2. Declare the Widget_ThirdParty_FancyButton attribute (usually in a file named attrs.xml ) 3. Declare Widget_ThirdParty_FancyButton into ThirdPartyStyles and make sure it references the style target resource (named Widget_ThirdParty_FancyButton too). Using the same name for the target style and the attribute is a recommendation (for clarity), but not a requirement. After this is done, you can make a class to group related styles, as done in the Views DSL AppCompat split , so you get type inference, and a nicer syntax.","title":"Using any other xml style"},{"location":"3/views-dsl/#view-extensions","text":"For even more expressive UI code, Splitties Views DSL has a transitive dependency on the Views split that provides a useful set of Kotlin-friendly extension functions and properties dedicated to View s and some of their subclasses.","title":"View extensions"},{"location":"3/views-dsl/#inflating-existing-xml-layouts","text":"Splitties Views DSL works well with xml layouts too! The inflate extension functions is a variant to the view function mentioned earlier in this guide which has an additional first parameter: the layout resource id you want to inflate. Also, if the xml layout defines an id for the root view, it will be kept, unless you specified an explicit id (including View.NO_ID ). Just like view , inflate is defined for Context , View and Ui . Here\u2019s a short example: val mySecretFancyView = inflate ( R . layout . my_fancy_layout ) { isVisible = false }","title":"Inflating existing xml layouts"},{"location":"3/views-dsl/#laying-out-the-views","text":"","title":"Laying out the views"},{"location":"3/views-dsl/#viewgroupadd-an-alias-to-viewgroupaddview","text":"To add a View to a ViewGroup in code, you can use View.addView(\u2026) . However, this can become quite redundant to have View repeated over and over when it\u2019s already obvious that you are in a UI centric class that passes a parameter that is clearly a View . That\u2019s why this split has an inline alias to it named just add(\u2026) for ViewGroup . It has the extra benefit of returning the passed View , which can be handy in some situations. The ViewGroup.add(\u2026) function requires an instance of ViewGroup.LayoutParams , see how Splitties helps instantiating it with minimal, yet explicit code. The add function also has 2 overloads that take either a beforeChild or an afterChild argument, handy when the order of Views matters or when adding views dynamically.","title":"ViewGroup.add(\u2026), an alias to ViewGroup.addView(\u2026)"},{"location":"3/views-dsl/#viewgroups-extension-functions-to-instantiate-layoutparams","text":"Splitties provides several methods named lParams(\u2026) { \u2026 } for the 2 Android\u2019s built-in ViewGroup s: LinearLayout and FrameLayout . You can find support for additional ViewGroup s in the additional modules . These methods make it easy to instantiate LayoutParams with typesafe and readable code (unlike xml). Here\u2019s the contract that every lParams or alike function must respect: 1. The receiver is the type of the target ViewGroup subclass. 2. The function returns the LayoutParams for the target ViewGroup . 3. The first parameter is width and defaults to wrapContent , unless otherwise noted. 4. The second parameter is height and defaults to the same value as width , unless otherwise noted. 5. The width or height parameters may be missing in case they shall always have the same value for this target ViewGroup or for this function. 5. There may be additional parameters, with default values if possible. 6. The last parameter is a lambda with LayoutParams as a receiver and is executed exactly once, last (i.e. after any logic that the lParams implementation may have). 7. If the lParams function targets a ViewGroup that has a superclass that also has its own LayoutParams , and its own lParams function, it should be named defaultLParams instead to prevent any overload resolution ambiguity. A great example is AppBarLayout that is a child class of LinearLayout and has such extension functions for LayoutParams . 8. In case the function is specialized for non default use case (e.g. adding an AppBarLayout into a CoordinatorLayout ), it can have a custom name, but should always end with LParams (e.g. appBarLParams ).","title":"ViewGroups extension functions to instantiate LayoutParams"},{"location":"3/views-dsl/#warning-regarding-lparams-and-defaultlparams-usage","text":"lParams and similar functions are resolved based on the type of their receiver. However, unless you prepend lParams or defaultLParams call with this. , the received is picked implicitly, and can be indirect, possibly causing the wrong lParams method to be used. Here\u2019s a short, example : You\u2019re in a FrameLayout (because you\u2019re writing a subclass of it, or because of a lambda receiver, like inside frameLayout { \u2026 } ). You call constraintLayout { \u2026 } and start adding views inside it, but when you call lParams , you may use the implementation for FrameLayout , and wonder why the ConstraintLayout.LayoutParams properties and extensions are not available. To highlight such errors, you can prepend this. to your suspicious lParams calls, and if they are in red, then you used the wrong one for the ViewGroup you\u2019re in. The IDE should quickly fix it, adding the proper import at this point. After this is done, you can then safely remove the this. prefix. To avoid this issue, you can be alert when you\u2019re typing/auto-completing lParams and defaultLParams and make sure that you\u2019re selecting the extension for the type of the ViewGroup you\u2019re in (direct parent of the child View you are adding).","title":"WARNING regarding lParams and defaultLParams usage:"},{"location":"3/views-dsl/#other-extensions-for-viewgroup","text":"wrapContent and matchParent inline extensions properties on ViewGroup are convenience aliases to ViewGroup.LayoutParams.WRAP_CONTENT and ViewGroup.LayoutParams.MATCH_PARENT . horizontalMargin , verticalMargin and margin for convenient margins definition in layout parameters ( ViewGroup.MarginLayoutParams which is the base of nearly all LayoutParams). startMargin and endMargin which are compatible below API 17 (using LTR) and fix the inconsistent name ordering ( leftMargin , but marginStart ?).","title":"Other extensions for ViewGroup"},{"location":"3/views-dsl/#the-interface-for-user-interfaces-named-ui","text":"This section doesn\u2019t just writes so many words about how the Ui interface has only 2 properties . It explains why it is useful , how to use it the right way , and the possibilities it offers. FYI, the declaration of this interface looks like this: interface Ui { val ctx : Context val root : View }","title":"The interface for user interfaces, named Ui"},{"location":"3/views-dsl/#why-this-interface","text":"As said above, you can put your UI code directly in an Activity or a Fragment , but the fact you can doesn\u2019t mean you should. Mixing UI code with business logic, data storage code, network calls and miscellaneous boilerplate in the same \u201cgod\u201d class will quickly make further work (like feature additions and maintenance) very hard, because you\u2019re likely not a god programmer, and even if you are, your coworkers, or successors, are likely not. Xml layouts alleviate this issue by forcing you to put most of your UI code into a separate xml file, but you often need complementary code (e.g. to handle transitions, dynamic visibility), and this is often put into a Fragment or an Activity , which makes things worse, as you now have your UI code spread over at least two places that are tightly coupled.","title":"Why this interface"},{"location":"3/views-dsl/#what-it-is-made-of","text":"With Splitties Views DSL, there\u2019s an optional interface named Ui , whose implementations are meant to contain your UI code. It has a ctx property because in Android, a Context is needed to create a View . It has a root property because you need a View to display in the end. Since you\u2019re using Kotlin code, you can put all the UI related logic in it too, in a single place this time. Also, since Ui is an interface, you can get creative by creating sub-interfaces or sub-classes to have different implementations of the same UI, which is nice for A/B testing, user preferences (different styles that the user can pick), configuration (like screen orientation), and more.","title":"What it is made of"},{"location":"3/views-dsl/#implementing-the-ui-interface","text":"When writing a Ui implementation, override the ctx property as the first constructor parameter (e.g. class MainUi(override val ctx: Context) : Ui { ), and override the root parameter as a property with a backing field by assigning it a View (e.g. override val root = coordinatorLayout { ... } ). Then create your views (usually putting them as final properties, like root ), and add them to the ViewGroup s they belong to, so they are direct, or indirect children of root (in the likely case where you have multiple views in your UI and root is therefore a ViewGroup ).","title":"Implementing the Ui interface"},{"location":"3/views-dsl/#using-ui-implementations","text":"To use a Ui implementation from an Activity subclass, just call setContentView(ui) . To use it from any other place, just get the root property. In a Fragment subclass, that will mean returning it from onCreateView(\u2026) . You can also use any function or property you\u2019ve declared in your sub-interface or implementation. Here are two examples: * Using a public property of type Button to set it an OnClickListener in the place where the Ui is used (like an Activity or a Fragment that connects your UI to a ViewModel and any other components). * Call a method called animateGoalReached() .","title":"Using Ui implementations"},{"location":"3/views-dsl/#simple-examples","text":"See concrete examples in MainUi and DemoUi with their respective Activities MainActivity and DemoActivity .","title":"Simple examples"},{"location":"3/views-dsl/#possibilities-brought-by-the-ui-interface","text":"","title":"Possibilities brought by the Ui interface"},{"location":"3/views-dsl/#ide-preview","text":"With the UiPreView class, you can preview your Ui implementations right from the IDE, (requires Android Studio 4.0 or newer). You can do it in code and have access to it contextually by selecting the \u201cSplit\u201d or \u201cDesign\u201d view in the top right corner of the editor, or you can do it in xml and benefit from options not yet available in View subclasses preview such as configuration switching (night mode, locale, etc). While the real app might show actual data, you\u2019ll likely want to show sample data in the IDE preview. To support this use case in the best way possible such as there\u2019s no impact on the production code, Splitties brings the isInPreview inline extension property for Ui and View . When your app is compiled in release mode, it evaluates to false as a constant value (unlike View.isInEditmode ), which means that any code path under this condition will be removed by the compiler (kotlinc), and R8 or proguard will then remove any extra code that was only used in the IDE preview.","title":"IDE Preview"},{"location":"3/views-dsl/#ide-preview-example","text":"Below is a preview example in Kotlin that the IDE can display. //region IDE preview @Deprecated ( \"For IDE preview only\" , level = DeprecationLevel . HIDDEN ) private class MainUiImplPreview ( context : Context , attrs : AttributeSet ? = null , defStyleAttr : Int = 0 ) : UiPreView ( context = context . withTheme ( R . style . AppTheme ), attrs = attrs , defStyleAttr = defStyleAttr , createUi = { MainUiImpl ( it ) } ) //endregion It is surrounded by a \u201cregion\u201d so it can be collapsed by the IDE as you can see in the screenshot just below. Below is a preview xml layout example that the IDE can display. It assumes there\u2019s a class implementing Ui named MainUi in the main subpackage (relative to the app/library package name). Beware that for the xml approach, any refactoring changes will not be reflected in the xml file, so if you change the package or the name of your Ui implementation class, you\u2019ll have to remember to edit the xml preview too to keep it working. <splitties.views.dsl.idepreview.UiPreView xmlns:android= \"http://schemas.android.com/apk/res/android\" xmlns:app= \"http://schemas.android.com/apk/res-auto\" android:layout_width= \"match_parent\" android:layout_height= \"match_parent\" app:splitties_class_package_name_relative= \"main.MainUi\" /> Here\u2019s a screenshot of how it looks like with DemoUi from the sample after the mergeDebugJavaResource gradle task has been run:","title":"IDE Preview Example"},{"location":"3/views-dsl/#important-info-regarding-xml-based-ide-preview","text":"","title":"Important info regarding xml based IDE Preview"},{"location":"3/views-dsl/#interfaces-parameters","text":"In order for the xml preview to work, your Ui subclass need to have its first parameter of type Context . For the subsequent parameters (if applicable), any interface is supported, but its methods need to not be called when this view is created and drawn, or an exception will be thrown. A special support has been added for CoroutineContext and CoroutineScope , so there\u2019s no exception thrown if you use an actor or other code relying on coroutines at init or drawing time.","title":"Interfaces parameters"},{"location":"3/views-dsl/#known-issues-and-their-workaround","text":"If preview doesn\u2019t work or doesn\u2019t reflect latest changes, it\u2019s likely because you didn\u2019t execute the mergeDebugJavaResource gradle task on your project (module actually). IDE preview currently only works with compiled classes and xml layouts. Running the mergeDebugJavaResource gradle task will save you time as it doesn\u2019t involve all the subsequent tasks that package a full apk.","title":"Known issues and their workaround"},{"location":"3/views-dsl/#finding-a-suitable-constructor-to-instantiate-your-ui","text":"UiPreView is compatible with Ui implementations with two kind of constructors: * Constructors with a single Context parameter. * Constructors whose first parameter is a Context and other parameters are interfaces. Note that the interface methods need to not be called during preview, or an UnsupportedOperationException will be raised because UiPreView can only create stub implementations. You can use View.isInEditMode to skip code for preview if really needed.","title":"Finding a suitable constructor to instantiate your UI"},{"location":"3/views-dsl/#finding-the-class","text":"When using the splitties_class_package_name_relative attribute, the UiPreView class will take the packageName returned from the Context and append a dot plus the value of the attribute to get the class name of your Ui implementation. However, you may have configured your build so your debug buildType has an applicationId suffix that is usually .debug like show in the example below: buildTypes { debug { applicationIdSuffix \".debug\" // This changes the packageName returned from a Context versionNameSuffix \"-DEBUG\" } release { // Config of your release build } } That\u2019s why by default, the UiPreView class will drop any .debug suffix found in the package name before trying to instantiate the class. If you use another suffix, or have other suffixes for other debuggable buildTypes, or use productFlavors, you\u2019re in luck! The package name suffix to drop is configurable from your resources. Just copy paste the string resource below in your project in a value resource file named something like config.xml or do_not_translate.xml , and edit it to the suffix you use: <string name= \"splitties_views_dsl_ide_preview_package_name_suffix\" translatable= \"false\" > .debug </string> This will override the default value from the library. You can also override the splitties_ui_preview_base_package_names string array resource and add all the base package names where you have implementations of the Ui interface you want to preview. You can see such an example in the sample here . This can be handy if you change the applicationId , or if you have a modularized codebase. Alternatively, you can use the splitties_class_fully_qualified_name attribute instead and specify the full class name with its package.","title":"Finding the class"},{"location":"3/views-dsl/#modular-user-interface-contracts","text":"While having a dedicated class for user interface, that is agnostic from where it will be used (Activity, Fragment, IDE Preview\u2026), is a great first step to a modular user interface code, you can go further. Instead of exposing your Ui implementation directly to the Activity or Fragment, you can decide to write several interfaces that define a contract that your Activity, Fragment, ViewModel (beware of leaks), or whatever will need, and implement all of these with one or more classes. For example, let\u2019s say you are developing an email app. You write two interfaces: InboxUi and ComposeUi that both extend the Ui interface. You add to the interfaces all the functions (including any suspend fun ), properties and other symbols you may need to expose to the Activity, Fragment, ViewModel or whatever. Then you implement these two interfaces, with either one class or two, depending on whether you want to display them separately or not.","title":"Modular user interface contracts"},{"location":"3/views-dsl/#easier-multi-form-factors-support","text":"Modular UI contracts open the door to a great benefit: an easier way to support multiple form factors (smartphones, smartwatches, tablets, laptops, cars\u2026). In the previous example, we highlighted the fact that you could have multiple interfaces that expose the needed symbols, and then decide to implement these interfaces in one, or multiple classes. This can help you support different form factors with zero, or only a few changes in non-UI code as it is no longer relies on a specific implementation. It is planned to add such examples in the samples of this repository. If you want to have them faster, please open an issue so the examples can be discussed. Also, maybe you, or someone you know, can contribute.","title":"Easier multi form factors support"},{"location":"3/views-dsl/#multiplatform-user-interface-contracts","text":"Here\u2019s an example of how you may write multiplatform user interface contracts: In Kotlin common code, you would write an interface that is platform agnostic but declares the needed symbols that all platforms can share: Continuing our email app example, you would write these two interfaces: interface InboxUiContract { // Whatever you need } interface ComposeUiContract { // Whatever you need } Then write to sub-interfaces for each platform you want to support, Android and iOS in this example: interface AndroidInboxUi : InboxUiContract , Ui interface IOSInboxUi : InboxUiContract { val root : UIView } And you may finally implement them for each platform, still supporting multiple form-factors and platform variants if needed. The two common interfaces ( InboxUiContract and ComposeUiContract ) could be replaced by abstract classes in case you need to have backing fields, final declarations or final implementations, as long as they don\u2019t reference Splitties Ui interface and no platform specific code.","title":"Multiplatform user interface contracts"},{"location":"3/views-dsl/#testing","text":"Having your user interface as an interface can make it easy to mock it, and simulate user interactions for testing purposes.","title":"Testing"},{"location":"3/views-dsl/#redesign","text":"If you expect an interface for the user interface, then it becomes easy to replace an implementation by another one in case you\u2019re redesigning your app. You can also split your UI contracts (the interface s) into smaller subsets before starting a redesign if needed, this can be helpful if you want to move some UI controls to another area of the application, or just organize things differently.","title":"Redesign"},{"location":"3/views-dsl/#ab-testing","text":"When you have multiple UI interface s implementations, you can then swap them at runtime for A/B testing, allowing you to test which UI works the best for what you determined.","title":"A/B Testing"},{"location":"3/views-dsl/#additional-modules","text":"There are additional splits for extended support. Views DSL\u2026 * AppCompat provides proper styling to Button , TextView , EditText and other widgets. views like coloredFlatButton . * ConstraintLayout provides support for ConstraintLayout.LayoutParams . ViewGroup s and bottom sheets. * IDE preview provides the ability to preview your user interfaces right from the IDE. * Material provides extensions for Material Components * RecyclerView provides extensions to have scrollbars and proper itemView layout parameters.","title":"Additional modules"},{"location":"3/views-dsl/#download","text":"implementation ( \"com.louiscad.splitties:splitties-views-dsl:3.0.0-beta01\" )","title":"Download"},{"location":"3/views-material/","text":"Views Material \u00b6 Material Components extension of Views . Supported platforms: Android . Content \u00b6 CollapsingToolbarLayout extensions \u00b6 contentScrimColor allows to set the content scrim color of a CollapsingToolbarLayout using property syntax. TextInputLayout extensions \u00b6 The text read/write extension property for TextInputLayout is an alias to the text property of the child EditText . The string read only extension property for TextInputLayout allows to easily get the String (immutable) representation of the text of the child EditText . Download \u00b6 implementation ( \"com.louiscad.splitties:splitties-views-material:3.0.0-beta01\" )","title":"views-material"},{"location":"3/views-material/#views-material","text":"Material Components extension of Views . Supported platforms: Android .","title":"Views Material"},{"location":"3/views-material/#content","text":"","title":"Content"},{"location":"3/views-material/#collapsingtoolbarlayout-extensions","text":"contentScrimColor allows to set the content scrim color of a CollapsingToolbarLayout using property syntax.","title":"CollapsingToolbarLayout extensions"},{"location":"3/views-material/#textinputlayout-extensions","text":"The text read/write extension property for TextInputLayout is an alias to the text property of the child EditText . The string read only extension property for TextInputLayout allows to easily get the String (immutable) representation of the text of the child EditText .","title":"TextInputLayout extensions"},{"location":"3/views-material/#download","text":"implementation ( \"com.louiscad.splitties:splitties-views-material:3.0.0-beta01\" )","title":"Download"},{"location":"3/views-recyclerview/","text":"Views RecyclerView \u00b6 Supported platforms: Android . Content \u00b6 RecyclerView extensions \u00b6 The fixedSize extension property for RecyclerView is an alias to the hasFixedSize() and setHasFixedSize(\u2026) methods. functions to create a LinearLayoutManager \u00b6 The verticalLayoutManager and horizontalLayoutManager functions allow you to instantiate and customize a LinearLayoutManager with more idiomatic Kotlin code. functions to create a GridLayoutManager \u00b6 The gridLayoutManager and horizontalGridLayoutManager functions allow you to instantiate and customize a GridLayoutManager with more idiomatic Kotlin code. Download \u00b6 implementation ( \"com.louiscad.splitties:splitties-views-recyclerview:3.0.0-beta01\" )","title":"views-recyclerview"},{"location":"3/views-recyclerview/#views-recyclerview","text":"Supported platforms: Android .","title":"Views RecyclerView"},{"location":"3/views-recyclerview/#content","text":"","title":"Content"},{"location":"3/views-recyclerview/#recyclerview-extensions","text":"The fixedSize extension property for RecyclerView is an alias to the hasFixedSize() and setHasFixedSize(\u2026) methods.","title":"RecyclerView extensions"},{"location":"3/views-recyclerview/#functions-to-create-a-linearlayoutmanager","text":"The verticalLayoutManager and horizontalLayoutManager functions allow you to instantiate and customize a LinearLayoutManager with more idiomatic Kotlin code.","title":"functions to create a LinearLayoutManager"},{"location":"3/views-recyclerview/#functions-to-create-a-gridlayoutmanager","text":"The gridLayoutManager and horizontalGridLayoutManager functions allow you to instantiate and customize a GridLayoutManager with more idiomatic Kotlin code.","title":"functions to create a GridLayoutManager"},{"location":"3/views-recyclerview/#download","text":"implementation ( \"com.louiscad.splitties:splitties-views-recyclerview:3.0.0-beta01\" )","title":"Download"},{"location":"3/views-selectable-appcompat/","text":"Selectable Views AppCompat \u00b6 Selectable Views for AppCompatTextView. Supported platforms: Android . Usage \u00b6 Just use SelectableTextView with the proper import instead of TextView or AppCompatTextView , and change the foregroundSelector Drawable if the default doesn\u2019t suit your needs. Download \u00b6 implementation ( \"com.louiscad.splitties:splitties-views-selectable-appcompat:3.0.0-beta01\" )","title":"views-selectable-appcompat"},{"location":"3/views-selectable-appcompat/#selectable-views-appcompat","text":"Selectable Views for AppCompatTextView. Supported platforms: Android .","title":"Selectable Views AppCompat"},{"location":"3/views-selectable-appcompat/#usage","text":"Just use SelectableTextView with the proper import instead of TextView or AppCompatTextView , and change the foregroundSelector Drawable if the default doesn\u2019t suit your needs.","title":"Usage"},{"location":"3/views-selectable-appcompat/#download","text":"implementation ( \"com.louiscad.splitties:splitties-views-selectable-appcompat:3.0.0-beta01\" )","title":"Download"},{"location":"3/views-selectable-constraintlayout/","text":"Selectable Views ConstraintLayout \u00b6 Selectable Views for ConstraintLayout. Supported platforms: Android . Usage \u00b6 Just use SelectableConstraintLayout with the proper import instead of ConstraintLayout , and change the foregroundSelector Drawable if the default doesn\u2019t suit your needs. Download \u00b6 implementation ( \"com.louiscad.splitties:splitties-views-selectable-constraintlayout:3.0.0-beta01\" )","title":"views-selectable-constraintlayout"},{"location":"3/views-selectable-constraintlayout/#selectable-views-constraintlayout","text":"Selectable Views for ConstraintLayout. Supported platforms: Android .","title":"Selectable Views ConstraintLayout"},{"location":"3/views-selectable-constraintlayout/#usage","text":"Just use SelectableConstraintLayout with the proper import instead of ConstraintLayout , and change the foregroundSelector Drawable if the default doesn\u2019t suit your needs.","title":"Usage"},{"location":"3/views-selectable-constraintlayout/#download","text":"implementation ( \"com.louiscad.splitties:splitties-views-selectable-constraintlayout:3.0.0-beta01\" )","title":"Download"},{"location":"3/views-selectable/","text":"Selectable Views \u00b6 Selectable Views with foreground property before API 23. Supported platforms: Android . This split provides selectable LinearLayout and platform TextView . See also the AppCompat and ConstraintLayout versions. Selectable views are particularly handy for list items that can be clicked. They have a foregroundSelector property that is like foregound property available on FrameLayout and all Views on API 23+. It defaults to android.R.attr.selectableItemBackground , showing visual feedback when the user selects the View (ripple effect on Lollipop and newer Android versions). Usage \u00b6 Just use SelectableLinearLayout and SelectableTextView instead of LinearLayout and TextView , and change the foregroundSelector Drawable if the default doesn\u2019t suit your needs. Download \u00b6 implementation ( \"com.louiscad.splitties:splitties-views-selectable:3.0.0-beta01\" )","title":"views-selectable"},{"location":"3/views-selectable/#selectable-views","text":"Selectable Views with foreground property before API 23. Supported platforms: Android . This split provides selectable LinearLayout and platform TextView . See also the AppCompat and ConstraintLayout versions. Selectable views are particularly handy for list items that can be clicked. They have a foregroundSelector property that is like foregound property available on FrameLayout and all Views on API 23+. It defaults to android.R.attr.selectableItemBackground , showing visual feedback when the user selects the View (ripple effect on Lollipop and newer Android versions).","title":"Selectable Views"},{"location":"3/views-selectable/#usage","text":"Just use SelectableLinearLayout and SelectableTextView instead of LinearLayout and TextView , and change the foregroundSelector Drawable if the default doesn\u2019t suit your needs.","title":"Usage"},{"location":"3/views-selectable/#download","text":"implementation ( \"com.louiscad.splitties:splitties-views-selectable:3.0.0-beta01\" )","title":"Download"},{"location":"3/views/","text":"Views \u00b6 Extensions function and properties on View s. Supported platforms: Android . Content \u00b6 This split includes extensions on view related classes. They are helpful when dealing with views programmatically. Depends on AndroidX core KTX \u00b6 Android core KTX already bundles its share of useful extensions for Views. For example, it includes View visibility extension properties like isVisible . To avoid duplication, Splitties deprecated symbols made redundant by Android core KTX, and included the dependency transitively instead. View background properties \u00b6 bg is an alias to the background property for View, but works below API 16, using setBackgroundDrawable(\u2026)`. backgroundColor allows to set the background color of a View using property syntax. ImageView properties \u00b6 imageResource allows to set the image of an ImageView from a resource id using property syntax. imageDrawable allows to get, set or clear the image of an ImageView with a Drawable? using property syntax. imageBitmap allows to set the image of an ImageView from a BitMap using property syntax. Layout direction properties \u00b6 isLtr extension property for View is true on API 16 and lower, or when the layout direction is left to right (like in English). isRtl is !isLtr . Would be true on an API 17+ device setup in Arabic or another RTL language, or when the device is forced to RTL in developer options. View padding properties \u00b6 The following extension properties allow to set the padding of a View using property syntax: padding horizontalPadding verticalPadding topPadding bottomPadding You can also use the setPaddingDp extension function that offers default parameter values. EditText extensions \u00b6 type allows to set the input type in a typesafe and more readable way using the InputType inline class (lots of \u201ctype\u201d occurrences in this sentence). TextView extensions \u00b6 textResource allows to set the text of a TextView from a string resource id using property syntax. textColorResource allows to set the color of the text of a TextView from a color resource id using property syntax. textAppearance allows to set the text appearance of a TextView from a text appearance style resource id using property syntax, even below API 23. lines allows to set the exact number of lines of a TextView using property syntax. centerText() sets gravity to center and center aligns the text. alignTextToStart() sets gravity to start and start aligns the text. alignTextToEnd() sets gravity to end and end aligns the text. setCompoundDrawables(\u2026) takes Drawable? parameters for start , top , end and bottom which all default to null , plus an intrinsicBounds parameter that defaults to false . setCompoundDrawables(\u2026) has an overload which takes drawable resource ids that default to 0 (no drawable) but no intrinsicBounds parameter (as it is implicitly true). clearCompoundDrawables() clears all compound drawables the TextView has. Click \u00b6 onClick { \u2026 } extension method for View avoids it shadowing if you have other lambdas, while also being more expressive than setOnClickListener { \u2026 } . onLongClick { \u2026 } is similar to onClick { \u2026 } , but also removes the need to have an extra line in the lambda to return true or false . LayoutInflater \u00b6 LayoutInflater , Context and ViewGroup have an inflate extension function that make inflating xml easy thanks to type parameter. There\u2019s also an inflateAndAttach extension function for ViewGroup . Gravity flags aliases \u00b6 Using Gravity constants on Android is a bit verbose. To alleviate this small issue, this split provides extension properties for View which start with gravity . They cover most use cases and play well with autocomplete. Example: Without Splitties : Gravity.START or Gravity.CENTER_VERTICAL With Splitties : gravityStartCenter List of supported Gravity flags: gravityCenter gravityCenterVertical gravityCenterHorizontal gravityVerticalCenter gravityHorizontalCenter gravityStart gravityTop gravityEnd gravityBottom gravityStartBottom gravityStartTop gravityEndBottom gravityEndTop gravityBottomStart (alias to gravityStartBottom) gravityTopStart (alias to gravityStartTop) gravityBottomEnd (alias to gravityEndBottom) gravityTopEnd (alias to gravityEndTop) gravityStartCenter gravityEndCenter gravityTopCenter gravityBottomCenter Other \u00b6 The generateViewId() top level function is a backwards compatible and more efficient version of View.generateViewId() that was introduced in Android API 17. The assignAndGetGeneratedId() extension function for View calls generateViewId() assigns it to the view and returns new generated id. The existingOrNewId extension property for View calls assignAndGetGeneratedId() if the view has no id ( 0 / View.NO_ID ), and returns the id of the View, existing or just generated. Download \u00b6 implementation ( \"com.louiscad.splitties:splitties-views:3.0.0-beta01\" )","title":"views"},{"location":"3/views/#views","text":"Extensions function and properties on View s. Supported platforms: Android .","title":"Views"},{"location":"3/views/#content","text":"This split includes extensions on view related classes. They are helpful when dealing with views programmatically.","title":"Content"},{"location":"3/views/#depends-on-androidx-core-ktx","text":"Android core KTX already bundles its share of useful extensions for Views. For example, it includes View visibility extension properties like isVisible . To avoid duplication, Splitties deprecated symbols made redundant by Android core KTX, and included the dependency transitively instead.","title":"Depends on AndroidX core KTX"},{"location":"3/views/#view-background-properties","text":"bg is an alias to the background property for View, but works below API 16, using setBackgroundDrawable(\u2026)`. backgroundColor allows to set the background color of a View using property syntax.","title":"View background properties"},{"location":"3/views/#imageview-properties","text":"imageResource allows to set the image of an ImageView from a resource id using property syntax. imageDrawable allows to get, set or clear the image of an ImageView with a Drawable? using property syntax. imageBitmap allows to set the image of an ImageView from a BitMap using property syntax.","title":"ImageView properties"},{"location":"3/views/#layout-direction-properties","text":"isLtr extension property for View is true on API 16 and lower, or when the layout direction is left to right (like in English). isRtl is !isLtr . Would be true on an API 17+ device setup in Arabic or another RTL language, or when the device is forced to RTL in developer options.","title":"Layout direction properties"},{"location":"3/views/#view-padding-properties","text":"The following extension properties allow to set the padding of a View using property syntax: padding horizontalPadding verticalPadding topPadding bottomPadding You can also use the setPaddingDp extension function that offers default parameter values.","title":"View padding properties"},{"location":"3/views/#edittext-extensions","text":"type allows to set the input type in a typesafe and more readable way using the InputType inline class (lots of \u201ctype\u201d occurrences in this sentence).","title":"EditText extensions"},{"location":"3/views/#textview-extensions","text":"textResource allows to set the text of a TextView from a string resource id using property syntax. textColorResource allows to set the color of the text of a TextView from a color resource id using property syntax. textAppearance allows to set the text appearance of a TextView from a text appearance style resource id using property syntax, even below API 23. lines allows to set the exact number of lines of a TextView using property syntax. centerText() sets gravity to center and center aligns the text. alignTextToStart() sets gravity to start and start aligns the text. alignTextToEnd() sets gravity to end and end aligns the text. setCompoundDrawables(\u2026) takes Drawable? parameters for start , top , end and bottom which all default to null , plus an intrinsicBounds parameter that defaults to false . setCompoundDrawables(\u2026) has an overload which takes drawable resource ids that default to 0 (no drawable) but no intrinsicBounds parameter (as it is implicitly true). clearCompoundDrawables() clears all compound drawables the TextView has.","title":"TextView extensions"},{"location":"3/views/#click","text":"onClick { \u2026 } extension method for View avoids it shadowing if you have other lambdas, while also being more expressive than setOnClickListener { \u2026 } . onLongClick { \u2026 } is similar to onClick { \u2026 } , but also removes the need to have an extra line in the lambda to return true or false .","title":"Click"},{"location":"3/views/#layoutinflater","text":"LayoutInflater , Context and ViewGroup have an inflate extension function that make inflating xml easy thanks to type parameter. There\u2019s also an inflateAndAttach extension function for ViewGroup .","title":"LayoutInflater"},{"location":"3/views/#gravity-flags-aliases","text":"Using Gravity constants on Android is a bit verbose. To alleviate this small issue, this split provides extension properties for View which start with gravity . They cover most use cases and play well with autocomplete. Example: Without Splitties : Gravity.START or Gravity.CENTER_VERTICAL With Splitties : gravityStartCenter List of supported Gravity flags: gravityCenter gravityCenterVertical gravityCenterHorizontal gravityVerticalCenter gravityHorizontalCenter gravityStart gravityTop gravityEnd gravityBottom gravityStartBottom gravityStartTop gravityEndBottom gravityEndTop gravityBottomStart (alias to gravityStartBottom) gravityTopStart (alias to gravityStartTop) gravityBottomEnd (alias to gravityEndBottom) gravityTopEnd (alias to gravityEndTop) gravityStartCenter gravityEndCenter gravityTopCenter gravityBottomCenter","title":"Gravity flags aliases"},{"location":"3/views/#other","text":"The generateViewId() top level function is a backwards compatible and more efficient version of View.generateViewId() that was introduced in Android API 17. The assignAndGetGeneratedId() extension function for View calls generateViewId() assigns it to the view and returns new generated id. The existingOrNewId extension property for View calls assignAndGetGeneratedId() if the view has no id ( 0 / View.NO_ID ), and returns the id of the View, existing or just generated.","title":"Other"},{"location":"3/views/#download","text":"implementation ( \"com.louiscad.splitties:splitties-views:3.0.0-beta01\" )","title":"Download"}]}